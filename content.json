[{"title":"PONDER","date":"2020-07-11T12:08:40.000Z","path":"2020/07/11/PONDER/","text":"关于行业&amp;领域的一些思考——产品溢价&amp;AR/VR&amp;机器学习的落地 产品溢价首先产品溢价是一个自创的概念，我把它定义为由于某产品的价值较高，而导致其周边产品的价值也偏高的现象。 品牌溢价是我们所熟悉的，而且很多企业都很好的利用了这种“感情价值”，这是一种消费心理所导致的现象，其直接表现就是品牌的附加值，这部分投入其实在一定程度是集中在了运营和市场，以及现在很火热的舆情。 这其实也属于我们所期待的市场的一种形态。 高附加值产品就是一个长久的资本企业所追求的核心要义，只不过市场让其变得复杂了，这种高附加值可以通过技术的垄断、资源的占有、市场和品牌的运营、甚至甲方的愚蠢（信息不对等）而产生。 附加价值是企业通过生产过程所新增加的价值;或者，从企业的销售额中扣除供生产之用而自其他企业购人的原材料成本，也就是企业的纯生产额。 到底怎么样的附加值产生方式更健康，很难靠一家之言蔽之。我想要讨论的也是一种附加价值的产生方式——产品溢价的方式。 众所周知，苹果手机的手机壳比小米手机的手机壳要昂贵很多，又比如同样非品牌的咖啡店，昂贵地段的咖啡的周边要比便宜地段咖啡的周边售价高很多，现有（也可能是我仍未知的）的一些价值理论无法解释这种情况，这并不是简单的附加价值，其仅仅是由于该产品所服务的产品价值更高，所以该产品相对价值更高。我将其称为产品溢价。 其实这是一种公知或者说是常识，我们想当然的认为装珍珠的袋子比装石头的袋子更加精致（当然有些情况下确实如此），所以面对价值更高的产品，我们会在后续愿意花费更多钱在相关的产品上，价值更高包括售价更高，但不限于此。比如二次元手办，其价值不只是来源于精致的细节刻画，更多的来源于消费者对其原型的一种感情价值，消费者愿意为此买单，但周边手办不全是创造原型的产业生产的，这就出现了产品溢价——二次元形象被创出的时候成本包括设计到剧本人设故事情节到美工以及后期的市场运营，涉及到甲公司的方方面面，这些时间人力物力成本造就了这个产品，但甲公司的收益大头往往是直接的版权费以及一部分周边带来的盈利，但其产品，如设计的二次元形象，还有很多的潜在价值尚未被利用和挖掘，比如众多需要被授权才能商用的方面——邮票、游戏、图书、舞台剧等等，如果是拿到了版权费，那说明这是一个健康的市场，但更多情况，大型的IP是无法保证不被侵权的，这种情况下的周边，就是产品溢价的情况，其利用了原作品的价值的溢价（高附加值也好，感情价值也好），来提高了周边的产品价值，从而获得了商业利益。下面把原作品称作主产品，原作品的周边、延申、配件等称作从产品。 类似案例还有很多，很多情况下不涉及侵权，而可以正大光明的利用产品溢价来提高我们的产品价值，从而获得利益。其不限于影视艺术作品的这种溢价（不得不说这种情况很常见），包括汽车内饰，同样的摆件，作为礼物可能只有十五元，但作为汽车摆件就需要五十元（汽车是主产品）；同样的计时器，用于做饭只能卖十元，但当作番茄闹钟用于自习（番茄闹钟学习法和学习本身是主产品），就可以卖一百元…这种情况还很多，如果可以找到合适的又具有很大市场的主产品，就可以通过产品溢价的原理，由从产品获得很大的利益。 这是一种商业思路，同时也是一种产品设计思路，本文仅仅举例阐述产品溢价这种规律和效应，由于用例有限，还只能作为一种思想，有待调整和证明。 AR/VRAR和VR是我一直关注的领域（我把MR视为AR的升级和迭代，一定要区分的话，MR更侧重虚拟图像的现实感，AR更侧重信息量，但MR的要求明显更高，AR包括MR）。 我一直相信这两个领域会在以后让人们的生活方式发生翻天覆地的变化，就像电视，就像手机等，其不仅仅是一种更真实的画面处理，其在客户端是一场人机交互的革命。 不论是各大巨头（微软、苹果为首），还是各种新型创业公司（亮风台等）都早已入场，B端用户也在试图找到出口（如腾讯），但效果都不如人意。由于5G技术的发展，AR和VR又站在了资本的舞台上，我的理解里，5G更多的是降低AR和VR的运动到成像的时延，其价值后文再进行深究。 AR\\VR领域已经发展十余年了，其仍旧更像是一个概念，和人们的生活相距甚远。微软已经把AR推向了工业生产，更安全、高效的辅助道具，从软件到硬件，国内的领头羊也把toB作为了主要方向，这是很多人尝试后的结果，但即便如此，此领域的公司盈利还遥遥无期。 我多次思考，这个技术到底缺了什么，是交互性，是成本过高，亦或是落地困难…当一件事找不到答案时，我们习惯于在以往的经验中进行类比思考。 我认为AR和VR的核心是交互革命，而这种交互对自然语言的处理要求更高，用户需要通过更简单的方式，更小的可佩戴硬件，向计算机传达指令，有一种方式十分适合AR/VR——手势，这就需要人工智能以及机器学习的帮助，自然语言识别的增强和反馈。 成本从来都不应该给用户来考虑，如果无法普及，只能证明工业生产和资本运作的方式不对，以至于一个有价值的技术和产品只限于少数人，当然这个技术或者产品必须是有价值的，最好解决了用户的痛点（汽车），或者其娱乐性所向睥睨（影视），我认为，为了行业的发展，这个技术的切入点的最佳解可能并不是优化生产效率，我认为一款足够优秀的游戏作品可以吸引更多的用户，更多的用户可以吸引更多的资本，如此才能把整个行业盘活。3A大作并不少，或许游戏会像电影促进建模仿生技术发展那样，促进AR和VR的发展呢。 落地需要更实际的场景，人工智能的落地其实并不如人意，但人工智能有前面的大数据和后面的云服务，两座浪把人工智能推的舒舒服服的，AR\\VR领域就缺少了这种相关领域，所以才会感觉后劲不足，但这个领域的价值如果存在，那么找到靠山其实并不困难，这需要我更深造，学的更广泛和深刻，才能感知到两种技术可能发生的化学反应吧。 我在淘宝上看到了一款很基础的AR游戏——射箭（通过手机屏幕，连接实体的发射器，实现AR）。这很上面的分析和观点论证——一种技术的兴起，能称之为革命，一定是解决了巨大的痛点或者是在娱乐（消费）方面有所突破，而游戏正正拥有着这个娱乐时代的顶流，FPS类游戏的核心就是第一人称视角对真实战争的模拟，强调代入感，而大型游戏机中的射击类游戏也很受欢迎，这正是AR或者VR的用武之地。但就FPS游戏的设计角度，需要实现游戏中第一人称移动方面的人机交互，更吸引玩家和资本的RPG类游戏中，移动方面的人机交互也是核心，如果实现了这种交互方式，那么加上VR技术，我想应该可以把游戏体验提高到一个很高的高度了。 AR和VR的应用面还很广泛，很多前辈和老师也在探索，就我认为，家装和游戏应该是两个很好的方向，资本很足，也解决了足够的痛点，但家装只是提高服务方面的用户体验，并不属于用户买单的核心产品，所以用户可能并不会为此买单，即使现有的案例中可以看出效果其实尚可。接下来我会尽可能深刻一些的分析游戏中移动方面的交互实现方向以及可能的方式。 先从人机交互说起。 人机交互现在最大最热的几个方向技术——语音交互技术、图像识别技术、AR和VR以及体感交互技术。语音交互自然不必多说，这可以说是现在处理自然语言最成熟的技术，键盘鼠标相对原始的人机交互，需要人类自己通过学习，把希望表达的内容和信息转化为字符，再从输入设备输入，而语音交互则不需要用户进行这样的学习，其交互更接近人类的生活习惯，国内的科大讯飞在这方面很成功。当然不论是文本的输入，还是语音的信息处理输入，都是建立在广义的自然语言识别（NLP）的基础上进行的，由于自然语言的种类情景多变，但传达的信息却可以分类，所以随着机器学习的兴起，NLP也成了大热的研究方向，通过聚类的分析等（学识有限），对自然语言进行识别处理，随后进行计算，再通过自然语言生成系统输出，这也就是计算机作为一种工具，在用户层最本质的逻辑。 已经说到了这些机器学习的大热方向，也就这样的方向继续聊聊吧。 当下计算机的算法方面比较火热的三个方面，自然语言识别（NLP）、计算机视觉（CV）、推荐系统。这三个方面都和大热的机器学习有些关联，NLP是分割字段，提取关键词后构建语义向量，然后再将语义组合，通过机器学习进行聚类等分析；CV则是先通过边缘监测，提取图中的核心区域，然后通过特征选择，一般为过滤法（还包括包裹式和嵌入式），进行降维和泛化，然后进行分类，再训练学习器；推荐系统则分为选择用户还是产品，以用户为例，提取其物品特征，然后构建网络进行分类，对其进行打分和聚类分析，训练学习器。 可以看出，三个方面大热的主要原因都在学习器，学习器大大降低了本来的数据分析成本，而深度学习正是由大数据延伸出的技术，推荐系统正是大数据浪潮中的数据分析的常用模型，由于巨大的商业价值（用户粘性）而站在了，而NLP和CV则都用到了表征学习方面的内容，如向量化后构建网络，深度学习则是更基础的内容。常用的深度学习框架又有深度神经网络、卷积神经网络、深度置信网络和循环神经网络等。 深度学习是一种对数据进行表征学习的算法，如用向量去表示关键词和子图，然后用（非）监督学习对目标特征提取。表征学习的特点我引用维基百科上的描述：“表征学习的目标是寻求更好的表示方法并创建更好的模型来从大规模未标记数据中学习这些表示方法。表示方法来自神经科学，并松散地创建在类似神经系统中的信息处理和对通信模式的理解上”。 人工智能+大数据&gt;机器学习&gt;深度学习&gt;神经网络，而这些数据的类型的不同则决定了深度学习所发力的领域了。 扯到了很远，但其实都很基础，计算机发展迅速，若想在学术上有所造诣，只能专精一个方向啊，但是如果是商业实现，那么重点在落地了，这也是本文第三部分想说的东西。说回人机交互的大热领域，解释完了语音识别后，图像识别也就是CV的方向了，也使用了深度学习的模型，只不过是更明确的目标，可以使用监督学习来达到目标。 AR、VR以及体感技术，前两者是本节主要讨论的目标，把他们归类在交互中其实有所牵强，因为这两个的目的都是沉浸感，不仅仅是交互，其中重点更是在移动和显示等方面，可以理解为上面的自然语言生成的一种革命，而其余的交互更多的是自然语言处理的进化，我想这个道理还是想的明白的。体感技术则是人们通过肢体动作，与周围环境和装置直接互动，相比于语音、语言，这种交互的情况更复杂，类型更多，我的学识有限，并不知道是否一样可以通过向量化来进行处理，并通过训练学习器来优化这种处理效率和结果。 一样的，面对陌生的无头绪的问题，我们可以通过类似的案例，进行类比分析来找到出路，接下来我将介绍和分析科大讯飞的人机交互解决方案AIUI。 AIUI除了升级了无效拒识、纠错、上下文理解能力，还加入了语境和情感分析，在交互的角度来看，AIUI在交互链路中增加了语音唤醒系统。AIUI的人机交互流程分为感知、认知、处理、表达四部分。在AIUI中有3种不同交互理解功能的设计：任务完成型的交互理解、基于知识图谱的知识问答类型、基于问答库的闲聊或问答。而这些技术中最核心和困难的就是语义的提取，语义提取又分为显规则提取和基于深度学习的语义提取。对于自然语言的处理（NLP），需要更多的依靠深度学习中的RNN循环神经网络和CNN卷积神经网络。而语义提取其实是NLP中的自然语言理解（NLU）的工作，而NLU的困难同时也是核心工作，其实是对文本序列背后的特定语义结构进行预测，这是中文分词、词性标注、命名实体识别、共指消解、句法分析、语义角色标注等工作的基础，这需要更完备高效的语义结构，这样才能进行归类和预测。 相比于更倾向于办公效率优化和辅助的AR（增强现实），我认为VR更容易造就游戏界的革命，最追求沉浸式体验的产业当属游戏领域。 类比语音识别前，我先聊聊沉浸式体验。 不得不说，我想要记录下来的东西很多，很杂，但我认为，知识要的不是专精，专精是精于一个问题，一个领域，一个细节的处理与优化，所以我希望在讨论VR的时候，尽可能不要遗漏与其有关的任何部分。 沉浸式在字面意义上其实很好了解，在安卓开发中，沉浸式设计就是把安卓系统边框透明化，并且把交互按钮尽可能隐藏，使用APP的主要内容尽可能的填满屏幕；而在电影和文学设计中，则讲究通过镜头语言，实现表达、内容结构、形式与意义的关系（叙事学），叙事学是在《十日谈》中被提出的概念，其讲究的是一种表里关系，后来这种理论和概念在空间设计中也常常被提及，很成功的案例，如迪士尼，就是标准的沉浸式设计。但这些其实并不直观，就我的理解，沉浸式其实是从用户体验的角度来说的，所以我认为，任何可以使用户获得沉浸式体验的设计，都能称为沉浸式设计（当然引人入胜的诗词、山川，那不能称为设计，设计应该是有意识和目的的），沉浸式如果要从心理学的角度分析，那应该是心流体验的代言词，或者说，心流体验应该是沉浸式体验的更深刻更持久更强烈的状态，心流体验更强调认知和意识，而沉浸式体验更强调感官。沉浸式设计最普遍承认的是叙事型设计（赵江洪的《设计心理学》），即通过讲故事，通过气氛角色情节等等来让用户带入其中，迪士尼就具有很强的叙事性；在游戏设计中则是把各种导航和操作交互藏在内容为主的情景中，这样就让用户把注意力更多的集中在游戏的主要内容上，更沉浸其中，如王者荣耀的方向键是隐藏的，DNF中主线的触发、技能的学习和装备的升级等都是通过和NPC交流实现的，这样玩家注意力可以更集中于游戏本身，从而获得更好的体验，当然除了这种隐藏式的设计，还有画面、操作、反馈和节奏等都是很重要的因素，通过这些部分的设计也可以达到沉浸式体验的效果。但显然这个原理并不是很试用于VR的设计。 VR的沉浸式设计其实很明确，即通过声音和视觉（3D、动态视角，高FOV）,加上体感交互，就可以实现现实和虚拟的颠倒，这也是VR的革命之处。 接下来我将分析VR技术需要解决的一些问题。 晕动症——由于延迟，清晰度——人眼要求中心像素高，GPU不足；以及我最想谈的交互方式。VR的交互和传统交互不同，VR作为一种输出设备，必定需要输入设备来与之搭配，双手交互的精度和处理效率要求很高，双手柄的交互方式则对用户和硬件要求较高。 对于VR的玩法，先引用XboxOne 平台的体感游戏开发团队的日志—— 由于头部运动追踪的存在, 点头和摇头的操作是可以被识别的, 这就意味着很多 Yes/No的操作可以直接通过头显输入；头部的朝向可以灵活变化, 当你”盯”着某个物体看时,可以针对这个行为做出相应指令, 具体可以参考 GearVR 上的 Land’sEnd；由于360度视角方向不受限制, 我们可以在背后做一些场景改变,让每次转头看到的场景都不一样, 既能做成惊喜, 也能做成惊吓；头部不仅仅可以转动,还可以配合身体小范围移动, 比如 Summer Lesson 中凑近 NPC, NPC 会害羞……Vive的一个上帝视角 Demo 可以蹲下看到地底下打地道的小兵；VR 渲染可以调整 WorldScale,即世界单位缩放, 相当于动态调整自身相对于场景的比例, 既可以做成巨人的视角,也能做成蚁人的视角；因为 VR 世界中的单位可以与现实不一样,那么一些类似”缩地术”的功能也变成现实, 通过身体小范围的移动,达到虚拟世界中的大范围移动效果；双手控制器的存在可以模拟一些抓, 扔, 摸,打等的操作, 捡起一个道具上下左右仔细看也是很有意思的一件事,可以把迷题设计在道具的隐藏角落里；VR 中有了双手的存在,很多解迷机关就不再是简单的按一个键, 各种零件组合, 机械,绘画等对于双手控制器来说都是很棒的操作体验；控制器的握持感,非常接近于游戏中的手持武器, 比如枪械, 比如刀剑,这比握着一个鼠标或者手柄的感觉强多了. 得益于高精度的传感器,做出具有竞技性的操作玩法也不是不可能；双手具有天然的空间感,一些建造类的玩法也非常适合, 比如 MineCraft, 比如 Besiege 等, UE4 甚至尝试了在 VR中进行场景编辑；由于3D 音效的加强(下面会提到), “听音辨位”就可以做得更真实,各种潜入类玩法非常适合；另外, 由于沉浸感的增强,恐怖游戏和XX游戏带给人的感官刺激会放大, 这就不用展开了, 试过就知道。 对于VR的游戏方面我研究还有限，前辈的想法颇多，特此记录，以便往后反复思量。 我认为VR的移动交互是很需要实现的内容，第一人称视角的自由移动，HTC的解决方案也只能做到5m×5m，是否可以做到模拟真实的运动场地呢，如果可以实现，那么通过传感器来记录动作和模拟距离其实很容易实现。 是否有这样的设备呢，可以记录移动，并且给人真实的移动感。作为沉浸式体验，当然想要虚拟人类的各种感官，VR更多的是在视觉和听觉上进行模拟，而在游戏中，不可忽略的部分当属移动，移动也是最大化自由视角的重要方式。那么有什么方式可以模拟出移动呢，我简单的举一些例子： 摇杆，很经典的游戏移动的交互方式；键盘，由于VR，可能需要进行虚拟；螺旋仪，需要用户进行接受和适应；手柄，当前比较好的解决方式。 其实我认为，具体的操作方式最好按照不同的游戏来进行设计，如竞速类游戏，就可以简单的通过手部交互来满足游戏需求，如果一定要移动，那可以通过机甲等元素来实现，这样玩家更容易接受和适应，整个游戏设计的叙事性也更强更完整，虚拟的也更彻底。考虑到成本问题，我认为VR方面的交互可以有新的思路，比如把电脑设备的显示屏接入在VR的视野中（3D，VR），其他的部分（如键盘，甚至显示屏（护眼，沉浸式学习工作））仍然全是虚拟的，这样用户的交互都放在VR中实现，这样算是实现了VR的整个逻辑。 接下来我将梳理一下VR的制作流程，以及游戏的制作，然后类比语音交互，尝试引入机器学习来提高VR相关工作的效率并降低其成本。 VR分两大种，实景拍摄（通过全景合成软件制作3D）和3D建模，3D建模又分为第一视角是否可以移动。3D建模一般使用unity或者UE实现，关于unity和UE这两种引擎，我并不了解，这里借用一些前辈的观点加之我的理解和总结，记录后以便反复思量。 UE比起开源的unity成本更高，同时也更适应于高端设备的显示效果（3a大作），unity则更适合在移动设备或者web上进行开发。学习路线（unity）：C#-SQL-EFCore-web&amp;TCP/http-Lua。有前辈提到，UE作为游戏引擎，可视化设计器做的很优秀，但由于托鼠标造成的项目冗余过高，只能重构轮子，导致效率降低，总之，UE相对来说对美术生更友好，而对于程序员来说，可能门槛降低带来的代价还是过于沉重，不过也因此，Unity更适合单人项目，UE在制作时更需要团队的支持。Ogre3D中文站站长有句话很棒，希望我以后如果从事相关工作也可以谨记——图形学的天花板在硬件，引擎绝不是阻碍你的原因。 继续分析VR的基础内容。 VR之所以可以沉浸式，是因为用户视角在一个三维空间中，这就要求将本身的全景二维图，投影到一个立体的空间（如球面纹理映射）。对于VR的播放器，如VRPlayer，还有开源的VR开发可以使用Google的主页——https://developers.google.com/vr/。（在googlevr sdk for android中 有一个cardboard的sample——treasurehunt，研究源码可以快速学习）；关于硬件方面，涉及到第一视角移动和体感交互，常常使用九轴传感器（加速度传感器、磁力计、陀螺仪），需要考虑的有瞳距、FOV、畸变、ViewPortRect等。 接下来就是VR方面的开发，SteamVR插件是全免费的（Valve），此外我们还需要一个VR设备以方便我们的调试，以游戏开发为例（http://robotinvader.com/blog/（deadsecret），函数查询http://wiki.ceeger.com/ceeger.php）。 再简单介绍VR之后，我还想提一下计算机图形学。 在games的前几个论文，大部分都是把3D和神经网络相结合，获得一个智能化的东西，或者用图形学解决实用的问题，计算机图形学更多的是解决3D的问题。3D和VR有天然的桥梁，我想这就是把机器学习引入VR的大好渠道。 加之语音交互中人工智能的解决方案的参考，会发现VR的几个问题很需要人工智能来解决，比如帧数，晕动症，这种问题完全可以通过机器学习来预测用户的下一步动作，而早做准备，提前进行画面渲染等。 如果希望把机器学习和VR结合，还需要多研究计算机图形学的前沿论文，相信这样也可以更快的找到答案。 机器学习的落地机器学习相关的历史和研究方向在上面两部分已经讨论过了，这三部分看似不是很相关，但深入思考，会发现这三个命题之间的关系千丝万缕。 想要迎合现在的市场风口和计算机发展的方向，不可避免的需要涉及到机器学习的内容，而VR/AR在20年被苹果公司提上了日程，虽然很遗憾的，由于其内部分歧，AR眼镜的发布被推迟了，但最晚22年也会与世人相见，同样的20年5月，UE5问世，学疏才浅，我简单的了解后，仍旧无法判断UE5是否可以解决VR游戏的巨大问题，并且在我的理解中，UE或者是unity更多的是类似于Axure这种涉及软件，是另一领域的高级UI设计，所以可能并不适合我，相比来说，我更希望从事底层的研究。 AR/VR的话，我认为做成我的世界一样的沙盒游戏也是很棒的方向，可以避免性能方面的不足，同时可以得到很棒的游戏体验，渲染的要求也较低；或者是沉浸式办公学习的产品，难度其实很有限，像面对面的聊天，已经被实现了，这种产品的开发门槛同样需要被考量。 回到机器学习，对于机器学习的就业和研究方向，我看到越来越多的前辈呼吁，一是要交叉，交叉学科才是硬道理；二是要落地，机器学习要落地到工业生产，在学习器模型已经比较成熟的情况下，是否可以融会贯通，不仅仅是调参，而是和实际的工业生产相结合，产生真正的商业价值，这才是市场和资本需要的能力和技术。 所以下面我就机器学习和AR/VR以及其他学科的交叉领域，在相关的领域中落地，产生商业价值，解决市场痛点等方面，进一步思索。 微软早在2017年便开源了一个“空中信息与机器人平台”，这是一款通过高级虚拟现实训练人工智能的系统。可通过在VR的虚拟环境中模拟无数有细节差异的场景对无人机进行训练。节省了大量枯燥无味且耗时巨大的工作，同时还能全面彻底的对无人机进行障碍物覆盖。这个系统同样适用于无人驾驶的领域，这种通过VR协助人工智能的思路是很值得学习的。 此外关于VR游戏，对于游戏设计，和普通游戏有所不同。就来自First ContactEntertainment公司的AdamOrth的观点，在虚拟现实开发者大会上（2017），除了包括一些经验之谈，如他提醒游戏开发者，不要将环境设置得过于复杂，阻碍玩家对游戏的探索。如果在一款游戏里玩家无法自由移动，那么就不要在游戏世界里设置太多弯弯绕绕，要让玩家的视野尽量开阔——“游戏开发者要确保玩家不会觉得自己错过了游戏世界里的什么东西”；还有，不要把游戏人物或是物体设置在玩家背后，以免吓到他们；人物的可信度远比精细度要来得重要，可以对化身进行简化，以防止模型存在违和感，VR中虚拟人物确实可以表现出肢体语言，即使只有三点数据；此外，还有VR技术本身就提供给玩家一种“临场感”的观点，通过VR捕捉一些感觉，如太空，通过互动创造沉浸感——“你可以利用这个机会来让自己的虚拟世界变得非常真实，但你所写下这一规规则要统一适用于这个世界中的所有物品”以及“让一些高画质的物体离玩家近一点，让一些低画质的东西离他们远些，这能够提升让整个体验的质量”，要确保玩家看到的以及摸得到的东西都很精细；还有很重要的观点和建议——“不要低估了力反馈以及音频在游戏中的作用”。另外还有一个命题，就是多人VR游戏，很前沿的尝试有育碧的《星际迷航：舰桥船员》，但是多人游戏，甚至网络游戏中，如果玩家互动增加，人数增加，延迟的现象会更加严重，从而影响玩家的沉浸感，同时配套的外设也是多人参与中很大的阻碍；要处理的还有玩家之间的空间问题，碰撞、交互以及语音通话等，要保证沉浸感。还有一个很重要的观点，就是建立合理的反馈机制，这也是VR向未来发展很重要的过程。 VR还在试穿和化妆预览、家居装修、推销等领域已经有了落地的实现，这些领域的VR应用往往也伴随着人工智能。 MakeupGenius，这是一个移动应用程序，它使客户可以在决定购买化妆品之前对其进行虚拟试用。该公司声称该技术使用面部跟踪或面部动作捕捉，这是一种计算机视觉技术，可通过实时映射面部标志的64个数据点来确定图像中的图像和视频数据，以确定头部姿势，面部表情和不同的肤色。在嘴唇，脸部和面部轮廓上。该公司还声称，该应用程序的面部识别算法经过培训，可以确定年龄，种族，性别，面部毛发和其他属性。Snapfeet，同样是一个移动应用程序，该应用程序声称可以使购物者根据双脚的3D生物特征扫描来虚拟地穿鞋。据该公司称，在扫描购物者的脚后，该应用程序可以推荐最适合客户的鞋子尺寸和型号。使用从多个角度拍摄的客户脚的照片，该应用程序的生物特征识别功能将创建脚的3D图像。将图像保存在应用程序中后，其算法将对图像进行排列并在生物特征识别就绪后发送通知。家居和商务平台也类似。还有很新颖的思路是营销虚拟现实，类似于用VR来训练学习器，这里是用VR来模拟实际环境中的零售，从而制定营销策略。不可否认，VR头戴式耳机仍旧是阻碍VR落地的主要因素之一。 下面引用一些大牛的观点和思想： 就人工智能对VR产业的推进，工业和信息化部电子第五研究所副所长王蕴辉：一是渲染处理。深度学习的渲染成为人工智能在图像渲染领域的重要创新。二是内容制作。以真实用户的虚拟化和三维重建为发展对象。进一步增强VR内容的交互性，以真实用户为对象的虚拟化身成为近期的热点，传统的方法依靠的是昂贵的设备和繁琐的后期处理，新一代的方法是基于深度学习技术，通过学习知识可以从一个或者是多个二维头像中，恢复物体的三维几何和结构，而无需复杂的过程。三是感知交互，通过结合计算机视觉与生理信号的反馈，打造虚实结合的体验。VR技术大大提升了VR的体验。 多伦多大学计算机科学系教授基罗斯.库图拉科斯：主动3D成像将在清晰度和分辨率上改善VR/AR。3D相机对于虚拟现实产业的发展有着非常重要的作用。3D相机其实和我们之前所使用的相机完全不同，这些3D相机可以测量距离，通过加工光线的强弱来测量照相的距离，并且可以对周边的环境进行一些测量，他们可以应用到手机、耳机、眼镜等等里面，或者可以放在车上。我们所研发出的这个相机，它有很多的体系，能够引入到很多的体系中，也就是我们称为主动的3D成像，可以用在我们的经济体系中，通过使用这种主动的3D成像技术之后，可以进行建立3D的成像体系。相机里面有不同的系统，它们在设计的时候，就可以应用到很多复杂的应用中。而且成本也可以有所控制，这些设备其实能够使用不同的技术、高端的或者光速技术，以及能够使用商业的扫描技术中，而且可以在很长的距离中，可以实现3D成像技术。而且他的精度也很高，它的清晰度、分辨率都很高，能达到微米级的距离。因为使用的是三角测量的方式，它的准确度很高，而且短距离和长距离的摄影效果都非常好。这种相机目前是高端技术，它的价格可能会稍微高，它可以使用很多的3D的成像点进行连接。 叠境数字公司联合创始人、CTO JasonYang：利用深度学习实现更少拍摄带来更精准重现。表情研究、表情分析在AI中的应用以及VR中的应用越来越广泛。我们公司的业务之一是对表情进行分析研究。 加州理工学院计算与数学科学教授马修.德布伦：机器学习与粗粒化研究相结合，能够提升模拟的精准度。人工智能、虚拟现实可以在很多方面帮助我们进行改进，获得提高。比如利用虚拟现实与人工智能结合进行外科手术培训，可以帮助医生提升以后手术的精准度。比如我们通过人工智能、虚拟现实的方式进行检测、测试肝脏在进行手术的种种情况，让外科医生了解在手术过程中怎么样操作才能更好。 特尔VFX特效负责人、电影艺术学院成员赫莲娜·派克：在虚实现实中，我们通过人工智能帮助我们塑造自然的环境，把人的情绪植入到虚拟世界中。比如《复仇者联盟》，他们使用的就是渲染以及人工智能和塑造建模的方式，提升动作上的相互匹配度、数字化人物的灵活度。目前，我们可以使用人工智能的方式把人和场景进行分割，可以把人区分出来放在不同的场景中。还通过粒子的模拟方式，帮助我们进行仿真，比如对火、烟、水进行仿真，通过人工智能仿真可以看清火的特性、形状，以人工智能的方式将其创造出来。我们希望缩短模拟仿真时间，也在致力于通过手机就能完成，加速我们拥有更多更好的VR方面体验感。 中国移动研究院云VR项目负责人李可：5G、AI与VR密不可分。一些痛点：第一是我们希望VR业务能变成大众型的业务，能走进千家万户，但目前高端VR设备依然比较昂贵。第二是VR设备便携性不够。VR头盔在工作单位、工厂里可以用，但是在家里放一个很复杂的VR设备就不太现实。第三是目前VR设备用户体验感尚无法达到替代手机和平板电脑。所以VR/AR在价格、便携性和体验上还有很多工作要推进。而5G的传输能力和边缘网络的计算能力，可以增强VR设备的处理能力，降低设备的价格。5G和4G的区别是边缘网络和边缘计算能力的增强，这对无论是游戏还是渲染业务都非常有帮助。AI与VR一直密不可分，VR本身就是AI技术的一个分支，VR对于位置、运动追踪，都依赖于AI的能力。所以5G和AI能力对于VR业务非常重要同时也密不可分。 最后还有Facebook利用机器学习为移动VR构建的全新低延迟高效能图形渲染框架，论文地址为https://dl.acm.org/doi/10.1145/3355088.3365154。团队介绍了一个为VR一体机的渲染管道运行机器学习的全新低延迟高效能框架。这个架构允许所述设备利用机器学习来显著提升图像质量和视频渲染。研究人员根据这一框架创建了一个示例应用，它能够重建更高分辨率的渲染（称为超分辨率），以最少的计算资源提高移动芯片组的VR图形保真度。这个全新框架同时可以用于执行面向的流式传输内容时的压缩伪影去除，帧预测，特征分析，以及针对引导式注视点渲染的反馈。 了解了这么多想法，再来看一看VR和人工智能以及落地的问题。 VR在原理上有个需要解决的问题是分辨率，由于畸变和FOV值，分辨率一定要解决；VR在游戏中需要解决的问题，一个是延迟，多人游戏的问题也是延迟，会影响用户的沉浸感，二个是交互，交互包括NPC的表达以及反馈机制等，体感是一个方向，但带来的问题也不小；VR在使用方面，可以对人工智能甚至营销策略进行训练和优化，很多实验，可以通过VR对现实进行捕捉，如电影中的科幻模型，但这更偏向于3D的领域；VR的直接使用还有对表情的捕捉和管理，这可能也是CV的交叉，同时可能涉及到心理学，以及3D相机，通过人工智能测距测温达到直接生成VR的效果，也是属于VR这个大命题的主战场了。最后是硬件方面，VR产业除了需要3D相机外，还有必不可少的头戴式外设，价格昂贵，其功能还是无法触及和解决人群的痛点，很难像计算机一样普及起来，这也成了很多领域推广VR的巨大阻力。 VR需要解决延迟，分辨率，交互，外设，生产成本，模型的诸多相关内容等。 关于机器学习的应用，可以解决延迟，通过预测下一帧；解决分辨率，同样通过预测；解决交互，以体感为主，其实不是VR方向了，只是体感更接近沉浸式体验，更和VR同源；解决生产成本，直接拍摄出VR的3D环境，快速搭建VR场景，这需要通过人工智能来实现；再有就是游戏方面的提高了，通过人工智能制造出有感情的NPC，这其实是计算机视觉的活。 接下来是两个我深以为然的观点： 「对于绝大部分人而言，努力成为交叉领域的熟手，远比成为计算机科学家要现实且有意义」。 能够站在机器学习“工程体系”之上，综合考虑“模型结构”，“工程限制”，“问题目标”的算法“工程师”。 这句来自于清华毕业的王喆老师。 技术需要服务于目标。 朱小强在“深度学习推荐系统”这本书作序时写的一段话结尾: 在工业级深度学习2.0阶段，技术演进的模式将再升级：从算法视角的实践和问题驱动，进一步拓展到更宏大的技术体系整体思考：领域问题特性、数据、算力、算法、架构及工程系统等将被纳入统一的思考框架中，成为技术创新的发力点。 工业界和资本需要的是可以把技术落地的，可以把学术连接到工业界，从而灵活解决问题的人才；而学校和人类需要的是专精一个领域以及从理论开始研究并搭建高楼的人才。 人工智能的落地已经在很多产业实现，或是解决巨大痛点，又或是产生商业价值，就VR的落地成本和复用仍旧需要探索。 本来感觉真相很近了，写到头，思索到失去焦点，才感觉真相仍旧遥不可及。大概这就未了解一个领域，会感觉简单清晰，但逐渐了解一个方向和领域后，才感觉到一无所知，才开始明白需要解决的问题，可能遇到的困境，每一条路都不易。 希望自己在以后谨记此时的思索，进入这片领域的海洋后，心里仍旧有方向，思索仍旧不止。","tags":[{"name":"x","slug":"x","permalink":"http://yoursite.com/tags/x/"}]},{"title":"x+","date":"2020-05-27T09:22:47.000Z","path":"2020/05/27/x-1/","text":"X+==== LeetCode刷题先做五个tag：array，string，tree，linkedlist，math。 每个tag内部就按照easy-medium-hard的顺序做，开始一天刷10道easy，后续保持。 其实，从2019开始，业界对AI的技术方向就已经达成了共识，也就是深度学习+大数据+大计算，其中尤其以数据为重。可以说只要数据足够，假以时日，大家的速度和精度都不会太差。现在大家比拼主要是算法变现的能力，也就是看谁能够把算法变成产品销售出去，因此今年我的感觉是，相对于纯粹的算法，综合性人才更稀缺，例如有既有产品思维，懂算法，懂编程的人。 ——知乎_沈世钧 数据科学数据工程师前 5 项主要技能是：SQL, Java, Python, Hadoop, 和Linux。第一步学Java基础, 或者Python；第二步学习系统语言最少掌握LINUX；第三步掌握一门数据库语言 ORACLE /DB2；第四步学习SHELL编程；第五步学习hadoop/spark生态圈. 数据挖掘工程师数据挖掘 =业务知识 + 自然语言处理技术（ NLP ） + 计算机视觉技术（ CV ） + 机器学习 / 深度学习（ ML/DL ） 大数据学习路线java(Java se,javaweb)Linux(shell,高并发架构,lucene,solr)Hadoop(Hadoop,HDFS,Mapreduce,yarn,hive,hbase,sqoop,zookeeper,flume)机器学习(R,mahout)Storm(Storm,kafka,redis)Spark(scala,spark,spark core,spark sql,spark streaming,spark mllib,spark graphx)Python(python,spark python)云计算平台(docker,kvm,openstack) 因此，数据工程师需要掌握通用脚本语言和工具，利用和改进数据分析系统，不断提高数据数量和质量。 精通Java技术知识，熟悉Spark、kafka、Hive、HBase、zookeeper、HDFS、MR等应用设计及开发；了解百python/shell等脚本语言；熟悉大数据平台架构，对ETL、数据仓库等有一定了解。","tags":[{"name":"x","slug":"x","permalink":"http://yoursite.com/tags/x/"}]},{"title":"MySQL_编程一五八俱乐部","date":"2020-05-27T04:22:14.000Z","path":"2020/05/27/MySQL-编程一五八俱乐部/","text":"MySQL学习笔记 登录和退出MySQL服务器12345# 登录MySQL$ mysql -u root -p12345612# 退出MySQL数据库服务器exit; 基本语法12345678910111213141516171819202122232425262728293031323334353637383940-- 显示所有数据库show databases;-- 创建数据库CREATE DATABASE test;-- 切换数据库use test;-- 显示数据库中的所有表show tables;-- 创建数据表CREATE TABLE pet ( name VARCHAR(20), owner VARCHAR(20), species VARCHAR(20), sex CHAR(1), birth DATE, death DATE);-- 查看数据表结构-- describe pet;desc pet;-- 查询表SELECT * from pet;-- 插入数据INSERT INTO pet VALUES (&#39;puffball&#39;, &#39;Diane&#39;, &#39;hamster&#39;, &#39;f&#39;, &#39;1990-03-30&#39;, NULL);-- 修改数据UPDATE pet SET name &#x3D; &#39;squirrel&#39; where owner &#x3D; &#39;Diane&#39;;-- 删除数据DELETE FROM pet where name &#x3D; &#39;squirrel&#39;;-- 删除表DROP TABLE myorder; 建表约束主键约束123456789101112131415161718192021222324252627282930-- 主键约束-- 使某个字段不重复且不得为空，确保表内所有数据的唯一性。CREATE TABLE user ( id INT PRIMARY KEY, name VARCHAR(20));-- 联合主键-- 联合主键中的每个字段都不能为空，并且加起来不能和已设置的联合主键重复。CREATE TABLE user ( id INT, name VARCHAR(20), password VARCHAR(20), PRIMARY KEY(id, name));-- 自增约束-- 自增约束的主键由系统自动递增分配。CREATE TABLE user ( id INT PRIMARY KEY AUTO_INCREMENT, name VARCHAR(20));-- 添加主键约束-- 如果忘记设置主键，还可以通过SQL语句设置（两种方式）：ALTER TABLE user ADD PRIMARY KEY(id);ALTER TABLE user MODIFY id INT PRIMARY KEY;-- 删除主键ALTER TABLE user drop PRIMARY KEY; 唯一主键1234567891011121314-- 建表时创建唯一主键CREATE TABLE user ( id INT, name VARCHAR(20), UNIQUE(name));-- 添加唯一主键-- 如果建表时没有设置唯一建，还可以通过SQL语句设置（两种方式）：ALTER TABLE user ADD UNIQUE(name);ALTER TABLE user MODIFY name VARCHAR(20) UNIQUE;-- 删除唯一主键ALTER TABLE user DROP INDEX name; 非空约束123456789-- 建表时添加非空约束-- 约束某个字段不能为空CREATE TABLE user ( id INT, name VARCHAR(20) NOT NULL);-- 移除非空约束ALTER TABLE user MODIFY name VARCHAR(20); 默认约束12345678910-- 建表时添加默认约束-- 约束某个字段的默认值CREATE TABLE user2 ( id INT, name VARCHAR(20), age INT DEFAULT 10);-- 移除非空约束ALTER TABLE user MODIFY age INT; 外键约束123456789101112131415161718-- 班级CREATE TABLE classes ( id INT PRIMARY KEY, name VARCHAR(20));-- 学生表CREATE TABLE students ( id INT PRIMARY KEY, name VARCHAR(20), -- 这里的 class_id 要和 classes 中的 id 字段相关联 class_id INT, -- 表示 class_id 的值必须来自于 classes 中的 id 字段值 FOREIGN KEY(class_id) REFERENCES classes(id));-- 1. 主表（父表）classes 中没有的数据值，在副表（子表）students 中，是不可以使用的；-- 2. 主表中的记录被副表引用时，主表不可以被删除。 数据库的三大设计范式1NF只要字段值还可以继续拆分，就不满足第一范式。 范式设计得越详细，对某些实际操作可能会更好，但并非都有好处，需要对项目的实际情况进行设定。 2NF在满足第一范式的前提下，其他列都必须完全依赖于主键列。如果出现不完全依赖，只可能发生在联合主键的情况下： 12345678-- 订单表CREATE TABLE myorder ( product_id INT, customer_id INT, product_name VARCHAR(20), customer_name VARCHAR(20), PRIMARY KEY (product_id, customer_id)); 实际上，在这张订单表中，product_name 只依赖于 product_id ，customer_name 只依赖于 customer_id 。也就是说，product_name 和 customer_id 是没用关系的，customer_name 和 product_id 也是没有关系的。 这就不满足第二范式：其他列都必须完全依赖于主键列！ 123456789101112131415CREATE TABLE myorder ( order_id INT PRIMARY KEY, product_id INT, customer_id INT);CREATE TABLE product ( id INT PRIMARY KEY, name VARCHAR(20));CREATE TABLE customer ( id INT PRIMARY KEY, name VARCHAR(20)); 拆分之后，myorder 表中的 product_id 和 customer_id 完全依赖于 order_id 主键，而 product 和 customer 表中的其他字段又完全依赖于主键。满足了第二范式的设计！ 3NF在满足第二范式的前提下，除了主键列之外，其他列之间不能有传递依赖关系。 123456CREATE TABLE myorder ( order_id INT PRIMARY KEY, product_id INT, customer_id INT, customer_phone VARCHAR(15)); 表中的 customer_phone 有可能依赖于 order_id 、 customer_id 两列，也就不满足了第三范式的设计：其他列之间不能有传递依赖关系。 1234567891011CREATE TABLE myorder ( order_id INT PRIMARY KEY, product_id INT, customer_id INT);CREATE TABLE customer ( id INT PRIMARY KEY, name VARCHAR(20), phone VARCHAR(15)); 修改后就不存在其他列之间的传递依赖关系，其他列都只依赖于主键列，满足了第三范式的设计！ 查询练习准备数据123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687-- 创建数据库CREATE DATABASE select_test;-- 切换数据库USE select_test;-- 创建学生表CREATE TABLE student ( no VARCHAR(20) PRIMARY KEY, name VARCHAR(20) NOT NULL, sex VARCHAR(10) NOT NULL, birthday DATE, -- 生日 class VARCHAR(20) -- 所在班级);-- 创建教师表CREATE TABLE teacher ( no VARCHAR(20) PRIMARY KEY, name VARCHAR(20) NOT NULL, sex VARCHAR(10) NOT NULL, birthday DATE, profession VARCHAR(20) NOT NULL, -- 职称 department VARCHAR(20) NOT NULL -- 部门);-- 创建课程表CREATE TABLE course ( no VARCHAR(20) PRIMARY KEY, name VARCHAR(20) NOT NULL, t_no VARCHAR(20) NOT NULL, -- 教师编号 -- 表示该 tno 来自于 teacher 表中的 no 字段值 FOREIGN KEY(t_no) REFERENCES teacher(no) );-- 成绩表CREATE TABLE score ( s_no VARCHAR(20) NOT NULL, -- 学生编号 c_no VARCHAR(20) NOT NULL, -- 课程号 degree DECIMAL, -- 成绩 -- 表示该 s_no, c_no 分别来自于 student, course 表中的 no 字段值 FOREIGN KEY(s_no) REFERENCES student(no), FOREIGN KEY(c_no) REFERENCES course(no), -- 设置 s_no, c_no 为联合主键 PRIMARY KEY(s_no, c_no));-- 查看所有表SHOW TABLES;-- 添加学生表数据INSERT INTO student VALUES(&#39;101&#39;, &#39;曾华&#39;, &#39;男&#39;, &#39;1977-09-01&#39;, &#39;95033&#39;);INSERT INTO student VALUES(&#39;102&#39;, &#39;匡明&#39;, &#39;男&#39;, &#39;1975-10-02&#39;, &#39;95031&#39;);INSERT INTO student VALUES(&#39;103&#39;, &#39;王丽&#39;, &#39;女&#39;, &#39;1976-01-23&#39;, &#39;95033&#39;);INSERT INTO student VALUES(&#39;104&#39;, &#39;李军&#39;, &#39;男&#39;, &#39;1976-02-20&#39;, &#39;95033&#39;);INSERT INTO student VALUES(&#39;105&#39;, &#39;王芳&#39;, &#39;女&#39;, &#39;1975-02-10&#39;, &#39;95031&#39;);INSERT INTO student VALUES(&#39;106&#39;, &#39;陆军&#39;, &#39;男&#39;, &#39;1974-06-03&#39;, &#39;95031&#39;);INSERT INTO student VALUES(&#39;107&#39;, &#39;王尼玛&#39;, &#39;男&#39;, &#39;1976-02-20&#39;, &#39;95033&#39;);INSERT INTO student VALUES(&#39;108&#39;, &#39;张全蛋&#39;, &#39;男&#39;, &#39;1975-02-10&#39;, &#39;95031&#39;);INSERT INTO student VALUES(&#39;109&#39;, &#39;赵铁柱&#39;, &#39;男&#39;, &#39;1974-06-03&#39;, &#39;95031&#39;);-- 添加教师表数据INSERT INTO teacher VALUES(&#39;804&#39;, &#39;李诚&#39;, &#39;男&#39;, &#39;1958-12-02&#39;, &#39;副教授&#39;, &#39;计算机系&#39;);INSERT INTO teacher VALUES(&#39;856&#39;, &#39;张旭&#39;, &#39;男&#39;, &#39;1969-03-12&#39;, &#39;讲师&#39;, &#39;电子工程系&#39;);INSERT INTO teacher VALUES(&#39;825&#39;, &#39;王萍&#39;, &#39;女&#39;, &#39;1972-05-05&#39;, &#39;助教&#39;, &#39;计算机系&#39;);INSERT INTO teacher VALUES(&#39;831&#39;, &#39;刘冰&#39;, &#39;女&#39;, &#39;1977-08-14&#39;, &#39;助教&#39;, &#39;电子工程系&#39;);-- 添加课程表数据INSERT INTO course VALUES(&#39;3-105&#39;, &#39;计算机导论&#39;, &#39;825&#39;);INSERT INTO course VALUES(&#39;3-245&#39;, &#39;操作系统&#39;, &#39;804&#39;);INSERT INTO course VALUES(&#39;6-166&#39;, &#39;数字电路&#39;, &#39;856&#39;);INSERT INTO course VALUES(&#39;9-888&#39;, &#39;高等数学&#39;, &#39;831&#39;);-- 添加添加成绩表数据INSERT INTO score VALUES(&#39;103&#39;, &#39;3-105&#39;, &#39;92&#39;);INSERT INTO score VALUES(&#39;103&#39;, &#39;3-245&#39;, &#39;86&#39;);INSERT INTO score VALUES(&#39;103&#39;, &#39;6-166&#39;, &#39;85&#39;);INSERT INTO score VALUES(&#39;105&#39;, &#39;3-105&#39;, &#39;88&#39;);INSERT INTO score VALUES(&#39;105&#39;, &#39;3-245&#39;, &#39;75&#39;);INSERT INTO score VALUES(&#39;105&#39;, &#39;6-166&#39;, &#39;79&#39;);INSERT INTO score VALUES(&#39;109&#39;, &#39;3-105&#39;, &#39;76&#39;);INSERT INTO score VALUES(&#39;109&#39;, &#39;3-245&#39;, &#39;68&#39;);INSERT INTO score VALUES(&#39;109&#39;, &#39;6-166&#39;, &#39;81&#39;);-- 查看表结构SELECT * FROM course;SELECT * FROM score;SELECT * FROM student;SELECT * FROM teacher; 1 到 1012345678910111213141516171819202122232425262728293031323334353637383940414243-- 查询 student 表的所有行SELECT * FROM student;-- 查询 student 表中的 name、sex 和 class 字段的所有行SELECT name, sex, class FROM student;-- 查询 teacher 表中不重复的 department 列-- department: 去重查询SELECT DISTINCT department FROM teacher;-- 查询 score 表中成绩在60-80之间的所有行（区间查询和运算符查询）-- BETWEEN xx AND xx: 查询区间, AND 表示 &quot;并且&quot;SELECT * FROM score WHERE degree BETWEEN 60 AND 80;SELECT * FROM score WHERE degree &gt; 60 AND degree &lt; 80;-- 查询 score 表中成绩为 85, 86 或 88 的行-- IN: 查询规定中的多个值SELECT * FROM score WHERE degree IN (85, 86, 88);-- 查询 student 表中 &#39;95031&#39; 班或性别为 &#39;女&#39; 的所有行-- or: 表示或者关系SELECT * FROM student WHERE class &#x3D; &#39;95031&#39; or sex &#x3D; &#39;女&#39;;-- 以 class 降序的方式查询 student 表的所有行-- DESC: 降序，从高到低-- ASC（默认）: 升序，从低到高SELECT * FROM student ORDER BY class DESC;SELECT * FROM student ORDER BY class ASC;-- 以 c_no 升序、degree 降序查询 score 表的所有行SELECT * FROM score ORDER BY c_no ASC, degree DESC;-- 查询 &quot;95031&quot; 班的学生人数-- COUNT: 统计SELECT COUNT(*) FROM student WHERE class &#x3D; &#39;95031&#39;;-- 查询 score 表中的最高分的学生学号和课程编号（子查询或排序查询）。-- (SELECT MAX(degree) FROM score): 子查询，算出最高分SELECT s_no, c_no FROM score WHERE degree &#x3D; (SELECT MAX(degree) FROM score);-- 排序查询-- LIMIT r, n: 表示从第r行开始，查询n条数据SELECT s_no, c_no, degree FROM score ORDER BY degree DESC LIMIT 0, 1; 分组计算平均成绩查询每门课的平均成绩。 1234567-- AVG: 平均值SELECT AVG(degree) FROM score WHERE c_no &#x3D; &#39;3-105&#39;;SELECT AVG(degree) FROM score WHERE c_no &#x3D; &#39;3-245&#39;;SELECT AVG(degree) FROM score WHERE c_no &#x3D; &#39;6-166&#39;;-- GROUP BY: 分组查询SELECT c_no, AVG(degree) FROM score GROUP BY c_no; 分组条件与模糊查询查询 score 表中至少有 2 名学生选修，并以 3 开头的课程的平均分数。 123456789101112131415SELECT * FROM score;-- c_no 课程编号+------+-------+--------+| s_no | c_no | degree |+------+-------+--------+| 103 | 3-105 | 92 || 103 | 3-245 | 86 || 103 | 6-166 | 85 || 105 | 3-105 | 88 || 105 | 3-245 | 75 || 105 | 6-166 | 79 || 109 | 3-105 | 76 || 109 | 3-245 | 68 || 109 | 6-166 | 81 |+------+-------+--------+ 分析表发现，至少有 2 名学生选修的课程是 3-105 、3-245 、6-166 ，以 3 开头的课程是 3-105 、3-245 。也就是说，我们要查询所有 3-105 和 3-245 的 degree 平均分。 12345678910111213141516171819202122232425262728-- 首先把 c_no, AVG(degree) 通过分组查询出来SELECT c_no, AVG(degree) FROM score GROUP BY c_no+-------+-------------+| c_no | AVG(degree) |+-------+-------------+| 3-105 | 85.3333 || 3-245 | 76.3333 || 6-166 | 81.6667 |+-------+-------------+-- 再查询出至少有 2 名学生选修的课程-- HAVING: 表示持有HAVING COUNT(c_no) &gt;&#x3D; 2-- 并且是以 3 开头的课程-- LIKE 表示模糊查询，&quot;%&quot; 是一个通配符，匹配 &quot;3&quot; 后面的任意字符。AND c_no LIKE &#39;3%&#39;;-- 把前面的SQL语句拼接起来，-- 后面加上一个 COUNT(*)，表示将每个分组的个数也查询出来。SELECT c_no, AVG(degree), COUNT(*) FROM score GROUP BY c_noHAVING COUNT(c_no) &gt;&#x3D; 2 AND c_no LIKE &#39;3%&#39;;+-------+-------------+----------+| c_no | AVG(degree) | COUNT(*) |+-------+-------------+----------+| 3-105 | 85.3333 | 3 || 3-245 | 76.3333 | 3 |+-------+-------------+----------+ 多表查询 - 1查询所有学生的 name，以及该学生在 score 表中对应的 c_no 和 degree 。 1234567891011121314151617181920212223242526272829SELECT no, name FROM student;+-----+-----------+| no | name |+-----+-----------+| 101 | 曾华 || 102 | 匡明 || 103 | 王丽 || 104 | 李军 || 105 | 王芳 || 106 | 陆军 || 107 | 王尼玛 || 108 | 张全蛋 || 109 | 赵铁柱 |+-----+-----------+SELECT s_no, c_no, degree FROM score;+------+-------+--------+| s_no | c_no | degree |+------+-------+--------+| 103 | 3-105 | 92 || 103 | 3-245 | 86 || 103 | 6-166 | 85 || 105 | 3-105 | 88 || 105 | 3-245 | 75 || 105 | 6-166 | 79 || 109 | 3-105 | 76 || 109 | 3-245 | 68 || 109 | 6-166 | 81 |+------+-------+--------+ 通过分析可以发现，只要把 score 表中的 s_no 字段值替换成 student 表中对应的 name 字段值就可以了，如何做呢？ 1234567891011121314151617-- FROM...: 表示从 student, score 表中查询-- WHERE 的条件表示为，只有在 student.no 和 score.s_no 相等时才显示出来。SELECT name, c_no, degree FROM student, score WHERE student.no &#x3D; score.s_no;+-----------+-------+--------+| name | c_no | degree |+-----------+-------+--------+| 王丽 | 3-105 | 92 || 王丽 | 3-245 | 86 || 王丽 | 6-166 | 85 || 王芳 | 3-105 | 88 || 王芳 | 3-245 | 75 || 王芳 | 6-166 | 79 || 赵铁柱 | 3-105 | 76 || 赵铁柱 | 3-245 | 68 || 赵铁柱 | 6-166 | 81 |+-----------+-------+--------+ 多表查询 - 2查询所有学生的 no 、课程名称 ( course 表中的 name ) 和成绩 ( score 表中的 degree ) 列。 只有 score 关联学生的 no ，因此只要查询 score 表，就能找出所有和学生相关的 no 和 degree ： 1234567891011121314SELECT s_no, c_no, degree FROM score;+------+-------+--------+| s_no | c_no | degree |+------+-------+--------+| 103 | 3-105 | 92 || 103 | 3-245 | 86 || 103 | 6-166 | 85 || 105 | 3-105 | 88 || 105 | 3-245 | 75 || 105 | 6-166 | 79 || 109 | 3-105 | 76 || 109 | 3-245 | 68 || 109 | 6-166 | 81 |+------+-------+--------+ 然后查询 course 表： 12345678+-------+-----------------+| no | name |+-------+-----------------+| 3-105 | 计算机导论 || 3-245 | 操作系统 || 6-166 | 数字电路 || 9-888 | 高等数学 |+-------+-----------------+ 只要把 score 表中的 c_no 替换成 course 表中对应的 name 字段值就可以了。 1234567891011121314151617-- 增加一个查询字段 name，分别从 score、course 这两个表中查询。-- as 表示取一个该字段的别名。SELECT s_no, name as c_name, degree FROM score, courseWHERE score.c_no &#x3D; course.no;+------+-----------------+--------+| s_no | c_name | degree |+------+-----------------+--------+| 103 | 计算机导论 | 92 || 105 | 计算机导论 | 88 || 109 | 计算机导论 | 76 || 103 | 操作系统 | 86 || 105 | 操作系统 | 75 || 109 | 操作系统 | 68 || 103 | 数字电路 | 85 || 105 | 数字电路 | 79 || 109 | 数字电路 | 81 |+------+-----------------+--------+ 三表关联查询查询所有学生的 name 、课程名 ( course 表中的 name ) 和 degree 。 只有 score 表中关联学生的学号和课堂号，我们只要围绕着 score 这张表查询就好了。 1234567891011121314SELECT * FROM score;+------+-------+--------+| s_no | c_no | degree |+------+-------+--------+| 103 | 3-105 | 92 || 103 | 3-245 | 86 || 103 | 6-166 | 85 || 105 | 3-105 | 88 || 105 | 3-245 | 75 || 105 | 6-166 | 79 || 109 | 3-105 | 76 || 109 | 3-245 | 68 || 109 | 6-166 | 81 |+------+-------+--------+ 只要把 s_no 和 c_no 替换成 student 和 srouse 表中对应的 name 字段值就好了。 首先把 s_no 替换成 student 表中的 name 字段： 1234567891011121314SELECT name, c_no, degree FROM student, score WHERE student.no &#x3D; score.s_no;+-----------+-------+--------+| name | c_no | degree |+-----------+-------+--------+| 王丽 | 3-105 | 92 || 王丽 | 3-245 | 86 || 王丽 | 6-166 | 85 || 王芳 | 3-105 | 88 || 王芳 | 3-245 | 75 || 王芳 | 6-166 | 79 || 赵铁柱 | 3-105 | 76 || 赵铁柱 | 3-245 | 68 || 赵铁柱 | 6-166 | 81 |+-----------+-------+--------+ 再把 c_no 替换成 course 表中的 name 字段： 12345678910111213141516-- 课程表SELECT no, name FROM course;+-------+-----------------+| no | name |+-------+-----------------+| 3-105 | 计算机导论 || 3-245 | 操作系统 || 6-166 | 数字电路 || 9-888 | 高等数学 |+-------+-----------------+-- 由于字段名存在重复，使用 &quot;表名.字段名 as 别名&quot; 代替。SELECT student.name as s_name, course.name as c_name, degree FROM student, score, courseWHERE student.NO &#x3D; score.s_noAND score.c_no &#x3D; course.no; 子查询加分组求平均分查询 95031 班学生每门课程的平均成绩。 在 score 表中根据 student 表的学生编号筛选出学生的课堂号和成绩： 12345678910111213-- IN (..): 将筛选出的学生号当做 s_no 的条件查询SELECT s_no, c_no, degree FROM scoreWHERE s_no IN (SELECT no FROM student WHERE class &#x3D; &#39;95031&#39;);+------+-------+--------+| s_no | c_no | degree |+------+-------+--------+| 105 | 3-105 | 88 || 105 | 3-245 | 75 || 105 | 6-166 | 79 || 109 | 3-105 | 76 || 109 | 3-245 | 68 || 109 | 6-166 | 81 |+------+-------+--------+ 这时只要将 c_no 分组一下就能得出 95031 班学生每门课的平均成绩： 12345678910SELECT c_no, AVG(degree) FROM scoreWHERE s_no IN (SELECT no FROM student WHERE class &#x3D; &#39;95031&#39;)GROUP BY c_no;+-------+-------------+| c_no | AVG(degree) |+-------+-------------+| 3-105 | 82.0000 || 3-245 | 71.5000 || 6-166 | 80.0000 |+-------+-------------+ 子查询 - 1查询在 3-105 课程中，所有成绩高于 109 号同学的记录。 首先筛选出课堂号为 3-105 ，在找出所有成绩高于 109 号同学的的行。 123SELECT * FROM score WHERE c_no &#x3D; &#39;3-105&#39;AND degree &gt; (SELECT degree FROM score WHERE s_no &#x3D; &#39;109&#39; AND c_no &#x3D; &#39;3-105&#39;); 子查询 - 2查询所有成绩高于 109 号同学的 3-105 课程成绩记录。 123-- 不限制课程号，只要成绩大于109号同学的3-105课程成绩就可以。SELECT * FROM scoreWHERE degree &gt; (SELECT degree FROM score WHERE s_no &#x3D; &#39;109&#39; AND c_no &#x3D; &#39;3-105&#39;); YEAR 函数与带 IN 关键字查询查询所有和 101 、108 号学生同年出生的 no 、name 、birthday 列。 123-- YEAR(..): 取出日期中的年份SELECT no, name, birthday FROM studentWHERE YEAR(birthday) IN (SELECT YEAR(birthday) FROM student WHERE no IN (101, 108)); 多层嵌套子查询查询 &#39;张旭&#39; 教师任课的学生成绩表。 首先找到教师编号： 1SELECT NO FROM teacher WHERE NAME &#x3D; &#39;张旭&#39; 通过 sourse 表找到该教师课程号： 1SELECT NO FROM course WHERE t_no &#x3D; ( SELECT NO FROM teacher WHERE NAME &#x3D; &#39;张旭&#39; ); 通过筛选出的课程号查询成绩表： 12345SELECT * FROM score WHERE c_no &#x3D; ( SELECT no FROM course WHERE t_no &#x3D; ( SELECT no FROM teacher WHERE NAME &#x3D; &#39;张旭&#39; )); 多表查询查询某选修课程多于5个同学的教师姓名。 首先在 teacher 表中，根据 no 字段来判断该教师的同一门课程是否有至少5名学员选修： 1234567891011121314-- 查询 teacher 表SELECT no, name FROM teacher;+-----+--------+| no | name |+-----+--------+| 804 | 李诚 || 825 | 王萍 || 831 | 刘冰 || 856 | 张旭 |+-----+--------+SELECT name FROM teacher WHERE no IN ( -- 在这里找到对应的条件); 查看和教师编号有有关的表的信息： 12345678910SELECT * FROM course;-- t_no: 教师编号+-------+-----------------+------+| no | name | t_no |+-------+-----------------+------+| 3-105 | 计算机导论 | 825 || 3-245 | 操作系统 | 804 || 6-166 | 数字电路 | 856 || 9-888 | 高等数学 | 831 |+-------+-----------------+------+ 我们已经找到和教师编号有关的字段就在 course 表中，但是还无法知道哪门课程至少有5名学生选修，所以还需要根据 score 表来查询： 12345678910111213141516171819202122232425262728293031-- 在此之前向 score 插入一些数据，以便丰富查询条件。INSERT INTO score VALUES (&#39;101&#39;, &#39;3-105&#39;, &#39;90&#39;);INSERT INTO score VALUES (&#39;102&#39;, &#39;3-105&#39;, &#39;91&#39;);INSERT INTO score VALUES (&#39;104&#39;, &#39;3-105&#39;, &#39;89&#39;);-- 查询 score 表SELECT * FROM score;+------+-------+--------+| s_no | c_no | degree |+------+-------+--------+| 101 | 3-105 | 90 || 102 | 3-105 | 91 || 103 | 3-105 | 92 || 103 | 3-245 | 86 || 103 | 6-166 | 85 || 104 | 3-105 | 89 || 105 | 3-105 | 88 || 105 | 3-245 | 75 || 105 | 6-166 | 79 || 109 | 3-105 | 76 || 109 | 3-245 | 68 || 109 | 6-166 | 81 |+------+-------+--------+-- 在 score 表中将 c_no 作为分组，并且限制 c_no 持有至少 5 条数据。SELECT c_no FROM score GROUP BY c_no HAVING COUNT(*) &gt; 5;+-------+| c_no |+-------+| 3-105 |+-------+ 根据筛选出来的课程号，找出在某课程中，拥有至少5名学员的教师编号： 12345678SELECT t_no FROM course WHERE no IN ( SELECT c_no FROM score GROUP BY c_no HAVING COUNT(*) &gt; 5);+------+| t_no |+------+| 825 |+------+ 在 teacher 表中，根据筛选出来的教师编号找到教师姓名： 123456SELECT name FROM teacher WHERE no IN ( -- 最终条件 SELECT t_no FROM course WHERE no IN ( SELECT c_no FROM score GROUP BY c_no HAVING COUNT(*) &gt; 5 )); 子查询 - 3查询 “计算机系” 课程的成绩表。 思路是，先找出 course 表中所有 计算机系 课程的编号，然后根据这个编号查询 score 表。 123456789101112131415161718192021222324252627282930313233343536373839-- 通过 teacher 表查询所有 &#96;计算机系&#96; 的教师编号SELECT no, name, department FROM teacher WHERE department &#x3D; &#39;计算机系&#39;+-----+--------+--------------+| no | name | department |+-----+--------+--------------+| 804 | 李诚 | 计算机系 || 825 | 王萍 | 计算机系 |+-----+--------+--------------+-- 通过 course 表查询该教师的课程编号SELECT no FROM course WHERE t_no IN ( SELECT no FROM teacher WHERE department &#x3D; &#39;计算机系&#39;);+-------+| no |+-------+| 3-245 || 3-105 |+-------+-- 根据筛选出来的课程号查询成绩表SELECT * FROM score WHERE c_no IN ( SELECT no FROM course WHERE t_no IN ( SELECT no FROM teacher WHERE department &#x3D; &#39;计算机系&#39; ));+------+-------+--------+| s_no | c_no | degree |+------+-------+--------+| 103 | 3-245 | 86 || 105 | 3-245 | 75 || 109 | 3-245 | 68 || 101 | 3-105 | 90 || 102 | 3-105 | 91 || 103 | 3-105 | 92 || 104 | 3-105 | 89 || 105 | 3-105 | 88 || 109 | 3-105 | 76 |+------+-------+--------+ UNION 和 NOTIN 的使用查询 计算机系 与 电子工程系 中的不同职称的教师。 123456789-- NOT: 代表逻辑非SELECT * FROM teacher WHERE department &#x3D; &#39;计算机系&#39; AND profession NOT IN ( SELECT profession FROM teacher WHERE department &#x3D; &#39;电子工程系&#39;)-- 合并两个集UNIONSELECT * FROM teacher WHERE department &#x3D; &#39;电子工程系&#39; AND profession NOT IN ( SELECT profession FROM teacher WHERE department &#x3D; &#39;计算机系&#39;); ANY 表示至少一个 - DESC ( 降序 )查询课程 3-105 且成绩 至少 高于 3-245 的 score 表。 12345678910111213141516171819202122232425262728293031323334353637SELECT * FROM score WHERE c_no &#x3D; &#39;3-105&#39;;+------+-------+--------+| s_no | c_no | degree |+------+-------+--------+| 101 | 3-105 | 90 || 102 | 3-105 | 91 || 103 | 3-105 | 92 || 104 | 3-105 | 89 || 105 | 3-105 | 88 || 109 | 3-105 | 76 |+------+-------+--------+SELECT * FROM score WHERE c_no &#x3D; &#39;3-245&#39;;+------+-------+--------+| s_no | c_no | degree |+------+-------+--------+| 103 | 3-245 | 86 || 105 | 3-245 | 75 || 109 | 3-245 | 68 |+------+-------+--------+-- ANY: 符合SQL语句中的任意条件。-- 也就是说，在 3-105 成绩中，只要有一个大于从 3-245 筛选出来的任意行就符合条件，-- 最后根据降序查询结果。SELECT * FROM score WHERE c_no &#x3D; &#39;3-105&#39; AND degree &gt; ANY( SELECT degree FROM score WHERE c_no &#x3D; &#39;3-245&#39;) ORDER BY degree DESC;+------+-------+--------+| s_no | c_no | degree |+------+-------+--------+| 103 | 3-105 | 92 || 102 | 3-105 | 91 || 101 | 3-105 | 90 || 104 | 3-105 | 89 || 105 | 3-105 | 88 || 109 | 3-105 | 76 |+------+-------+--------+ 表示所有的 ALL查询课程 3-105 且成绩高于 3-245 的 score 表。 123456789101112131415-- 只需对上一道题稍作修改。-- ALL: 符合SQL语句中的所有条件。-- 也就是说，在 3-105 每一行成绩中，都要大于从 3-245 筛选出来全部行才算符合条件。SELECT * FROM score WHERE c_no &#x3D; &#39;3-105&#39; AND degree &gt; ALL( SELECT degree FROM score WHERE c_no &#x3D; &#39;3-245&#39;);+------+-------+--------+| s_no | c_no | degree |+------+-------+--------+| 101 | 3-105 | 90 || 102 | 3-105 | 91 || 103 | 3-105 | 92 || 104 | 3-105 | 89 || 105 | 3-105 | 88 |+------+-------+--------+ 复制表的数据作为条件查询查询某课程成绩比该课程平均成绩低的 score 表。 1234567891011121314151617181920212223242526272829303132333435363738394041424344-- 查询平均分SELECT c_no, AVG(degree) FROM score GROUP BY c_no;+-------+-------------+| c_no | AVG(degree) |+-------+-------------+| 3-105 | 87.6667 || 3-245 | 76.3333 || 6-166 | 81.6667 |+-------+-------------+-- 查询 score 表SELECT degree FROM score;+--------+| degree |+--------+| 90 || 91 || 92 || 86 || 85 || 89 || 88 || 75 || 79 || 76 || 68 || 81 |+--------+-- 将表 b 作用于表 a 中查询数据-- score a (b): 将表声明为 a (b)，-- 如此就能用 a.c_no &#x3D; b.c_no 作为条件执行查询了。SELECT * FROM score a WHERE degree &lt; ( (SELECT AVG(degree) FROM score b WHERE a.c_no &#x3D; b.c_no));+------+-------+--------+| s_no | c_no | degree |+------+-------+--------+| 105 | 3-245 | 75 || 105 | 6-166 | 79 || 109 | 3-105 | 76 || 109 | 3-245 | 68 || 109 | 6-166 | 81 |+------+-------+--------+ 子查询 - 4查询所有任课 ( 在 course 表里有课程 ) 教师的 name 和 department 。 123456789SELECT name, department FROM teacher WHERE no IN (SELECT t_no FROM course);+--------+-----------------+| name | department |+--------+-----------------+| 李诚 | 计算机系 || 王萍 | 计算机系 || 刘冰 | 电子工程系 || 张旭 | 电子工程系 |+--------+-----------------+ 条件加组筛选查询 student 表中至少有 2 名男生的 class 。 12345678910111213141516171819202122232425-- 查看学生表信息SELECT * FROM student;+-----+-----------+-----+------------+-------+| no | name | sex | birthday | class |+-----+-----------+-----+------------+-------+| 101 | 曾华 | 男 | 1977-09-01 | 95033 || 102 | 匡明 | 男 | 1975-10-02 | 95031 || 103 | 王丽 | 女 | 1976-01-23 | 95033 || 104 | 李军 | 男 | 1976-02-20 | 95033 || 105 | 王芳 | 女 | 1975-02-10 | 95031 || 106 | 陆军 | 男 | 1974-06-03 | 95031 || 107 | 王尼玛 | 男 | 1976-02-20 | 95033 || 108 | 张全蛋 | 男 | 1975-02-10 | 95031 || 109 | 赵铁柱 | 男 | 1974-06-03 | 95031 || 110 | 张飞 | 男 | 1974-06-03 | 95038 |+-----+-----------+-----+------------+-------+-- 只查询性别为男，然后按 class 分组，并限制 class 行大于 1。SELECT class FROM student WHERE sex &#x3D; &#39;男&#39; GROUP BY class HAVING COUNT(*) &gt; 1;+-------+| class |+-------+| 95033 || 95031 |+-------+ NOTLIKE 模糊查询取反查询 student 表中不姓 “王” 的同学记录。 1234567891011121314-- NOT: 取反-- LIKE: 模糊查询mysql&gt; SELECT * FROM student WHERE name NOT LIKE &#39;王%&#39;;+-----+-----------+-----+------------+-------+| no | name | sex | birthday | class |+-----+-----------+-----+------------+-------+| 101 | 曾华 | 男 | 1977-09-01 | 95033 || 102 | 匡明 | 男 | 1975-10-02 | 95031 || 104 | 李军 | 男 | 1976-02-20 | 95033 || 106 | 陆军 | 男 | 1974-06-03 | 95031 || 108 | 张全蛋 | 男 | 1975-02-10 | 95031 || 109 | 赵铁柱 | 男 | 1974-06-03 | 95031 || 110 | 张飞 | 男 | 1974-06-03 | 95038 |+-----+-----------+-----+------------+-------+ YEAR 与 NOW 函数查询 student 表中每个学生的姓名和年龄。 12345678910111213141516-- 使用函数 YEAR(NOW()) 计算出当前年份，减去出生年份后得出年龄。SELECT name, YEAR(NOW()) - YEAR(birthday) as age FROM student;+-----------+------+| name | age |+-----------+------+| 曾华 | 42 || 匡明 | 44 || 王丽 | 43 || 李军 | 43 || 王芳 | 44 || 陆军 | 45 || 王尼玛 | 43 || 张全蛋 | 44 || 赵铁柱 | 45 || 张飞 | 45 |+-----------+------+ MAX 与 MIN 函数查询 student 表中最大和最小的 birthday 值。 123456SELECT MAX(birthday), MIN(birthday) FROM student;+---------------+---------------+| MAX(birthday) | MIN(birthday) |+---------------+---------------+| 1977-09-01 | 1974-06-03 |+---------------+---------------+ 多段排序以 class 和 birthday 从大到小的顺序查询 student 表。 123456789101112131415SELECT * FROM student ORDER BY class DESC, birthday;+-----+-----------+-----+------------+-------+| no | name | sex | birthday | class |+-----+-----------+-----+------------+-------+| 110 | 张飞 | 男 | 1974-06-03 | 95038 || 103 | 王丽 | 女 | 1976-01-23 | 95033 || 104 | 李军 | 男 | 1976-02-20 | 95033 || 107 | 王尼玛 | 男 | 1976-02-20 | 95033 || 101 | 曾华 | 男 | 1977-09-01 | 95033 || 106 | 陆军 | 男 | 1974-06-03 | 95031 || 109 | 赵铁柱 | 男 | 1974-06-03 | 95031 || 105 | 王芳 | 女 | 1975-02-10 | 95031 || 108 | 张全蛋 | 男 | 1975-02-10 | 95031 || 102 | 匡明 | 男 | 1975-10-02 | 95031 |+-----+-----------+-----+------------+-------+ 子查询 - 5查询 “男” 教师及其所上的课程。 1234567SELECT * FROM course WHERE t_no in (SELECT no FROM teacher WHERE sex &#x3D; &#39;男&#39;);+-------+--------------+------+| no | name | t_no |+-------+--------------+------+| 3-245 | 操作系统 | 804 || 6-166 | 数字电路 | 856 |+-------+--------------+------+ MAX 函数与子查询查询最高分同学的 score 表。 1234567891011-- 找出最高成绩（该查询只能有一个结果）SELECT MAX(degree) FROM score;-- 根据上面的条件筛选出所有最高成绩表，-- 该查询可能有多个结果，假设 degree 值多次符合条件。SELECT * FROM score WHERE degree &#x3D; (SELECT MAX(degree) FROM score);+------+-------+--------+| s_no | c_no | degree |+------+-------+--------+| 103 | 3-105 | 92 |+------+-------+--------+ 子查询 - 6查询和 “李军” 同性别的所有同学 name 。 123456789101112131415161718192021222324-- 首先将李军的性别作为条件取出来SELECT sex FROM student WHERE name &#x3D; &#39;李军&#39;;+-----+| sex |+-----+| 男 |+-----+-- 根据性别查询 name 和 sexSELECT name, sex FROM student WHERE sex &#x3D; ( SELECT sex FROM student WHERE name &#x3D; &#39;李军&#39;);+-----------+-----+| name | sex |+-----------+-----+| 曾华 | 男 || 匡明 | 男 || 李军 | 男 || 陆军 | 男 || 王尼玛 | 男 || 张全蛋 | 男 || 赵铁柱 | 男 || 张飞 | 男 |+-----------+-----+ 子查询 - 7查询和 “李军” 同性别且同班的同学 name 。 123456789101112SELECT name, sex, class FROM student WHERE sex &#x3D; ( SELECT sex FROM student WHERE name &#x3D; &#39;李军&#39;) AND class &#x3D; ( SELECT class FROM student WHERE name &#x3D; &#39;李军&#39;);+-----------+-----+-------+| name | sex | class |+-----------+-----+-------+| 曾华 | 男 | 95033 || 李军 | 男 | 95033 || 王尼玛 | 男 | 95033 |+-----------+-----+-------+ 子查询 - 8查询所有选修 “计算机导论” 课程的 “男” 同学成绩表。 需要的 “计算机导论” 和性别为 “男” 的编号可以在 course 和 student 表中找到。 12345678910111213SELECT * FROM score WHERE c_no &#x3D; ( SELECT no FROM course WHERE name &#x3D; &#39;计算机导论&#39;) AND s_no IN ( SELECT no FROM student WHERE sex &#x3D; &#39;男&#39;);+------+-------+--------+| s_no | c_no | degree |+------+-------+--------+| 101 | 3-105 | 90 || 102 | 3-105 | 91 || 104 | 3-105 | 89 || 109 | 3-105 | 76 |+------+-------+--------+ 按等级查询建立一个 grade 表代表学生的成绩等级，并插入数据： 12345678910111213141516171819202122CREATE TABLE grade ( low INT(3), upp INT(3), grade char(1));INSERT INTO grade VALUES (90, 100, &#39;A&#39;);INSERT INTO grade VALUES (80, 89, &#39;B&#39;);INSERT INTO grade VALUES (70, 79, &#39;C&#39;);INSERT INTO grade VALUES (60, 69, &#39;D&#39;);INSERT INTO grade VALUES (0, 59, &#39;E&#39;);SELECT * FROM grade;+------+------+-------+| low | upp | grade |+------+------+-------+| 90 | 100 | A || 80 | 89 | B || 70 | 79 | C || 60 | 69 | D || 0 | 59 | E |+------+------+-------+ 查询所有学生的 s_no 、c_no 和 grade 列。 思路是，使用区间 ( BETWEEN ) 查询，判断学生的成绩 ( degree ) 在 grade 表的 low 和 upp 之间。 123456789101112131415161718SELECT s_no, c_no, grade FROM score, grade WHERE degree BETWEEN low AND upp;+------+-------+-------+| s_no | c_no | grade |+------+-------+-------+| 101 | 3-105 | A || 102 | 3-105 | A || 103 | 3-105 | A || 103 | 3-245 | B || 103 | 6-166 | B || 104 | 3-105 | B || 105 | 3-105 | B || 105 | 3-245 | C || 105 | 6-166 | C || 109 | 3-105 | C || 109 | 3-245 | D || 109 | 6-166 | B |+------+-------+-------+ 连接查询准备用于测试连接查询的数据： 12345678910111213141516171819202122232425262728293031323334CREATE DATABASE testJoin;CREATE TABLE person ( id INT, name VARCHAR(20), cardId INT);CREATE TABLE card ( id INT, name VARCHAR(20));INSERT INTO card VALUES (1, &#39;饭卡&#39;), (2, &#39;建行卡&#39;), (3, &#39;农行卡&#39;), (4, &#39;工商卡&#39;), (5, &#39;邮政卡&#39;);SELECT * FROM card;+------+-----------+| id | name |+------+-----------+| 1 | 饭卡 || 2 | 建行卡 || 3 | 农行卡 || 4 | 工商卡 || 5 | 邮政卡 |+------+-----------+INSERT INTO person VALUES (1, &#39;张三&#39;, 1), (2, &#39;李四&#39;, 3), (3, &#39;王五&#39;, 6);SELECT * FROM person;+------+--------+--------+| id | name | cardId |+------+--------+--------+| 1 | 张三 | 1 || 2 | 李四 | 3 || 3 | 王五 | 6 |+------+--------+--------+ 分析两张表发现，person 表并没有为 cardId 字段设置一个在 card 表中对应的 id 外键。如果设置了的话，person 中 cardId 字段值为 6 的行就插不进去，因为该 cardId 值在 card 表中并没有。 内连接要查询这两张表中有关系的数据，可以使用 INNER JOIN ( 内连接 ) 将它们连接在一起。 123456789101112-- INNER JOIN: 表示为内连接，将两张表拼接在一起。-- on: 表示要执行某个条件。SELECT * FROM person INNER JOIN card on person.cardId &#x3D; card.id;+------+--------+--------+------+-----------+| id | name | cardId | id | name |+------+--------+--------+------+-----------+| 1 | 张三 | 1 | 1 | 饭卡 || 2 | 李四 | 3 | 3 | 农行卡 |+------+--------+--------+------+-----------+-- 将 INNER 关键字省略掉，结果也是一样的。-- SELECT * FROM person JOIN card on person.cardId &#x3D; card.id; 注意：card 的整张表被连接到了右边。 左外连接完整显示左边的表 ( person ) ，右边的表如果符合条件就显示，不符合则补 NULL 。 123456789-- LEFT JOIN 也叫做 LEFT OUTER JOIN，用这两种方式的查询结果是一样的。SELECT * FROM person LEFT JOIN card on person.cardId &#x3D; card.id;+------+--------+--------+------+-----------+| id | name | cardId | id | name |+------+--------+--------+------+-----------+| 1 | 张三 | 1 | 1 | 饭卡 || 2 | 李四 | 3 | 3 | 农行卡 || 3 | 王五 | 6 | NULL | NULL |+------+--------+--------+------+-----------+ 右外链接完整显示右边的表 ( card ) ，左边的表如果符合条件就显示，不符合则补 NULL 。 12345678910SELECT * FROM person RIGHT JOIN card on person.cardId &#x3D; card.id;+------+--------+--------+------+-----------+| id | name | cardId | id | name |+------+--------+--------+------+-----------+| 1 | 张三 | 1 | 1 | 饭卡 || 2 | 李四 | 3 | 3 | 农行卡 || NULL | NULL | NULL | 2 | 建行卡 || NULL | NULL | NULL | 4 | 工商卡 || NULL | NULL | NULL | 5 | 邮政卡 |+------+--------+--------+------+-----------+ 全外链接完整显示两张表的全部数据。 12345678910111213141516171819-- MySQL 不支持这种语法的全外连接-- SELECT * FROM person FULL JOIN card on person.cardId &#x3D; card.id;-- 出现错误：-- ERROR 1054 (42S22): Unknown column &#39;person.cardId&#39; in &#39;on clause&#39;-- MySQL全连接语法，使用 UNION 将两张表合并在一起。SELECT * FROM person LEFT JOIN card on person.cardId &#x3D; card.idUNIONSELECT * FROM person RIGHT JOIN card on person.cardId &#x3D; card.id;+------+--------+--------+------+-----------+| id | name | cardId | id | name |+------+--------+--------+------+-----------+| 1 | 张三 | 1 | 1 | 饭卡 || 2 | 李四 | 3 | 3 | 农行卡 || 3 | 王五 | 6 | NULL | NULL || NULL | NULL | NULL | 2 | 建行卡 || NULL | NULL | NULL | 4 | 工商卡 || NULL | NULL | NULL | 5 | 邮政卡 |+------+--------+--------+------+-----------+ 事务在 MySQL 中，事务其实是一个最小的不可分割的工作单元。事务能够保证一个业务的完整性。 比如我们的银行转账： 12345-- a -&gt; -100UPDATE user set money &#x3D; money - 100 WHERE name &#x3D; &#39;a&#39;;-- b -&gt; +100UPDATE user set money &#x3D; money + 100 WHERE name &#x3D; &#39;b&#39;; 在实际项目中，假设只有一条 SQL 语句执行成功，而另外一条执行失败了，就会出现数据前后不一致。 因此，在执行多条有关联 SQL 语句时，事务可能会要求这些 SQL 语句要么同时执行成功，要么就都执行失败。 如何控制事务 - COMMIT / ROLLBACK在 MySQL 中，事务的自动提交状态默认是开启的。 1234567-- 查询事务的自动提交状态SELECT @@AUTOCOMMIT;+--------------+| @@AUTOCOMMIT |+--------------+| 1 |+--------------+ 自动提交的作用：当我们执行一条 SQL 语句的时候，其产生的效果就会立即体现出来，且不能回滚。 什么是回滚？举个例子： 123456789101112131415161718CREATE DATABASE bank;USE bank;CREATE TABLE user ( id INT PRIMARY KEY, name VARCHAR(20), money INT);INSERT INTO user VALUES (1, &#39;a&#39;, 1000);SELECT * FROM user;+----+------+-------+| id | name | money |+----+------+-------+| 1 | a | 1000 |+----+------+-------+ 可以看到，在执行插入语句后数据立刻生效，原因是 MySQL 中的事务自动将它提交到了数据库中。那么所谓回滚的意思就是，撤销执行过的所有 SQL 语句，使其回滚到最后一次提交数据时的状态。 在 MySQL 中使用 ROLLBACK 执行回滚： 123456789-- 回滚到最后一次提交ROLLBACK;SELECT * FROM user;+----+------+-------+| id | name | money |+----+------+-------+| 1 | a | 1000 |+----+------+-------+ 由于所有执行过的 SQL 语句都已经被提交过了，所以数据并没有发生回滚。那如何让数据可以发生回滚？ 12345678910-- 关闭自动提交SET AUTOCOMMIT &#x3D; 0;-- 查询自动提交状态SELECT @@AUTOCOMMIT;+--------------+| @@AUTOCOMMIT |+--------------+| 0 |+--------------+ 将自动提交关闭后，测试数据回滚： 1234567891011121314151617181920212223242526272829INSERT INTO user VALUES (2, &#39;b&#39;, 1000);-- 关闭 AUTOCOMMIT 后，数据的变化是在一张虚拟的临时数据表中展示，-- 发生变化的数据并没有真正插入到数据表中。SELECT * FROM user;+----+------+-------+| id | name | money |+----+------+-------+| 1 | a | 1000 || 2 | b | 1000 |+----+------+-------+-- 数据表中的真实数据其实还是：+----+------+-------+| id | name | money |+----+------+-------+| 1 | a | 1000 |+----+------+-------+-- 由于数据还没有真正提交，可以使用回滚ROLLBACK;-- 再次查询SELECT * FROM user;+----+------+-------+| id | name | money |+----+------+-------+| 1 | a | 1000 |+----+------+-------+ 那如何将虚拟的数据真正提交到数据库中？使用 COMMIT : 12345678910111213141516INSERT INTO user VALUES (2, &#39;b&#39;, 1000);-- 手动提交数据（持久性），-- 将数据真正提交到数据库中，执行后不能再回滚提交过的数据。COMMIT;-- 提交后测试回滚ROLLBACK;-- 再次查询（回滚无效了）SELECT * FROM user;+----+------+-------+| id | name | money |+----+------+-------+| 1 | a | 1000 || 2 | b | 1000 |+----+------+-------+ 总结 自动提交 查看自动提交状态：SELECT @@AUTOCOMMIT ； 设置自动提交状态：SET AUTOCOMMIT = 0 。 手动提交 @@AUTOCOMMIT = 0 时，使用 COMMIT 命令提交事务。 事务回滚 @@AUTOCOMMIT = 0 时，使用 ROLLBACK 命令回滚事务。 事务的实际应用，让我们再回到银行转账项目： 12345678910111213-- 转账UPDATE user set money &#x3D; money - 100 WHERE name &#x3D; &#39;a&#39;;-- 到账UPDATE user set money &#x3D; money + 100 WHERE name &#x3D; &#39;b&#39;;SELECT * FROM user;+----+------+-------+| id | name | money |+----+------+-------+| 1 | a | 900 || 2 | b | 1100 |+----+------+-------+ 这时假设在转账时发生了意外，就可以使用 ROLLBACK 回滚到最后一次提交的状态： 12345678910-- 假设转账发生了意外，需要回滚。ROLLBACK;SELECT * FROM user;+----+------+-------+| id | name | money |+----+------+-------+| 1 | a | 1000 || 2 | b | 1000 |+----+------+-------+ 这时我们又回到了发生意外之前的状态，也就是说，事务给我们提供了一个可以反悔的机会。假设数据没有发生意外，这时可以手动将数据真正提交到数据表中：COMMIT 。 手动开启事务 - BEGIN / START TRANSACTION事务的默认提交被开启 ( @@AUTOCOMMIT = 1 ) 后，此时就不能使用事务回滚了。但是我们还可以手动开启一个事务处理事件，使其可以发生回滚： 1234567891011121314151617181920212223242526-- 使用 BEGIN 或者 START TRANSACTION 手动开启一个事务-- START TRANSACTION;BEGIN;UPDATE user set money &#x3D; money - 100 WHERE name &#x3D; &#39;a&#39;;UPDATE user set money &#x3D; money + 100 WHERE name &#x3D; &#39;b&#39;;-- 由于手动开启的事务没有开启自动提交，-- 此时发生变化的数据仍然是被保存在一张临时表中。SELECT * FROM user;+----+------+-------+| id | name | money |+----+------+-------+| 1 | a | 900 || 2 | b | 1100 |+----+------+-------+-- 测试回滚ROLLBACK;SELECT * FROM user;+----+------+-------+| id | name | money |+----+------+-------+| 1 | a | 1000 || 2 | b | 1000 |+----+------+-------+ 仍然使用 COMMIT 提交数据，提交后无法再发生本次事务的回滚。 1234567891011121314151617BEGIN;UPDATE user set money &#x3D; money - 100 WHERE name &#x3D; &#39;a&#39;;UPDATE user set money &#x3D; money + 100 WHERE name &#x3D; &#39;b&#39;;SELECT * FROM user;+----+------+-------+| id | name | money |+----+------+-------+| 1 | a | 900 || 2 | b | 1100 |+----+------+-------+-- 提交数据COMMIT;-- 测试回滚（无效，因为表的数据已经被提交）ROLLBACK; 事务的 ACID 特征与使用事务的四大特征： A 原子性：事务是最小的单位，不可以再分割； C 一致性：要求同一事务中的 SQL 语句，必须保证同时成功或者失败； I 隔离性：事务1 和 事务2 之间是具有隔离性的； D 持久性：事务一旦结束 ( COMMIT ) ，就不可以再返回了 ( ROLLBACK ) 。 事务的隔离性事务的隔离性可分为四种 ( 性能从低到高 ) ： READ UNCOMMITTED ( 读取未提交 ) 如果有多个事务，那么任意事务都可以看见其他事务的未提交数据。 READ COMMITTED ( 读取已提交 ) 只能读取到其他事务已经提交的数据。 REPEATABLE READ ( 可被重复读 ) 如果有多个连接都开启了事务，那么事务之间不能共享数据记录，否则只能共享已提交的记录。 SERIALIZABLE ( 串行化 ) 所有的事务都会按照固定顺序执行，执行完一个事务后再继续执行下一个事务的写入操作。 查看当前数据库的默认隔离级别： 123456789101112-- MySQL 8.x, GLOBAL 表示系统级别，不加表示会话级别。SELECT @@GLOBAL.TRANSACTION_ISOLATION;SELECT @@TRANSACTION_ISOLATION;+--------------------------------+| @@GLOBAL.TRANSACTION_ISOLATION |+--------------------------------+| REPEATABLE-READ | -- MySQL的默认隔离级别，可以重复读。+--------------------------------+-- MySQL 5.xSELECT @@GLOBAL.TX_ISOLATION;SELECT @@TX_ISOLATION; 修改隔离级别： 12345678910-- 设置系统隔离级别，LEVEL 后面表示要设置的隔离级别 (READ UNCOMMITTED)。SET GLOBAL TRANSACTION ISOLATION LEVEL READ UNCOMMITTED;-- 查询系统隔离级别，发现已经被修改。SELECT @@GLOBAL.TRANSACTION_ISOLATION;+--------------------------------+| @@GLOBAL.TRANSACTION_ISOLATION |+--------------------------------+| READ-UNCOMMITTED |+--------------------------------+ 脏读测试 READ UNCOMMITTED ( 读取未提交 ) 的隔离性： 1234567891011121314151617181920212223242526272829INSERT INTO user VALUES (3, &#39;小明&#39;, 1000);INSERT INTO user VALUES (4, &#39;淘宝店&#39;, 1000);SELECT * FROM user;+----+-----------+-------+| id | name | money |+----+-----------+-------+| 1 | a | 900 || 2 | b | 1100 || 3 | 小明 | 1000 || 4 | 淘宝店 | 1000 |+----+-----------+-------+-- 开启一个事务操作数据-- 假设小明在淘宝店买了一双800块钱的鞋子：START TRANSACTION;UPDATE user SET money &#x3D; money - 800 WHERE name &#x3D; &#39;小明&#39;;UPDATE user SET money &#x3D; money + 800 WHERE name &#x3D; &#39;淘宝店&#39;;-- 然后淘宝店在另一方查询结果，发现钱已到账。SELECT * FROM user;+----+-----------+-------+| id | name | money |+----+-----------+-------+| 1 | a | 900 || 2 | b | 1100 || 3 | 小明 | 200 || 4 | 淘宝店 | 1800 |+----+-----------+-------+ 由于小明的转账是在新开启的事务上进行操作的，而该操作的结果是可以被其他事务（另一方的淘宝店）看见的，因此淘宝店的查询结果是正确的，淘宝店确认到账。但就在这时，如果小明在它所处的事务上又执行了 ROLLBACK 命令，会发生什么？ 12345678910111213-- 小明所处的事务ROLLBACK;-- 此时无论对方是谁，如果再去查询结果就会发现：SELECT * FROM user;+----+-----------+-------+| id | name | money |+----+-----------+-------+| 1 | a | 900 || 2 | b | 1100 || 3 | 小明 | 1000 || 4 | 淘宝店 | 1000 |+----+-----------+-------+ 这就是所谓的脏读，一个事务读取到另外一个事务还未提交的数据。这在实际开发中是不允许出现的。 读取已提交把隔离级别设置为 READ COMMITTED ： 1234567SET GLOBAL TRANSACTION ISOLATION LEVEL READ COMMITTED;SELECT @@GLOBAL.TRANSACTION_ISOLATION;+--------------------------------+| @@GLOBAL.TRANSACTION_ISOLATION |+--------------------------------+| READ-COMMITTED |+--------------------------------+ 这样，再有新的事务连接进来时，它们就只能查询到已经提交过的事务数据了。但是对于当前事务来说，它们看到的还是未提交的数据，例如： 12345678910111213141516171819202122232425262728293031-- 正在操作数据事务（当前事务）START TRANSACTION;UPDATE user SET money &#x3D; money - 800 WHERE name &#x3D; &#39;小明&#39;;UPDATE user SET money &#x3D; money + 800 WHERE name &#x3D; &#39;淘宝店&#39;;-- 虽然隔离级别被设置为了 READ COMMITTED，但在当前事务中，-- 它看到的仍然是数据表中临时改变数据，而不是真正提交过的数据。SELECT * FROM user;+----+-----------+-------+| id | name | money |+----+-----------+-------+| 1 | a | 900 || 2 | b | 1100 || 3 | 小明 | 200 || 4 | 淘宝店 | 1800 |+----+-----------+-------+-- 假设此时在远程开启了一个新事务，连接到数据库。$ mysql -u root -p12345612-- 此时远程连接查询到的数据只能是已经提交过的SELECT * FROM user;+----+-----------+-------+| id | name | money |+----+-----------+-------+| 1 | a | 900 || 2 | b | 1100 || 3 | 小明 | 1000 || 4 | 淘宝店 | 1000 |+----+-----------+-------+ 但是这样还有问题，那就是假设一个事务在操作数据时，其他事务干扰了这个事务的数据。例如： 1234567891011121314151617181920212223242526272829303132333435-- 小张在查询数据的时候发现：SELECT * FROM user;+----+-----------+-------+| id | name | money |+----+-----------+-------+| 1 | a | 900 || 2 | b | 1100 || 3 | 小明 | 200 || 4 | 淘宝店 | 1800 |+----+-----------+-------+-- 在小张求表的 money 平均值之前，小王做了一个操作：START TRANSACTION;INSERT INTO user VALUES (5, &#39;c&#39;, 100);COMMIT;-- 此时表的真实数据是：SELECT * FROM user;+----+-----------+-------+| id | name | money |+----+-----------+-------+| 1 | a | 900 || 2 | b | 1100 || 3 | 小明 | 1000 || 4 | 淘宝店 | 1000 || 5 | c | 100 |+----+-----------+-------+-- 这时小张再求平均值的时候，就会出现计算不相符合的情况：SELECT AVG(money) FROM user;+------------+| AVG(money) |+------------+| 820.0000 |+------------+ 虽然 READ COMMITTED 让我们只能读取到其他事务已经提交的数据，但还是会出现问题，就是在读取同一个表的数据时，可能会发生前后不一致的情况。这被称为不可重复读现象 ( READ COMMITTED ) 。 幻读将隔离级别设置为 REPEATABLE READ ( 可被重复读取 ) : 1234567SET GLOBAL TRANSACTION ISOLATION LEVEL REPEATABLE READ;SELECT @@GLOBAL.TRANSACTION_ISOLATION;+--------------------------------+| @@GLOBAL.TRANSACTION_ISOLATION |+--------------------------------+| REPEATABLE-READ |+--------------------------------+ 测试 REPEATABLE READ ，假设在两个不同的连接上分别执行 START TRANSACTION : 123456789-- 小张 - 成都START TRANSACTION;INSERT INTO user VALUES (6, 'd', 1000);-- 小王 - 北京START TRANSACTION;-- 小张 - 成都COMMIT; 当前事务开启后，没提交之前，查询不到，提交后可以被查询到。但是，在提交之前其他事务被开启了，那么在这条事务线上，就不会查询到当前有操作事务的连接。相当于开辟出一条单独的线程。 无论小张是否执行过 COMMIT ，在小王这边，都不会查询到小张的事务记录，而是只会查询到自己所处事务的记录： 12345678910SELECT * FROM user;+----+-----------+-------+| id | name | money |+----+-----------+-------+| 1 | a | 900 || 2 | b | 1100 || 3 | 小明 | 1000 || 4 | 淘宝店 | 1000 || 5 | c | 100 |+----+-----------+-------+ 这是因为小王在此之前开启了一个新的事务 ( START TRANSACTION ) **，那么在他的这条新事务的线上，跟其他事务是没有联系的**，也就是说，此时如果其他事务正在操作数据，它是不知道的。 然而事实是，在真实的数据表中，小张已经插入了一条数据。但是小王此时并不知道，也插入了同一条数据，会发生什么呢？ 12INSERT INTO user VALUES (6, 'd', 1000);-- ERROR 1062 (23000): Duplicate entry '6' for key 'PRIMARY' 报错了，操作被告知已存在主键为 6 的字段。这种现象也被称为幻读，一个事务提交的数据，不能被其他事务读取到。 串行化顾名思义，就是所有事务的写入操作全都是串行化的。什么意思？把隔离级别修改成 SERIALIZABLE : 1234567SET GLOBAL TRANSACTION ISOLATION LEVEL SERIALIZABLE;SELECT @@GLOBAL.TRANSACTION_ISOLATION;+--------------------------------+| @@GLOBAL.TRANSACTION_ISOLATION |+--------------------------------+| SERIALIZABLE |+--------------------------------+ 还是拿小张和小王来举例： 123456789101112131415161718192021-- 小张 - 成都START TRANSACTION;-- 小王 - 北京START TRANSACTION;-- 开启事务之前先查询表，准备操作数据。SELECT * FROM user;+----+-----------+-------+| id | name | money |+----+-----------+-------+| 1 | a | 900 || 2 | b | 1100 || 3 | 小明 | 1000 || 4 | 淘宝店 | 1000 || 5 | c | 100 || 6 | d | 1000 |+----+-----------+-------+-- 发现没有 7 号王小花，于是插入一条数据：INSERT INTO user VALUES (7, &#39;王小花&#39;, 1000); 此时会发生什么呢？由于现在的隔离级别是 SERIALIZABLE ( 串行化 ) ，串行化的意思就是：假设把所有的事务都放在一个串行的队列中，那么所有的事务都会按照固定顺序执行，执行完一个事务后再继续执行下一个事务的写入操作 ( 这意味着队列中同时只能执行一个事务的写入操作 ) 。 根据这个解释，小王在插入数据时，会出现等待状态，直到小张执行 COMMIT 结束它所处的事务，或者出现等待超时。","tags":[{"name":"MySQL","slug":"MySQL","permalink":"http://yoursite.com/tags/MySQL/"}]},{"title":"leetcode_766","date":"2020-05-27T04:12:28.000Z","path":"2020/05/27/leetcode-766/","text":"766.托普利茨矩阵 给定一个矩阵，判断其是否为托普利茨矩阵（如果一个矩阵的每一方向由左上到右下的对角线上具有相同元素，那么这个矩阵是托普利茨矩阵）。 解： 要理解对角线在矩阵中的数学表达。 对于对角线上后来出现的元素，托普利茨矩阵要求其与左上角的元素，即同一对角线上先出现的元素相同，元素A[i][j]的左上角元素为A[i-1][j-1]，遍历除了第一行&amp;第一列外的所有元素，若全与左上角相同，则返回true，否则返回false。 12345678910bool isToeplitzMatrix(vector&lt;vector&lt;int&gt;&gt;&amp; matrix) &#123; if(matrix.size()==1 || matrix[0].size()==1) return true; for(int i=1; i&lt;matrix.size(); i++)&#123; for(int j=1; j&lt;matrix[0].size(); j++)&#123; if(matrix[i][j]!=matrix[i-1][j-1]) return false; &#125; &#125; return true;&#125; 复杂度时间复杂度：O(m*n)。 空间复杂度：O(1)。 Tip：C++中二维数组的列数为matrix.length，行数为matrix[0].length。","tags":[{"name":"array","slug":"array","permalink":"http://yoursite.com/tags/array/"}]},{"title":"leetcode_867","date":"2020-05-27T03:10:42.000Z","path":"2020/05/27/leetcode-867/","text":"867.转置矩阵 给定一个矩阵，要求返回其转置矩阵（矩阵由二维vector存储）。 解： m*n的矩阵转置后会得到n*m的矩阵，假设原矩阵为A，转置后矩阵为B，则A[i][j] =B[j][j]。 嵌套for循环对二维数组逐个赋值即可。 Tip：C++中VECTOR的容量问题。 方法 效果 size() 返回容器的大小 empty() 判断容器是否为空 max_size() 返回容器最大的可以存储的元素 capacity() 返回容器当前能够容纳的元素数量 如果v.push_back(1)，容器本身可以提供且存储的元素为n个，加入一个元素后空间不足，申请后大小变为原来的两倍，固得到的size为n+1，而得到的capacity为2n。","tags":[{"name":"array","slug":"array","permalink":"http://yoursite.com/tags/array/"}]},{"title":"HTML快查","date":"2020-05-21T09:41:14.000Z","path":"2020/05/21/HTML快查/","text":"HTML语法快查 HTML基本框架1234567891011121314151617&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;title&gt;文档标题&lt;&#x2F;title&gt;&lt;&#x2F;head&gt;&lt;body&gt;可见文本...&lt;&#x2F;body&gt;&lt;&#x2F;html&gt; 基本标签12345678910111213141516171819&lt;h1&gt;最大的标题&lt;&#x2F;h1&gt;&lt;h2&gt; . . . &lt;&#x2F;h2&gt;&lt;h3&gt; . . . &lt;&#x2F;h3&gt;&lt;h4&gt; . . . &lt;&#x2F;h4&gt;&lt;h5&gt; . . . &lt;&#x2F;h5&gt;&lt;h6&gt;最小的标题&lt;&#x2F;h6&gt;&lt;p&gt;这是一个段落。&lt;&#x2F;p&gt;&lt;br&gt; （换行）&lt;hr&gt; （水平线）&lt;!-- 这是注释 --&gt; 文本格式化123456789101112131415161718192021222324252627282930313233&lt;b&gt;粗体文本&lt;&#x2F;b&gt;&lt;code&gt;计算机代码&lt;&#x2F;code&gt;&lt;em&gt;强调文本&lt;&#x2F;em&gt;&lt;i&gt;斜体文本&lt;&#x2F;i&gt;&lt;kbd&gt;键盘输入&lt;&#x2F;kbd&gt;&lt;pre&gt;预格式化文本&lt;&#x2F;pre&gt;&lt;small&gt;更小的文本&lt;&#x2F;small&gt;&lt;strong&gt;重要的文本&lt;&#x2F;strong&gt;&lt;abbr&gt; （缩写）&lt;address&gt; （联系信息）&lt;bdo&gt; （文字方向）&lt;blockquote&gt; （从另一个源引用的部分）&lt;cite&gt; （工作的名称）&lt;del&gt; （删除的文本）&lt;ins&gt; （插入的文本）&lt;sub&gt; （下标文本）&lt;sup&gt; （上标文本） 链接123456789101112普通的链接：&lt;a href&#x3D;&quot;http:&#x2F;&#x2F;www.example.com&#x2F;&quot;&gt;链接文本&lt;&#x2F;a&gt;图像链接： &lt;a href&#x3D;&quot;http:&#x2F;&#x2F;www.example.com&#x2F;&quot;&gt;&lt;img src&#x3D;&quot;URL&quot;alt&#x3D;&quot;替换文本&quot;&gt;&lt;&#x2F;a&gt;邮件链接： &lt;a href&#x3D;&quot;mailto:webmaster@example.com&quot;&gt;发送e-mail&lt;&#x2F;a&gt;书签：&lt;a id&#x3D;&quot;tips&quot;&gt;提示部分&lt;&#x2F;a&gt;&lt;a href&#x3D;&quot;#tips&quot;&gt;跳到提示部分&lt;&#x2F;a&gt; 图片1&lt;img src&#x3D;&quot;URL&quot; alt&#x3D;&quot;替换文本&quot; height&#x3D;&quot;42&quot; width&#x3D;&quot;42&quot;&gt; 区块1234567891011&lt;style type&#x3D;&quot;text&#x2F;css&quot;&gt;h1 &#123;color:red;&#125;p &#123;color:blue;&#125;&lt;&#x2F;style&gt;&lt;div&gt;文档中的块级元素&lt;&#x2F;div&gt;&lt;span&gt;文档中的内联元素&lt;&#x2F;span&gt; 无序有序列表12345678910111213141516&lt;ul&gt; &lt;li&gt;项目&lt;&#x2F;li&gt; &lt;li&gt;项目&lt;&#x2F;li&gt;&lt;&#x2F;ul&gt;&lt;ol&gt; &lt;li&gt;第一项&lt;&#x2F;li&gt; &lt;li&gt;第二项&lt;&#x2F;li&gt;&lt;&#x2F;ol&gt; 定义列表1234567891011&lt;dl&gt; &lt;dt&gt;项目 1&lt;&#x2F;dt&gt; &lt;dd&gt;描述项目 1&lt;&#x2F;dd&gt; &lt;dt&gt;项目 2&lt;&#x2F;dt&gt; &lt;dd&gt;描述项目 2&lt;&#x2F;dd&gt;&lt;&#x2F;dl&gt; 表格12345678910111213141516171819&lt;table border&#x3D;&quot;1&quot;&gt; &lt;tr&gt; &lt;th&gt;表格标题&lt;&#x2F;th&gt; &lt;th&gt;表格标题&lt;&#x2F;th&gt; &lt;&#x2F;tr&gt; &lt;tr&gt; &lt;td&gt;表格数据&lt;&#x2F;td&gt; &lt;td&gt;表格数据&lt;&#x2F;td&gt; &lt;&#x2F;tr&gt;&lt;&#x2F;table&gt; 框架1&lt;iframe src&#x3D;&quot;demo_iframe.htm&quot;&gt;&lt;&#x2F;iframe&gt; 表单1234567891011121314151617181920212223242526272829&lt;form action&#x3D;&quot;demo_form.php&quot; method&#x3D;&quot;post&#x2F;get&quot;&gt;&lt;input type&#x3D;&quot;text&quot; name&#x3D;&quot;email&quot; size&#x3D;&quot;40&quot; maxlength&#x3D;&quot;50&quot;&gt;&lt;input type&#x3D;&quot;password&quot;&gt;&lt;input type&#x3D;&quot;checkbox&quot; checked&#x3D;&quot;checked&quot;&gt;&lt;input type&#x3D;&quot;radio&quot; checked&#x3D;&quot;checked&quot;&gt;&lt;input type&#x3D;&quot;submit&quot; value&#x3D;&quot;Send&quot;&gt;&lt;input type&#x3D;&quot;reset&quot;&gt;&lt;input type&#x3D;&quot;hidden&quot;&gt;&lt;select&gt;&lt;option&gt;苹果&lt;&#x2F;option&gt;&lt;option selected&#x3D;&quot;selected&quot;&gt;香蕉&lt;&#x2F;option&gt;&lt;option&gt;樱桃&lt;&#x2F;option&gt;&lt;&#x2F;select&gt;&lt;textarea name&#x3D;&quot;comment&quot; rows&#x3D;&quot;60&quot; cols&#x3D;&quot;20&quot;&gt;&lt;&#x2F;textarea&gt;&lt;&#x2F;form&gt; 实体12345&lt; 等同于 &lt;&gt; 等同于 &gt;&amp;#169; 等同于 ©","tags":[{"name":"HTML","slug":"HTML","permalink":"http://yoursite.com/tags/HTML/"}]},{"title":"HTML入门","date":"2020-05-21T09:30:54.000Z","path":"2020/05/21/HTML入门/","text":"HTML的入门学习 12345678910111213&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset&#x3D;&quot;utf-8&quot;&gt;&lt;title&gt;Vain&lt;&#x2F;title&gt;&lt;&#x2F;head&gt;&lt;body&gt;&lt;h1&gt;标题&lt;&#x2F;h1&gt;&lt;p&gt;段落。&lt;&#x2F;p&gt;&lt;&#x2F;body&gt;&lt;&#x2F;html&gt; &lt;!DOCTYPE html&gt; 声明为 HTML5 文档&lt;html&gt; 元素是 HTML 页面的根元素&lt;head&gt; 元素包含了文档的元（meta）数据，如 &lt;meta charset=”utf-8”&gt;定义网页编码格式为 utf-8（中文）。&lt;title&gt; 元素描述了文档的标题&lt;body&gt; 元素包含了可见的页面内容&lt;h1&gt; 元素定义一个大标题&lt;p&gt; 元素定义一个段落 …… 注：在浏览器的页面上使用键盘上的 F12 按键开启调试模式，就可以看到组成标签。 Hyper Text Markup Language——标记语言 HTML元素包括 &lt;标签&gt;内容&lt;/标签&gt; 开始标签-内容-结束标签 注：只有 &lt;body&gt;才会在浏览器中显示。 编译器Visual Studio Code（简称 VS Code）。 新建HTML文件另存为HTML文件在浏览器中运行这个 HTML 文件 元素 开始标签 含义 结束标签 &lt;p&gt; 这是一个段落 &lt;/p&gt; &lt;a href=”default.htm”&gt; 这是一个链接 &lt;/a&gt; &lt;br&gt; 换行 &lt;h1&gt; 这是一个标题 &lt;/h1&gt; 标题（Heading）是通过&lt;h1&gt;-&lt;h6&gt;标签进行定义的。&lt;h1&gt;定义最大的标题。&lt;h6&gt;定义最小的标题。请确保将HTML标题标签只用于标题。不要仅仅是为了生成粗体或大号的文本而使用标题。浏览器会自动地在标题的前后添加空行。 搜索引擎使用标题为您的网页的结构和内容编制索引。&lt;br&gt;就是没有关闭标签的空元素，但使用&lt;br/&gt;更正规。 &lt;hr&gt; 标签在 HTML 页面中创建水平线。 &lt;!– 这是一个注释 –&gt; &lt;body&gt; 定义文档的主体 标签使用小写。 属性 类型 作用 class 为html元素定义一个或多个类名 id 定义元素的唯一id style 规定元素的行内样式（inlinestyle） title 描述了元素的额外信息(作为工具条使用) 属性值应该始终被包括在双引号内；在某些个别的情况下，比如属性值本身就含有双引号，则使用单引号。 属性使用小写。 文本格式化&lt;b&gt;加粗文本&lt;/b&gt; &lt;i&gt;斜体文本&lt;/i&gt; &lt;code&gt;电脑自动输出&lt;/code&gt; 这是 &lt;sub&gt; 下标&lt;/sub&gt; 和 &lt;sup&gt; 上标&lt;/sup&gt; 链接&lt;p&gt;&lt;a href=”//www.microsoft.com/&quot;\\&gt;本文本\\&lt;/a&gt;是一个指向万维网上的页面的链接。&lt;/p&gt; 默认情况下：一个未访问过的链接显示为蓝色字体并带有下划线。访问过的链接显示为紫色并带有下划线。点击链接时，链接显示为红色并带有下划线。 可以通过属性定义链接，如target、id，已适应不同的场景和需求。可以对超链接设置CSS样式，展示样式会根据CSS的设定而显示。 头部&lt;head&gt;元素包含了所有的头部标签元素。在&lt;head&gt;元素中你可以插入脚本（scripts）,样式文件（CSS），及各种meta信息。 可以添加在头部区域的元素标签为:&lt;title&gt;,&lt;style&gt;,&lt;meta&gt;,&lt;link&gt;,&lt;script&gt;,&lt;noscript&gt;和&lt;base&gt;。&lt;script&gt;标签用于加载脚本文件，如：JavaScript。 标签 描述 &lt;head&gt; 定义了文档的信息 &lt;title&gt; 定义了文档的标题 &lt;base&gt; 定义了页面链接标签的默认链接地址 &lt;link&gt; 定义了一个文档和外部资源之间的关系 &lt;meta&gt; 定义了HTML文档中的元数据 &lt;script&gt; 定义了客户端的脚本文件 &lt;style&gt; 定义了HTML文档的样式文件 CSSCSS (Cascading Style Sheets) 用于渲染HTML元素标签的样式。 CSS可以通过以下方式添加到HTML中: 1·内联样式-在HTML元素中使用”style”属性； 2·内部样式表-在HTML文档头部&lt;head&gt;区域使用&lt;style&gt;元素来包含CSS； 3·外部引用-使用外部CSS文件。 最好的方式是通过外部引用CSS文件。 对于大部分标签，”内联”和”外引”两种方式均可，且修改父级标签，子级标签特性也会改变。但某些标签确无法通过修改父级标签来改变子级标签特性，如a标签，修改其颜色特性，必须直接修改a标签的特性才可。 图像&lt;img border=”0” src=”/images/pulpit.jpg” alt=”Pulpit rock” width=”304”height=”228”&gt; 加载页面时，要注意插入页面图像的路径，如果不能正确设置图像的位置，浏览器无法加载图片，图像标签就会显示一个破碎的图片。 表格表格由&lt;table&gt;标签来定义。每个表格均有若干行（由&lt;tr&gt;标签定义），每行被分割为若干单元格（由&lt;td&gt;标签定义）。字母td指表格数据（tabledata），即数据单元格的内容。数据单元格可以包含文本、图片、列表、段落、表单、水平线、表格等等。 列表等不赘述。 区块大多数HTML元素被定义为块级元素或内联元素。 ——块级元素在浏览器显示时，通常会以新行来开始（和结束）。 HTML&lt;div&gt;元素是块级元素，它可用于组合其他HTML元素的容器。 &lt;div&gt;元素没有特定的含义。除此之外，由于它属于块级元素，浏览器会在其前后显示折行。如果与CSS一同使用，&lt;div&gt;元素可用于对大的内容块设置样式属性。&lt;div&gt;元素的另一个常见的用途是文档布局。 ——内联元素在显示时通常不会以新行开始。 HTML&lt;span&gt;元素是内联元素，可用作文本的容器，&lt;span&gt;元素也没有特定的含义。 当与CSS一同使用时，&lt;span&gt;元素可用于为部分文本设置样式属性。 布局网页布局对改善网站的外观非常重要。 大多数网站可以使用&lt;div&gt;或者&lt;table&gt;元素来创建多列。CSS用于对元素进行定位，或者为页面创建背景以及色彩丰富的外观。 使用CSS最大的好处是，如果把CSS代码存放到外部样式表中，那么站点会更易于维护。通过编辑单一的文件，就可以改变所有页面的布局。 表单HTML 表单用于收集不同类型的用户输入。 表单是一个包含表单元素的区域。表单元素是允许用户在表单中输入内容,比如：文本域(textarea)、下拉列表、单选框(radio-buttons)、复选框(checkboxes)等等。表单使用表单标签&lt;form&gt;来设置。 文本域通过&lt;inputtype=”text”&gt;标签来设定，当用户要在表单中键入字母、数字等内容时，就会用到文本域。 密码字段通过标签&lt;input type=”password”&gt;来定义。 &lt;inputtype=”radio”&gt;标签定义了表单单选框选项。可以设置以下几个属性：value、name、checked。 &lt;inputtype=”checkbox”&gt;定义了复选框。用户需要从若干给定的选择中选取一个或若干选项。 &lt;inputtype=”submit”&gt;定义了提交按钮。当用户单击确认按钮时，表单的内容会被传送到另一个文件。表单的动作属性定义了目的文件的文件名。由动作属性定义的这个文件通常会对接收到的输入数据进行相关的处理。 此外还有下拉列表选项、计算结果等。 框架通过使用框架，可以在同一个浏览器窗口中显示不止一个页面。 iframe语法: &lt;iframesrc=”URL”&gt;&lt;/iframe&gt; 该URL指向不同的网页。 颜色HTML颜色由一个十六进制符号来定义，这个符号由红色、绿色和蓝色的值组成（RGB）。 每种颜色的最小值是0（十六进制：#00）。最大值是255（十六进制：#FF）。 RGBA的意思是（Red-Green-Blue-Alpha）它是在RGB上扩展包括了“alpha”通道，运行对颜色值设置透明度。 141个颜色名称是在HTML和CSS颜色规范定义的（17标准颜色，再加124）。 脚本JavaScript使HTML页面具有更强的动态和交互性。 &lt;script&gt;标签用于定义客户端脚本，比如JavaScript，其既可包含脚本语句，也可通过src属性指向外部脚本文件。 &lt;noscript&gt;标签提供无法使用脚本时的替代内容，比方在浏览器禁用脚本时，或浏览器不支持客户端脚本时；只有在浏览器不支持脚本或者禁用脚本时，才会显示&lt;noscript&gt;元素中的内容。 字符实体HTML中的预留字符必须被替换为字符实体，以防浏览器误认为它们是标签。 HTML中的常用字符实体是不间断空格(&amp;nbsp;)。浏览器总是会截短HTML页面中的空格。如果在文本中写10个空格，在显示该页面之前，浏览器会删除它们中的9个。如需在页面中增加空格的数量，则需要使用&nbsp;字符实体。 URLURL——统一资源定位器是一个网页地址。 常见的URL Scheme（定义因特网服务的类型）—— Scheme 访问 用于… http 超文本传输协议 以 http:// 开头的普通网页。不加密。 https 安全超文本传输协议 安全网页，加密所有信息交换。 ftp 文件传输协议 用于将文件下载或上传至网站。 file 您计算机上的文件。","tags":[{"name":"HTML","slug":"HTML","permalink":"http://yoursite.com/tags/HTML/"}]},{"title":"leetcode_1","date":"2020-05-21T06:41:24.000Z","path":"2020/05/21/leetcode-1/","text":"1.两数之和 给定一个数组以及一个目标值——在该数组中找出和为目标值的那两个整数，并返回他们的数组下标。 解： 暴力法—— 遍历数组，对于每一个函数x，都再次遍历数组查找是否存在于target-x相等的元素。 两遍哈希表—— Hash表支持以近似恒定的速度查找元素，通过以空间换取速度的方式。使用两次迭代，第一次迭代将每个元素的值和它的索引添加到表中，；第二次迭代检查每个元素所对应的目标元素target-x是否存在于表中。 12345678910111213class Solution &#123;public: vector&lt;int&gt; twoSum(vector&lt;int&gt;&amp; nums, int target) &#123; unordered_map&lt;int,int&gt; m; for(int i = 0; i&lt;nums.size(); i++) m[nums[i]] = i; //向map中添加元素 for(int i = 0; i&lt;nums.size(); i++)&#123; if(m.find(target-nums[i]) != m.end() &amp;&amp; m[target-nums[i]] != i)//如果m中存在对应的键值，且不为i return &#123;i, m[target-nums[i]]&#125;; &#125; return &#123;&#125;; &#125;&#125;; 复杂度暴力法 时间复杂度：O(n2)。对于每一个元素，都需要遍历整个数组来查找是否存在target-x。 空间复杂度：O(1)。 两遍哈希表 时间复杂度：O(n)。把数组遍历了两次，由于哈希表将查找时间缩短到O(1)，所以时间复杂度为O(n)。 空间复杂度：O(n)。所需的额外空间取决于哈希表中存储的元素数量，该表中存储了n个元素。 Tip：HashMap在resize、put的时候消耗了很多时间没有计算在内，但这些其实都属于初始化范畴，在实际开发中，其实是一次性开销。 Java集合类中的Map.containsKey()方法判断Map集合对象中是否包含指定的键名。如果Map集合中包含指定的键名，则返回true，否则返回false。 也去专门去查了hashMap.containsKey()的时间复杂度，使用指针指向数组引用，时间复杂度为O(1)，未命中时，才回去遍历红黑树，时间复杂度为O(n)，如果仔细地挑选哈希函数，在哈希表中进行查找的用时应当被摊销为O(1)。 C++中，在map中查找key为k的元素，返回指向它的迭代器。若k不存在，返回map::end，返回值是一个迭代器，成功返回迭代器指向要查找的元素，失败返回的迭代器指向end。 map unordered_map #include &lt;map&gt; #include &lt;unordered_map&gt; map内部实现了一个红黑树，该结构具有自动排序的功能，因此map内部的所有元素都是有序的，红黑树的效率决定了map的效率。 unordered_map内部实现了一个哈希表，因此其元素的排列顺序是杂乱的，无序的。 红黑树、有序、空间占用率高 哈希表、无序、耗费时间多 对于那些有顺序要求的问题，用map会更高效一些 对于查找问题，unordered_map会更加高效一些","tags":[{"name":"array","slug":"array","permalink":"http://yoursite.com/tags/array/"}]},{"title":"leetcode_167","date":"2020-05-21T03:39:09.000Z","path":"2020/05/21/leetcode-167/","text":"167.两数之和II -输入有序数组 给定一个升序排列的数组以及一个目标值——求数组中的两个元素和为目标值，并按序输出两个元素的下标。 解： 双指针法——分别记录第一个元素和最后一个元素，求和后与target值比较大小，偏大则移动尾指针（值变小），偏小则移动头指针（值变大），等于目标值则按序输出头尾指针。 复杂度时间复杂度：O(n)。每个元素最多被访问一次。 空间复杂度：O(1)。只是用了两个指针。 Tip：vector作为参数的三种传参方式 c++中常用的vector容器作为参数时（为说明问题，用二维vector）： function1(std::vector&lt;std::vector&lt;int&gt; &gt; vec)，传值 function2(std::vector&lt;std::vector&lt;int&gt; &gt;&amp; vec)，传引用 function3(std::vector&lt;std::vector&lt;int&gt; &gt;* vec)，传指针 三种方式对应的调用形式分别为： function1(vec)，传入值 function2(vec)，传入引用 function3(&amp;vec),传入地址 三种方式在函数调用时是否了vector的拷贝构造函数： 会发生拷贝构造 不会发生拷贝构造 不会发生拷贝构造 函数体 函数调用 拷贝构造函数 void 函数名(vector&lt;int&gt; obj); deal( vec ); void 函数名(vector&lt;int&gt;* pobj); deal( &amp;vec ); void 函数名(const vector&lt;int&gt;* pobj); deal( &amp;vec ); 调用时不会调用拷贝构造函数 void 函数名(vector&lt;int&gt;&amp; obj); deal( vec ); void 函数名(const vector&lt;int&gt;&amp; obj); deal( vec ); 调用时会调用拷贝构造函数 *如果需要在函数中对vector容器中数据调换顺序等操作需要是引用传递 1234567vector&lt;int&gt; twoSum(vector&lt;int&gt;&amp; numbers, int target) &#123; //… int low = 0, high = numbers.size() - 1; //… return &#123;low + 1, high + 1&#125;; //…&#125;","tags":[{"name":"array","slug":"array","permalink":"http://yoursite.com/tags/array/"}]},{"title":"leetcode_941","date":"2020-05-20T09:29:15.000Z","path":"2020/05/20/leetcode-941/","text":"941.有效的山脉数组 检查一个数组是否符合山脉数组——数组元素大于等于三个，且存在某中间元素，其前元素值为递增，其后元素值为递减。 解： 按照数组下标扫描即可，判断出峰元素（从1到length-1的前一个），然后检查其后是否递减，判断以及检查中若有相等或者相反变化的部分，则return false。","tags":[{"name":"array","slug":"array","permalink":"http://yoursite.com/tags/array/"}]},{"title":"leetcode_914","date":"2020-05-20T08:43:13.000Z","path":"2020/05/20/leetcode-914/","text":"914.卡牌分组 检查一个数组是否符合分组的规则——可以分成大小一样的若干数组且各个数组中的数字都一样（子数组长度最小为2）。 解： 统计各个数字出现的次数，然后求其是否存在最大公约数大于等于2。 12345678910111213141516//求最大公约数int gcd(int a,int b)&#123; if(b == 0) return a; return gcd(b,a%b);&#125;class Solution &#123;public: bool hasGroupsSizeX(vector\\&lt;int\\&gt;&amp; deck) &#123; int bucket[10000] = &#123;0&#125;; int g = 0; for (int d : deck) bucket[d]++; //基于范围的for循环(C++11) for (int b : bucket) g = gcd(b, g); return g \\&gt;= 2; &#125;&#125;; Tip： for 语句允许简单的范围迭代： 1234567891011int my_array[5] = &#123;1, 2, 3, 4, 5&#125;;// 每个数组元素乘于 2for (int &amp;x : my_array)&#123; x *= 2; cout &lt;&lt; x &lt;&lt; endl;&#125;// auto 类型也是 C++11 新标准中的，用来自动获取变量的类型for (auto &amp;x : my_array) &#123; x *= 2; cout &lt;&lt; x &lt;&lt; endl;&#125; 上面for述句的第一部分定义被用来做范围迭代的变量，就像被声明在一般for循环的变量一样，其作用域仅只于循环的范围。而在”:”之后的第二区块，代表将被迭代的范围。","tags":[{"name":"array","slug":"array","permalink":"http://yoursite.com/tags/array/"}]},{"title":"人物塑造-第二真","date":"2020-05-19T08:48:38.000Z","path":"2020/05/19/人物塑造-第二真/","text":"人的认知是片面独立的。 每个人对他人的认定大多源于某个既定影响，然后随着某个契机，这个印象不断完善，人的好奇心，对世界的感官，都在促使这件事的完成。 对这个契机的认知是价值观的体现，人们喜欢把想象中的自己沉浸在其中，用想象中的自己去判断一维的好坏。 是想象中的自己，因为人们对自己的认知偏颇难以避免，这种认知同样是片面的，人们在做决定的时候更多的是内心存在选择后，尝试去反驳和证明，反驳和证明都需要存在，这种公允的，中庸的冷静，在和渴望挂不上钩的时候是必然存在的，渴望存在前和是如此经历被琢磨的。 人们判断他人、事物的时候把想象中的自己带入，而判断的主角和法官都是自己的时候，人们把想象带入，这是更深一层的渴望，如果说上者人们还顾及道德和法律，在判断自己的人生时，人们的思绪更多像个辩论赛，这场辩论的比分则由理性的逻辑和感性的价值观决定了。 人们对自己的认知和对别人的认知是完全不同的存在，本文要讨论的就是对他人的认知。 对他人的认知是把想象中的自己带入去判决一维的正误。 人物的塑造譬如肖像描写，仅仅只是第一印象的加成，在文学艺术作品里，所谓人物塑造栩栩如生是需要后期的那个契机的，人物形象丰满必须要有的过程。 塑造人物的手法套路大多出于经验，很成熟的方法论，然而其内核就是完成对读者的认知引导。成功塑造人物需要第一印象的捏造以及后续的契机设立，这种解构的方式是对塑造手法的总结。 说回人们对他人的认知，人的内在逻辑其实是单向的，不仅仅是对体验结果的判决，更是对契机引起的变化的一种单向，这就是反差存在的逻辑。 被成功塑造的恶人，在肖像方面往往是文质彬彬甚至美轮美奂的，其恶当然不只是源于人们对他后续行径的一种价值观判决，更多的，是一种反差的存在，人们的内在逻辑简单化，一者，判决的理智会被这种曲线的填满，人们更倾向于坚信后来被说服的事情，这是源于对后悔的习性，轻车熟路的悔不当初并拍案叫绝；二者是对他人认知的成长判决的简单性，这种判决源于其反差的方向，和肖像的相对方向，这就是人们心中的预设期望。 预设期望源于对第一印象的判决，沉浸式判决加以经验，让肖像在人心里留下一个正或负的分数，而后的契机成长，如果正数的正向成长，人们会在逻辑上表示，哦，果然是这样，这就是毫无新意的普通好人或者坏人，但如果是负数的正向成长，那会给人以冲击，所谓丰满，就是让人们意识到自己的认知错误，人们感觉到成长，感官甚至人生层面上的丰满。 对于好人的预设是一样的，瑕疵感为后来的正向成长加分的，除了真实的不完美，更多的和负数的正面成长的逻辑相似，人们倾向于相信第二个真理。当然也可以简单理解为经验，譬如欲扬先抑或者是巴黎圣母院中的克洛德。 第二个真理的说服力是一个很强大的存在。 颠覆给人一种辩证的真实感，世界并不是非黑即白的，人物的塑造当然不只是为了正面这正误的共生性，更多的还是去引导这种逻辑，操控观者的认知过程，没有影视作品会想要用负数印象加一个正向成长来塑造负面形象的，即使这种负面形象是一种复杂的，难判定好与坏的人物形象，作品也会有偏颇，有初衷与结果。 第二个真理是引导思维认知的重要理论依据。","tags":[{"name":"随笔","slug":"随笔","permalink":"http://yoursite.com/tags/%E9%9A%8F%E7%AC%94/"}]},{"title":"lu","date":"2020-04-05T07:48:58.000Z","path":"2020/04/05/lu/","text":"热爱","tags":[{"name":"随笔","slug":"随笔","permalink":"http://yoursite.com/tags/%E9%9A%8F%E7%AC%94/"}]},{"title":"x","date":"2020-04-05T07:48:18.000Z","path":"2020/04/05/x/","text":"Practice in individual leetcode Three questions per article per day Tags and knowledge extension are important algorithm According to leetcode, summarize the application of various classical algorithms A single article to tabulate various algorithms python Grammar and application C++ Grammar and application artificial intelligence Scipy-python Sklearm-python Deep Learning(to realize machine learning) Machine learning taught by Wu enda Neural network(after the fifth lesson) (by 3Blue1Brow) Deep learning(a flower color book) by Ian Goodfellow Sequence modeling linux operation and maintenance development bottom layer","tags":[{"name":"x","slug":"x","permalink":"http://yoursite.com/tags/x/"}]}]