[{"title":"leetcode_1","date":"2020-05-21T06:41:24.000Z","path":"2020/05/21/leetcode-1/","text":"1.两数之和 给定一个数组以及一个目标值——在该数组中找出和为目标值的那两个整数，并返回他们的数组下标。 解： 暴力法—— 遍历数组，对于每一个函数x，都再次遍历数组查找是否存在于target-x相等的元素。 两遍哈希表—— Hash表支持以近似恒定的速度查找元素，通过以空间换取速度的方式。使用两次迭代，第一次迭代将每个元素的值和它的索引添加到表中，；第二次迭代检查每个元素所对应的目标元素target-x是否存在于表中。 12345678910111213class Solution &#123;public: vector&lt;int&gt; twoSum(vector&lt;int&gt;&amp; nums, int target) &#123; unordered_map&lt;int,int&gt; m; for(int i = 0; i&lt;nums.size(); i++) m[nums[i]] = i; //向map中添加元素 for(int i = 0; i&lt;nums.size(); i++)&#123; if(m.find(target-nums[i]) != m.end() &amp;&amp; m[target-nums[i]] != i)//如果m中存在对应的键值，且不为i return &#123;i, m[target-nums[i]]&#125;; &#125; return &#123;&#125;; &#125;&#125;; 复杂度暴力法 时间复杂度：O(n2)。对于每一个元素，都需要遍历整个数组来查找是否存在target-x。 空间复杂度：O(1)。 两遍哈希表 时间复杂度：O(n)。把数组遍历了两次，由于哈希表将查找时间缩短到O(1)，所以时间复杂度为O(n)。 空间复杂度：O(n)。所需的额外空间取决于哈希表中存储的元素数量，该表中存储了n个元素。 Tip：HashMap在resize、put的时候消耗了很多时间没有计算在内，但这些其实都属于初始化范畴，在实际开发中，其实是一次性开销。 Java集合类中的Map.containsKey()方法判断Map集合对象中是否包含指定的键名。如果Map集合中包含指定的键名，则返回true，否则返回false。 也去专门去查了hashMap.containsKey()的时间复杂度，使用指针指向数组引用，时间复杂度为O(1)，未命中时，才回去遍历红黑树，时间复杂度为O(n)，如果仔细地挑选哈希函数，在哈希表中进行查找的用时应当被摊销为O(1)。 C++中，在map中查找key为k的元素，返回指向它的迭代器。若k不存在，返回map::end，返回值是一个迭代器，成功返回迭代器指向要查找的元素，失败返回的迭代器指向end。 map unordered_map #include &lt;map&gt; #include &lt;unordered_map&gt; map内部实现了一个红黑树，该结构具有自动排序的功能，因此map内部的所有元素都是有序的，红黑树的效率决定了map的效率。 unordered_map内部实现了一个哈希表，因此其元素的排列顺序是杂乱的，无序的。 红黑树、有序、空间占用率高 哈希表、无序、耗费时间多 对于那些有顺序要求的问题，用map会更高效一些 对于查找问题，unordered_map会更加高效一些","tags":[{"name":"array","slug":"array","permalink":"http://yoursite.com/tags/array/"}]},{"title":"leetcode_167","date":"2020-05-21T03:39:09.000Z","path":"2020/05/21/leetcode-167/","text":"167.两数之和II -输入有序数组 给定一个升序排列的数组以及一个目标值——求数组中的两个元素和为目标值，并按序输出两个元素的下标。 解： 双指针法——分别记录第一个元素和最后一个元素，求和后与target值比较大小，偏大则移动尾指针（值变小），偏小则移动头指针（值变大），等于目标值则按序输出头尾指针。 复杂度时间复杂度：O(n)。每个元素最多被访问一次。 空间复杂度：O(1)。只是用了两个指针。 Tip：vector作为参数的三种传参方式 c++中常用的vector容器作为参数时（为说明问题，用二维vector）： function1(std::vector&lt;std::vector&lt;int&gt; &gt; vec)，传值 function2(std::vector&lt;std::vector&lt;int&gt; &gt;&amp; vec)，传引用 function3(std::vector&lt;std::vector&lt;int&gt; &gt;* vec)，传指针 三种方式对应的调用形式分别为： function1(vec)，传入值 function2(vec)，传入引用 function3(&amp;vec),传入地址 三种方式在函数调用时是否了vector的拷贝构造函数： 会发生拷贝构造 不会发生拷贝构造 不会发生拷贝构造 函数体 函数调用 拷贝构造函数 void 函数名(vector&lt;int&gt; obj); deal( vec ); void 函数名(vector&lt;int&gt;* pobj); deal( &amp;vec ); void 函数名(const vector&lt;int&gt;* pobj); deal( &amp;vec ); 调用时不会调用拷贝构造函数 void 函数名(vector&lt;int&gt;&amp; obj); deal( vec ); void 函数名(const vector&lt;int&gt;&amp; obj); deal( vec ); 调用时会调用拷贝构造函数 *如果需要在函数中对vector容器中数据调换顺序等操作需要是引用传递 1234567vector&lt;int&gt; twoSum(vector&lt;int&gt;&amp; numbers, int target) &#123; //… int low = 0, high = numbers.size() - 1; //… return &#123;low + 1, high + 1&#125;; //…&#125;","tags":[{"name":"array","slug":"array","permalink":"http://yoursite.com/tags/array/"}]},{"title":"leetcode_941","date":"2020-05-20T09:29:15.000Z","path":"2020/05/20/leetcode-941/","text":"941.有效的山脉数组 检查一个数组是否符合山脉数组——数组元素大于等于三个，且存在某中间元素，其前元素值为递增，其后元素值为递减。 解： 按照数组下标扫描即可，判断出峰元素（从1到length-1的前一个），然后检查其后是否递减，判断以及检查中若有相等或者相反变化的部分，则return false。","tags":[{"name":"array","slug":"array","permalink":"http://yoursite.com/tags/array/"}]},{"title":"leetcode_914","date":"2020-05-20T08:43:13.000Z","path":"2020/05/20/leetcode-914/","text":"914.卡牌分组 检查一个数组是否符合分组的规则——可以分成大小一样的若干数组且各个数组中的数字都一样（子数组长度最小为2）。 解： 统计各个数字出现的次数，然后求其是否存在最大公约数大于等于2。 12345678910111213141516//求最大公约数int gcd(int a,int b)&#123; if(b == 0) return a; return gcd(b,a%b);&#125;class Solution &#123;public: bool hasGroupsSizeX(vector\\&lt;int\\&gt;&amp; deck) &#123; int bucket[10000] = &#123;0&#125;; int g = 0; for (int d : deck) bucket[d]++; //基于范围的for循环(C++11) for (int b : bucket) g = gcd(b, g); return g \\&gt;= 2; &#125;&#125;; Tip： for 语句允许简单的范围迭代： 1234567891011int my_array[5] = &#123;1, 2, 3, 4, 5&#125;;// 每个数组元素乘于 2for (int &amp;x : my_array)&#123; x *= 2; cout &lt;&lt; x &lt;&lt; endl;&#125;// auto 类型也是 C++11 新标准中的，用来自动获取变量的类型for (auto &amp;x : my_array) &#123; x *= 2; cout &lt;&lt; x &lt;&lt; endl;&#125; 上面for述句的第一部分定义被用来做范围迭代的变量，就像被声明在一般for循环的变量一样，其作用域仅只于循环的范围。而在”:”之后的第二区块，代表将被迭代的范围。","tags":[{"name":"array","slug":"array","permalink":"http://yoursite.com/tags/array/"}]},{"title":"人物塑造-第二真","date":"2020-05-19T08:48:38.000Z","path":"2020/05/19/人物塑造-第二真/","text":"人的认知是片面独立的。 每个人对他人的认定大多源于某个既定影响，然后随着某个契机，这个印象不断完善，人的好奇心，对世界的感官，都在促使这件事的完成。 对这个契机的认知是价值观的体现，人们喜欢把想象中的自己沉浸在其中，用想象中的自己去判断一维的好坏。 是想象中的自己，因为人们对自己的认知偏颇难以避免，这种认知同样是片面的，人们在做决定的时候更多的是内心存在选择后，尝试去反驳和证明，反驳和证明都需要存在，这种公允的，中庸的冷静，在和渴望挂不上钩的时候是必然存在的，渴望存在前和是如此经历被琢磨的。 人们判断他人、事物的时候把想象中的自己带入，而判断的主角和法官都是自己的时候，人们把想象带入，这是更深一层的渴望，如果说上者人们还顾及道德和法律，在判断自己的人生时，人们的思绪更多像个辩论赛，这场辩论的比分则由理性的逻辑和感性的价值观决定了。 人们对自己的认知和对别人的认知是完全不同的存在，本文要讨论的就是对他人的认知。 对他人的认知是把想象中的自己带入去判决一维的正误。 人物的塑造譬如肖像描写，仅仅只是第一印象的加成，在文学艺术作品里，所谓人物塑造栩栩如生是需要后期的那个契机的，人物形象丰满必须要有的过程。 塑造人物的手法套路大多出于经验，很成熟的方法论，然而其内核就是完成对读者的认知引导。成功塑造人物需要第一印象的捏造以及后续的契机设立，这种解构的方式是对塑造手法的总结。 说回人们对他人的认知，人的内在逻辑其实是单向的，不仅仅是对体验结果的判决，更是对契机引起的变化的一种单向，这就是反差存在的逻辑。 被成功塑造的恶人，在肖像方面往往是文质彬彬甚至美轮美奂的，其恶当然不只是源于人们对他后续行径的一种价值观判决，更多的，是一种反差的存在，人们的内在逻辑简单化，一者，判决的理智会被这种曲线的填满，人们更倾向于坚信后来被说服的事情，这是源于对后悔的习性，轻车熟路的悔不当初并拍案叫绝；二者是对他人认知的成长判决的简单性，这种判决源于其反差的方向，和肖像的相对方向，这就是人们心中的预设期望。 预设期望源于对第一印象的判决，沉浸式判决加以经验，让肖像在人心里留下一个正或负的分数，而后的契机成长，如果正数的正向成长，人们会在逻辑上表示，哦，果然是这样，这就是毫无新意的普通好人或者坏人，但如果是负数的正向成长，那会给人以冲击，所谓丰满，就是让人们意识到自己的认知错误，人们感觉到成长，感官甚至人生层面上的丰满。 对于好人的预设是一样的，瑕疵感为后来的正向成长加分的，除了真实的不完美，更多的和负数的正面成长的逻辑相似，人们倾向于相信第二个真理。当然也可以简单理解为经验，譬如欲扬先抑或者是巴黎圣母院中的克洛德。 第二个真理的说服力是一个很强大的存在。 颠覆给人一种辩证的真实感，世界并不是非黑即白的，人物的塑造当然不只是为了正面这正误的共生性，更多的还是去引导这种逻辑，操控观者的认知过程，没有影视作品会想要用负数印象加一个正向成长来塑造负面形象的，即使这种负面形象是一种复杂的，难判定好与坏的人物形象，作品也会有偏颇，有初衷与结果。 第二个真理是引导思维认知的重要理论依据。","tags":[{"name":"随笔","slug":"随笔","permalink":"http://yoursite.com/tags/%E9%9A%8F%E7%AC%94/"}]},{"title":"lu","date":"2020-04-05T07:48:58.000Z","path":"2020/04/05/lu/","text":"热爱","tags":[{"name":"随笔","slug":"随笔","permalink":"http://yoursite.com/tags/%E9%9A%8F%E7%AC%94/"}]},{"title":"x","date":"2020-04-05T07:48:18.000Z","path":"2020/04/05/x/","text":"Practice in individual leetcode Three questions per article per day Tags and knowledge extension are important algorithm According to leetcode, summarize the application of various classical algorithms A single article to tabulate various algorithms python Grammar and application C++ Grammar and application artificial intelligence Scipy-python Sklearm-python Deep Learning(to realize machine learning) Machine learning taught by Wu enda Neural network(after the fifth lesson) (by 3Blue1Brow) Deep learning(a flower color book) by Ian Goodfellow Sequence modeling linux operation and maintenance development bottom layer","tags":[{"name":"x","slug":"x","permalink":"http://yoursite.com/tags/x/"}]}]