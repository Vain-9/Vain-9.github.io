[{"title":"MySQL_编程一五八俱乐部","date":"2020-05-27T04:22:14.000Z","path":"2020/05/27/MySQL-编程一五八俱乐部/","text":"MySQL学习笔记 登录和退出MySQL服务器12345# 登录MySQL$ mysql -u root -p12345612# 退出MySQL数据库服务器exit; 基本语法12345678910111213141516171819202122232425262728293031323334353637383940-- 显示所有数据库show databases;-- 创建数据库CREATE DATABASE test;-- 切换数据库use test;-- 显示数据库中的所有表show tables;-- 创建数据表CREATE TABLE pet ( name VARCHAR(20), owner VARCHAR(20), species VARCHAR(20), sex CHAR(1), birth DATE, death DATE);-- 查看数据表结构-- describe pet;desc pet;-- 查询表SELECT * from pet;-- 插入数据INSERT INTO pet VALUES (&#39;puffball&#39;, &#39;Diane&#39;, &#39;hamster&#39;, &#39;f&#39;, &#39;1990-03-30&#39;, NULL);-- 修改数据UPDATE pet SET name &#x3D; &#39;squirrel&#39; where owner &#x3D; &#39;Diane&#39;;-- 删除数据DELETE FROM pet where name &#x3D; &#39;squirrel&#39;;-- 删除表DROP TABLE myorder; 建表约束主键约束123456789101112131415161718192021222324252627282930-- 主键约束-- 使某个字段不重复且不得为空，确保表内所有数据的唯一性。CREATE TABLE user ( id INT PRIMARY KEY, name VARCHAR(20));-- 联合主键-- 联合主键中的每个字段都不能为空，并且加起来不能和已设置的联合主键重复。CREATE TABLE user ( id INT, name VARCHAR(20), password VARCHAR(20), PRIMARY KEY(id, name));-- 自增约束-- 自增约束的主键由系统自动递增分配。CREATE TABLE user ( id INT PRIMARY KEY AUTO_INCREMENT, name VARCHAR(20));-- 添加主键约束-- 如果忘记设置主键，还可以通过SQL语句设置（两种方式）：ALTER TABLE user ADD PRIMARY KEY(id);ALTER TABLE user MODIFY id INT PRIMARY KEY;-- 删除主键ALTER TABLE user drop PRIMARY KEY; 唯一主键1234567891011121314-- 建表时创建唯一主键CREATE TABLE user ( id INT, name VARCHAR(20), UNIQUE(name));-- 添加唯一主键-- 如果建表时没有设置唯一建，还可以通过SQL语句设置（两种方式）：ALTER TABLE user ADD UNIQUE(name);ALTER TABLE user MODIFY name VARCHAR(20) UNIQUE;-- 删除唯一主键ALTER TABLE user DROP INDEX name; 非空约束123456789-- 建表时添加非空约束-- 约束某个字段不能为空CREATE TABLE user ( id INT, name VARCHAR(20) NOT NULL);-- 移除非空约束ALTER TABLE user MODIFY name VARCHAR(20); 默认约束12345678910-- 建表时添加默认约束-- 约束某个字段的默认值CREATE TABLE user2 ( id INT, name VARCHAR(20), age INT DEFAULT 10);-- 移除非空约束ALTER TABLE user MODIFY age INT; 外键约束123456789101112131415161718-- 班级CREATE TABLE classes ( id INT PRIMARY KEY, name VARCHAR(20));-- 学生表CREATE TABLE students ( id INT PRIMARY KEY, name VARCHAR(20), -- 这里的 class_id 要和 classes 中的 id 字段相关联 class_id INT, -- 表示 class_id 的值必须来自于 classes 中的 id 字段值 FOREIGN KEY(class_id) REFERENCES classes(id));-- 1. 主表（父表）classes 中没有的数据值，在副表（子表）students 中，是不可以使用的；-- 2. 主表中的记录被副表引用时，主表不可以被删除。 数据库的三大设计范式1NF只要字段值还可以继续拆分，就不满足第一范式。 范式设计得越详细，对某些实际操作可能会更好，但并非都有好处，需要对项目的实际情况进行设定。 2NF在满足第一范式的前提下，其他列都必须完全依赖于主键列。如果出现不完全依赖，只可能发生在联合主键的情况下： 12345678-- 订单表CREATE TABLE myorder ( product_id INT, customer_id INT, product_name VARCHAR(20), customer_name VARCHAR(20), PRIMARY KEY (product_id, customer_id)); 实际上，在这张订单表中，product_name 只依赖于 product_id ，customer_name 只依赖于 customer_id 。也就是说，product_name 和 customer_id 是没用关系的，customer_name 和 product_id 也是没有关系的。 这就不满足第二范式：其他列都必须完全依赖于主键列！ 123456789101112131415CREATE TABLE myorder ( order_id INT PRIMARY KEY, product_id INT, customer_id INT);CREATE TABLE product ( id INT PRIMARY KEY, name VARCHAR(20));CREATE TABLE customer ( id INT PRIMARY KEY, name VARCHAR(20)); 拆分之后，myorder 表中的 product_id 和 customer_id 完全依赖于 order_id 主键，而 product 和 customer 表中的其他字段又完全依赖于主键。满足了第二范式的设计！ 3NF在满足第二范式的前提下，除了主键列之外，其他列之间不能有传递依赖关系。 123456CREATE TABLE myorder ( order_id INT PRIMARY KEY, product_id INT, customer_id INT, customer_phone VARCHAR(15)); 表中的 customer_phone 有可能依赖于 order_id 、 customer_id 两列，也就不满足了第三范式的设计：其他列之间不能有传递依赖关系。 1234567891011CREATE TABLE myorder ( order_id INT PRIMARY KEY, product_id INT, customer_id INT);CREATE TABLE customer ( id INT PRIMARY KEY, name VARCHAR(20), phone VARCHAR(15)); 修改后就不存在其他列之间的传递依赖关系，其他列都只依赖于主键列，满足了第三范式的设计！ 查询练习准备数据123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687-- 创建数据库CREATE DATABASE select_test;-- 切换数据库USE select_test;-- 创建学生表CREATE TABLE student ( no VARCHAR(20) PRIMARY KEY, name VARCHAR(20) NOT NULL, sex VARCHAR(10) NOT NULL, birthday DATE, -- 生日 class VARCHAR(20) -- 所在班级);-- 创建教师表CREATE TABLE teacher ( no VARCHAR(20) PRIMARY KEY, name VARCHAR(20) NOT NULL, sex VARCHAR(10) NOT NULL, birthday DATE, profession VARCHAR(20) NOT NULL, -- 职称 department VARCHAR(20) NOT NULL -- 部门);-- 创建课程表CREATE TABLE course ( no VARCHAR(20) PRIMARY KEY, name VARCHAR(20) NOT NULL, t_no VARCHAR(20) NOT NULL, -- 教师编号 -- 表示该 tno 来自于 teacher 表中的 no 字段值 FOREIGN KEY(t_no) REFERENCES teacher(no) );-- 成绩表CREATE TABLE score ( s_no VARCHAR(20) NOT NULL, -- 学生编号 c_no VARCHAR(20) NOT NULL, -- 课程号 degree DECIMAL, -- 成绩 -- 表示该 s_no, c_no 分别来自于 student, course 表中的 no 字段值 FOREIGN KEY(s_no) REFERENCES student(no), FOREIGN KEY(c_no) REFERENCES course(no), -- 设置 s_no, c_no 为联合主键 PRIMARY KEY(s_no, c_no));-- 查看所有表SHOW TABLES;-- 添加学生表数据INSERT INTO student VALUES(&#39;101&#39;, &#39;曾华&#39;, &#39;男&#39;, &#39;1977-09-01&#39;, &#39;95033&#39;);INSERT INTO student VALUES(&#39;102&#39;, &#39;匡明&#39;, &#39;男&#39;, &#39;1975-10-02&#39;, &#39;95031&#39;);INSERT INTO student VALUES(&#39;103&#39;, &#39;王丽&#39;, &#39;女&#39;, &#39;1976-01-23&#39;, &#39;95033&#39;);INSERT INTO student VALUES(&#39;104&#39;, &#39;李军&#39;, &#39;男&#39;, &#39;1976-02-20&#39;, &#39;95033&#39;);INSERT INTO student VALUES(&#39;105&#39;, &#39;王芳&#39;, &#39;女&#39;, &#39;1975-02-10&#39;, &#39;95031&#39;);INSERT INTO student VALUES(&#39;106&#39;, &#39;陆军&#39;, &#39;男&#39;, &#39;1974-06-03&#39;, &#39;95031&#39;);INSERT INTO student VALUES(&#39;107&#39;, &#39;王尼玛&#39;, &#39;男&#39;, &#39;1976-02-20&#39;, &#39;95033&#39;);INSERT INTO student VALUES(&#39;108&#39;, &#39;张全蛋&#39;, &#39;男&#39;, &#39;1975-02-10&#39;, &#39;95031&#39;);INSERT INTO student VALUES(&#39;109&#39;, &#39;赵铁柱&#39;, &#39;男&#39;, &#39;1974-06-03&#39;, &#39;95031&#39;);-- 添加教师表数据INSERT INTO teacher VALUES(&#39;804&#39;, &#39;李诚&#39;, &#39;男&#39;, &#39;1958-12-02&#39;, &#39;副教授&#39;, &#39;计算机系&#39;);INSERT INTO teacher VALUES(&#39;856&#39;, &#39;张旭&#39;, &#39;男&#39;, &#39;1969-03-12&#39;, &#39;讲师&#39;, &#39;电子工程系&#39;);INSERT INTO teacher VALUES(&#39;825&#39;, &#39;王萍&#39;, &#39;女&#39;, &#39;1972-05-05&#39;, &#39;助教&#39;, &#39;计算机系&#39;);INSERT INTO teacher VALUES(&#39;831&#39;, &#39;刘冰&#39;, &#39;女&#39;, &#39;1977-08-14&#39;, &#39;助教&#39;, &#39;电子工程系&#39;);-- 添加课程表数据INSERT INTO course VALUES(&#39;3-105&#39;, &#39;计算机导论&#39;, &#39;825&#39;);INSERT INTO course VALUES(&#39;3-245&#39;, &#39;操作系统&#39;, &#39;804&#39;);INSERT INTO course VALUES(&#39;6-166&#39;, &#39;数字电路&#39;, &#39;856&#39;);INSERT INTO course VALUES(&#39;9-888&#39;, &#39;高等数学&#39;, &#39;831&#39;);-- 添加添加成绩表数据INSERT INTO score VALUES(&#39;103&#39;, &#39;3-105&#39;, &#39;92&#39;);INSERT INTO score VALUES(&#39;103&#39;, &#39;3-245&#39;, &#39;86&#39;);INSERT INTO score VALUES(&#39;103&#39;, &#39;6-166&#39;, &#39;85&#39;);INSERT INTO score VALUES(&#39;105&#39;, &#39;3-105&#39;, &#39;88&#39;);INSERT INTO score VALUES(&#39;105&#39;, &#39;3-245&#39;, &#39;75&#39;);INSERT INTO score VALUES(&#39;105&#39;, &#39;6-166&#39;, &#39;79&#39;);INSERT INTO score VALUES(&#39;109&#39;, &#39;3-105&#39;, &#39;76&#39;);INSERT INTO score VALUES(&#39;109&#39;, &#39;3-245&#39;, &#39;68&#39;);INSERT INTO score VALUES(&#39;109&#39;, &#39;6-166&#39;, &#39;81&#39;);-- 查看表结构SELECT * FROM course;SELECT * FROM score;SELECT * FROM student;SELECT * FROM teacher; 1 到 1012345678910111213141516171819202122232425262728293031323334353637383940414243-- 查询 student 表的所有行SELECT * FROM student;-- 查询 student 表中的 name、sex 和 class 字段的所有行SELECT name, sex, class FROM student;-- 查询 teacher 表中不重复的 department 列-- department: 去重查询SELECT DISTINCT department FROM teacher;-- 查询 score 表中成绩在60-80之间的所有行（区间查询和运算符查询）-- BETWEEN xx AND xx: 查询区间, AND 表示 &quot;并且&quot;SELECT * FROM score WHERE degree BETWEEN 60 AND 80;SELECT * FROM score WHERE degree &gt; 60 AND degree &lt; 80;-- 查询 score 表中成绩为 85, 86 或 88 的行-- IN: 查询规定中的多个值SELECT * FROM score WHERE degree IN (85, 86, 88);-- 查询 student 表中 &#39;95031&#39; 班或性别为 &#39;女&#39; 的所有行-- or: 表示或者关系SELECT * FROM student WHERE class &#x3D; &#39;95031&#39; or sex &#x3D; &#39;女&#39;;-- 以 class 降序的方式查询 student 表的所有行-- DESC: 降序，从高到低-- ASC（默认）: 升序，从低到高SELECT * FROM student ORDER BY class DESC;SELECT * FROM student ORDER BY class ASC;-- 以 c_no 升序、degree 降序查询 score 表的所有行SELECT * FROM score ORDER BY c_no ASC, degree DESC;-- 查询 &quot;95031&quot; 班的学生人数-- COUNT: 统计SELECT COUNT(*) FROM student WHERE class &#x3D; &#39;95031&#39;;-- 查询 score 表中的最高分的学生学号和课程编号（子查询或排序查询）。-- (SELECT MAX(degree) FROM score): 子查询，算出最高分SELECT s_no, c_no FROM score WHERE degree &#x3D; (SELECT MAX(degree) FROM score);-- 排序查询-- LIMIT r, n: 表示从第r行开始，查询n条数据SELECT s_no, c_no, degree FROM score ORDER BY degree DESC LIMIT 0, 1; 分组计算平均成绩查询每门课的平均成绩。 1234567-- AVG: 平均值SELECT AVG(degree) FROM score WHERE c_no &#x3D; &#39;3-105&#39;;SELECT AVG(degree) FROM score WHERE c_no &#x3D; &#39;3-245&#39;;SELECT AVG(degree) FROM score WHERE c_no &#x3D; &#39;6-166&#39;;-- GROUP BY: 分组查询SELECT c_no, AVG(degree) FROM score GROUP BY c_no; 分组条件与模糊查询查询 score 表中至少有 2 名学生选修，并以 3 开头的课程的平均分数。 123456789101112131415SELECT * FROM score;-- c_no 课程编号+------+-------+--------+| s_no | c_no | degree |+------+-------+--------+| 103 | 3-105 | 92 || 103 | 3-245 | 86 || 103 | 6-166 | 85 || 105 | 3-105 | 88 || 105 | 3-245 | 75 || 105 | 6-166 | 79 || 109 | 3-105 | 76 || 109 | 3-245 | 68 || 109 | 6-166 | 81 |+------+-------+--------+ 分析表发现，至少有 2 名学生选修的课程是 3-105 、3-245 、6-166 ，以 3 开头的课程是 3-105 、3-245 。也就是说，我们要查询所有 3-105 和 3-245 的 degree 平均分。 12345678910111213141516171819202122232425262728-- 首先把 c_no, AVG(degree) 通过分组查询出来SELECT c_no, AVG(degree) FROM score GROUP BY c_no+-------+-------------+| c_no | AVG(degree) |+-------+-------------+| 3-105 | 85.3333 || 3-245 | 76.3333 || 6-166 | 81.6667 |+-------+-------------+-- 再查询出至少有 2 名学生选修的课程-- HAVING: 表示持有HAVING COUNT(c_no) &gt;&#x3D; 2-- 并且是以 3 开头的课程-- LIKE 表示模糊查询，&quot;%&quot; 是一个通配符，匹配 &quot;3&quot; 后面的任意字符。AND c_no LIKE &#39;3%&#39;;-- 把前面的SQL语句拼接起来，-- 后面加上一个 COUNT(*)，表示将每个分组的个数也查询出来。SELECT c_no, AVG(degree), COUNT(*) FROM score GROUP BY c_noHAVING COUNT(c_no) &gt;&#x3D; 2 AND c_no LIKE &#39;3%&#39;;+-------+-------------+----------+| c_no | AVG(degree) | COUNT(*) |+-------+-------------+----------+| 3-105 | 85.3333 | 3 || 3-245 | 76.3333 | 3 |+-------+-------------+----------+ 多表查询 - 1查询所有学生的 name，以及该学生在 score 表中对应的 c_no 和 degree 。 1234567891011121314151617181920212223242526272829SELECT no, name FROM student;+-----+-----------+| no | name |+-----+-----------+| 101 | 曾华 || 102 | 匡明 || 103 | 王丽 || 104 | 李军 || 105 | 王芳 || 106 | 陆军 || 107 | 王尼玛 || 108 | 张全蛋 || 109 | 赵铁柱 |+-----+-----------+SELECT s_no, c_no, degree FROM score;+------+-------+--------+| s_no | c_no | degree |+------+-------+--------+| 103 | 3-105 | 92 || 103 | 3-245 | 86 || 103 | 6-166 | 85 || 105 | 3-105 | 88 || 105 | 3-245 | 75 || 105 | 6-166 | 79 || 109 | 3-105 | 76 || 109 | 3-245 | 68 || 109 | 6-166 | 81 |+------+-------+--------+ 通过分析可以发现，只要把 score 表中的 s_no 字段值替换成 student 表中对应的 name 字段值就可以了，如何做呢？ 1234567891011121314151617-- FROM...: 表示从 student, score 表中查询-- WHERE 的条件表示为，只有在 student.no 和 score.s_no 相等时才显示出来。SELECT name, c_no, degree FROM student, score WHERE student.no &#x3D; score.s_no;+-----------+-------+--------+| name | c_no | degree |+-----------+-------+--------+| 王丽 | 3-105 | 92 || 王丽 | 3-245 | 86 || 王丽 | 6-166 | 85 || 王芳 | 3-105 | 88 || 王芳 | 3-245 | 75 || 王芳 | 6-166 | 79 || 赵铁柱 | 3-105 | 76 || 赵铁柱 | 3-245 | 68 || 赵铁柱 | 6-166 | 81 |+-----------+-------+--------+ 多表查询 - 2查询所有学生的 no 、课程名称 ( course 表中的 name ) 和成绩 ( score 表中的 degree ) 列。 只有 score 关联学生的 no ，因此只要查询 score 表，就能找出所有和学生相关的 no 和 degree ： 1234567891011121314SELECT s_no, c_no, degree FROM score;+------+-------+--------+| s_no | c_no | degree |+------+-------+--------+| 103 | 3-105 | 92 || 103 | 3-245 | 86 || 103 | 6-166 | 85 || 105 | 3-105 | 88 || 105 | 3-245 | 75 || 105 | 6-166 | 79 || 109 | 3-105 | 76 || 109 | 3-245 | 68 || 109 | 6-166 | 81 |+------+-------+--------+ 然后查询 course 表： 12345678+-------+-----------------+| no | name |+-------+-----------------+| 3-105 | 计算机导论 || 3-245 | 操作系统 || 6-166 | 数字电路 || 9-888 | 高等数学 |+-------+-----------------+ 只要把 score 表中的 c_no 替换成 course 表中对应的 name 字段值就可以了。 1234567891011121314151617-- 增加一个查询字段 name，分别从 score、course 这两个表中查询。-- as 表示取一个该字段的别名。SELECT s_no, name as c_name, degree FROM score, courseWHERE score.c_no &#x3D; course.no;+------+-----------------+--------+| s_no | c_name | degree |+------+-----------------+--------+| 103 | 计算机导论 | 92 || 105 | 计算机导论 | 88 || 109 | 计算机导论 | 76 || 103 | 操作系统 | 86 || 105 | 操作系统 | 75 || 109 | 操作系统 | 68 || 103 | 数字电路 | 85 || 105 | 数字电路 | 79 || 109 | 数字电路 | 81 |+------+-----------------+--------+ 三表关联查询查询所有学生的 name 、课程名 ( course 表中的 name ) 和 degree 。 只有 score 表中关联学生的学号和课堂号，我们只要围绕着 score 这张表查询就好了。 1234567891011121314SELECT * FROM score;+------+-------+--------+| s_no | c_no | degree |+------+-------+--------+| 103 | 3-105 | 92 || 103 | 3-245 | 86 || 103 | 6-166 | 85 || 105 | 3-105 | 88 || 105 | 3-245 | 75 || 105 | 6-166 | 79 || 109 | 3-105 | 76 || 109 | 3-245 | 68 || 109 | 6-166 | 81 |+------+-------+--------+ 只要把 s_no 和 c_no 替换成 student 和 srouse 表中对应的 name 字段值就好了。 首先把 s_no 替换成 student 表中的 name 字段： 1234567891011121314SELECT name, c_no, degree FROM student, score WHERE student.no &#x3D; score.s_no;+-----------+-------+--------+| name | c_no | degree |+-----------+-------+--------+| 王丽 | 3-105 | 92 || 王丽 | 3-245 | 86 || 王丽 | 6-166 | 85 || 王芳 | 3-105 | 88 || 王芳 | 3-245 | 75 || 王芳 | 6-166 | 79 || 赵铁柱 | 3-105 | 76 || 赵铁柱 | 3-245 | 68 || 赵铁柱 | 6-166 | 81 |+-----------+-------+--------+ 再把 c_no 替换成 course 表中的 name 字段： 12345678910111213141516-- 课程表SELECT no, name FROM course;+-------+-----------------+| no | name |+-------+-----------------+| 3-105 | 计算机导论 || 3-245 | 操作系统 || 6-166 | 数字电路 || 9-888 | 高等数学 |+-------+-----------------+-- 由于字段名存在重复，使用 &quot;表名.字段名 as 别名&quot; 代替。SELECT student.name as s_name, course.name as c_name, degree FROM student, score, courseWHERE student.NO &#x3D; score.s_noAND score.c_no &#x3D; course.no; 子查询加分组求平均分查询 95031 班学生每门课程的平均成绩。 在 score 表中根据 student 表的学生编号筛选出学生的课堂号和成绩： 12345678910111213-- IN (..): 将筛选出的学生号当做 s_no 的条件查询SELECT s_no, c_no, degree FROM scoreWHERE s_no IN (SELECT no FROM student WHERE class &#x3D; &#39;95031&#39;);+------+-------+--------+| s_no | c_no | degree |+------+-------+--------+| 105 | 3-105 | 88 || 105 | 3-245 | 75 || 105 | 6-166 | 79 || 109 | 3-105 | 76 || 109 | 3-245 | 68 || 109 | 6-166 | 81 |+------+-------+--------+ 这时只要将 c_no 分组一下就能得出 95031 班学生每门课的平均成绩： 12345678910SELECT c_no, AVG(degree) FROM scoreWHERE s_no IN (SELECT no FROM student WHERE class &#x3D; &#39;95031&#39;)GROUP BY c_no;+-------+-------------+| c_no | AVG(degree) |+-------+-------------+| 3-105 | 82.0000 || 3-245 | 71.5000 || 6-166 | 80.0000 |+-------+-------------+ 子查询 - 1查询在 3-105 课程中，所有成绩高于 109 号同学的记录。 首先筛选出课堂号为 3-105 ，在找出所有成绩高于 109 号同学的的行。 123SELECT * FROM score WHERE c_no &#x3D; &#39;3-105&#39;AND degree &gt; (SELECT degree FROM score WHERE s_no &#x3D; &#39;109&#39; AND c_no &#x3D; &#39;3-105&#39;); 子查询 - 2查询所有成绩高于 109 号同学的 3-105 课程成绩记录。 123-- 不限制课程号，只要成绩大于109号同学的3-105课程成绩就可以。SELECT * FROM scoreWHERE degree &gt; (SELECT degree FROM score WHERE s_no &#x3D; &#39;109&#39; AND c_no &#x3D; &#39;3-105&#39;); YEAR 函数与带 IN 关键字查询查询所有和 101 、108 号学生同年出生的 no 、name 、birthday 列。 123-- YEAR(..): 取出日期中的年份SELECT no, name, birthday FROM studentWHERE YEAR(birthday) IN (SELECT YEAR(birthday) FROM student WHERE no IN (101, 108)); 多层嵌套子查询查询 &#39;张旭&#39; 教师任课的学生成绩表。 首先找到教师编号： 1SELECT NO FROM teacher WHERE NAME &#x3D; &#39;张旭&#39; 通过 sourse 表找到该教师课程号： 1SELECT NO FROM course WHERE t_no &#x3D; ( SELECT NO FROM teacher WHERE NAME &#x3D; &#39;张旭&#39; ); 通过筛选出的课程号查询成绩表： 12345SELECT * FROM score WHERE c_no &#x3D; ( SELECT no FROM course WHERE t_no &#x3D; ( SELECT no FROM teacher WHERE NAME &#x3D; &#39;张旭&#39; )); 多表查询查询某选修课程多于5个同学的教师姓名。 首先在 teacher 表中，根据 no 字段来判断该教师的同一门课程是否有至少5名学员选修： 1234567891011121314-- 查询 teacher 表SELECT no, name FROM teacher;+-----+--------+| no | name |+-----+--------+| 804 | 李诚 || 825 | 王萍 || 831 | 刘冰 || 856 | 张旭 |+-----+--------+SELECT name FROM teacher WHERE no IN ( -- 在这里找到对应的条件); 查看和教师编号有有关的表的信息： 12345678910SELECT * FROM course;-- t_no: 教师编号+-------+-----------------+------+| no | name | t_no |+-------+-----------------+------+| 3-105 | 计算机导论 | 825 || 3-245 | 操作系统 | 804 || 6-166 | 数字电路 | 856 || 9-888 | 高等数学 | 831 |+-------+-----------------+------+ 我们已经找到和教师编号有关的字段就在 course 表中，但是还无法知道哪门课程至少有5名学生选修，所以还需要根据 score 表来查询： 12345678910111213141516171819202122232425262728293031-- 在此之前向 score 插入一些数据，以便丰富查询条件。INSERT INTO score VALUES (&#39;101&#39;, &#39;3-105&#39;, &#39;90&#39;);INSERT INTO score VALUES (&#39;102&#39;, &#39;3-105&#39;, &#39;91&#39;);INSERT INTO score VALUES (&#39;104&#39;, &#39;3-105&#39;, &#39;89&#39;);-- 查询 score 表SELECT * FROM score;+------+-------+--------+| s_no | c_no | degree |+------+-------+--------+| 101 | 3-105 | 90 || 102 | 3-105 | 91 || 103 | 3-105 | 92 || 103 | 3-245 | 86 || 103 | 6-166 | 85 || 104 | 3-105 | 89 || 105 | 3-105 | 88 || 105 | 3-245 | 75 || 105 | 6-166 | 79 || 109 | 3-105 | 76 || 109 | 3-245 | 68 || 109 | 6-166 | 81 |+------+-------+--------+-- 在 score 表中将 c_no 作为分组，并且限制 c_no 持有至少 5 条数据。SELECT c_no FROM score GROUP BY c_no HAVING COUNT(*) &gt; 5;+-------+| c_no |+-------+| 3-105 |+-------+ 根据筛选出来的课程号，找出在某课程中，拥有至少5名学员的教师编号： 12345678SELECT t_no FROM course WHERE no IN ( SELECT c_no FROM score GROUP BY c_no HAVING COUNT(*) &gt; 5);+------+| t_no |+------+| 825 |+------+ 在 teacher 表中，根据筛选出来的教师编号找到教师姓名： 123456SELECT name FROM teacher WHERE no IN ( -- 最终条件 SELECT t_no FROM course WHERE no IN ( SELECT c_no FROM score GROUP BY c_no HAVING COUNT(*) &gt; 5 )); 子查询 - 3查询 “计算机系” 课程的成绩表。 思路是，先找出 course 表中所有 计算机系 课程的编号，然后根据这个编号查询 score 表。 123456789101112131415161718192021222324252627282930313233343536373839-- 通过 teacher 表查询所有 &#96;计算机系&#96; 的教师编号SELECT no, name, department FROM teacher WHERE department &#x3D; &#39;计算机系&#39;+-----+--------+--------------+| no | name | department |+-----+--------+--------------+| 804 | 李诚 | 计算机系 || 825 | 王萍 | 计算机系 |+-----+--------+--------------+-- 通过 course 表查询该教师的课程编号SELECT no FROM course WHERE t_no IN ( SELECT no FROM teacher WHERE department &#x3D; &#39;计算机系&#39;);+-------+| no |+-------+| 3-245 || 3-105 |+-------+-- 根据筛选出来的课程号查询成绩表SELECT * FROM score WHERE c_no IN ( SELECT no FROM course WHERE t_no IN ( SELECT no FROM teacher WHERE department &#x3D; &#39;计算机系&#39; ));+------+-------+--------+| s_no | c_no | degree |+------+-------+--------+| 103 | 3-245 | 86 || 105 | 3-245 | 75 || 109 | 3-245 | 68 || 101 | 3-105 | 90 || 102 | 3-105 | 91 || 103 | 3-105 | 92 || 104 | 3-105 | 89 || 105 | 3-105 | 88 || 109 | 3-105 | 76 |+------+-------+--------+ UNION 和 NOTIN 的使用查询 计算机系 与 电子工程系 中的不同职称的教师。 123456789-- NOT: 代表逻辑非SELECT * FROM teacher WHERE department &#x3D; &#39;计算机系&#39; AND profession NOT IN ( SELECT profession FROM teacher WHERE department &#x3D; &#39;电子工程系&#39;)-- 合并两个集UNIONSELECT * FROM teacher WHERE department &#x3D; &#39;电子工程系&#39; AND profession NOT IN ( SELECT profession FROM teacher WHERE department &#x3D; &#39;计算机系&#39;); ANY 表示至少一个 - DESC ( 降序 )查询课程 3-105 且成绩 至少 高于 3-245 的 score 表。 12345678910111213141516171819202122232425262728293031323334353637SELECT * FROM score WHERE c_no &#x3D; &#39;3-105&#39;;+------+-------+--------+| s_no | c_no | degree |+------+-------+--------+| 101 | 3-105 | 90 || 102 | 3-105 | 91 || 103 | 3-105 | 92 || 104 | 3-105 | 89 || 105 | 3-105 | 88 || 109 | 3-105 | 76 |+------+-------+--------+SELECT * FROM score WHERE c_no &#x3D; &#39;3-245&#39;;+------+-------+--------+| s_no | c_no | degree |+------+-------+--------+| 103 | 3-245 | 86 || 105 | 3-245 | 75 || 109 | 3-245 | 68 |+------+-------+--------+-- ANY: 符合SQL语句中的任意条件。-- 也就是说，在 3-105 成绩中，只要有一个大于从 3-245 筛选出来的任意行就符合条件，-- 最后根据降序查询结果。SELECT * FROM score WHERE c_no &#x3D; &#39;3-105&#39; AND degree &gt; ANY( SELECT degree FROM score WHERE c_no &#x3D; &#39;3-245&#39;) ORDER BY degree DESC;+------+-------+--------+| s_no | c_no | degree |+------+-------+--------+| 103 | 3-105 | 92 || 102 | 3-105 | 91 || 101 | 3-105 | 90 || 104 | 3-105 | 89 || 105 | 3-105 | 88 || 109 | 3-105 | 76 |+------+-------+--------+ 表示所有的 ALL查询课程 3-105 且成绩高于 3-245 的 score 表。 123456789101112131415-- 只需对上一道题稍作修改。-- ALL: 符合SQL语句中的所有条件。-- 也就是说，在 3-105 每一行成绩中，都要大于从 3-245 筛选出来全部行才算符合条件。SELECT * FROM score WHERE c_no &#x3D; &#39;3-105&#39; AND degree &gt; ALL( SELECT degree FROM score WHERE c_no &#x3D; &#39;3-245&#39;);+------+-------+--------+| s_no | c_no | degree |+------+-------+--------+| 101 | 3-105 | 90 || 102 | 3-105 | 91 || 103 | 3-105 | 92 || 104 | 3-105 | 89 || 105 | 3-105 | 88 |+------+-------+--------+ 复制表的数据作为条件查询查询某课程成绩比该课程平均成绩低的 score 表。 1234567891011121314151617181920212223242526272829303132333435363738394041424344-- 查询平均分SELECT c_no, AVG(degree) FROM score GROUP BY c_no;+-------+-------------+| c_no | AVG(degree) |+-------+-------------+| 3-105 | 87.6667 || 3-245 | 76.3333 || 6-166 | 81.6667 |+-------+-------------+-- 查询 score 表SELECT degree FROM score;+--------+| degree |+--------+| 90 || 91 || 92 || 86 || 85 || 89 || 88 || 75 || 79 || 76 || 68 || 81 |+--------+-- 将表 b 作用于表 a 中查询数据-- score a (b): 将表声明为 a (b)，-- 如此就能用 a.c_no &#x3D; b.c_no 作为条件执行查询了。SELECT * FROM score a WHERE degree &lt; ( (SELECT AVG(degree) FROM score b WHERE a.c_no &#x3D; b.c_no));+------+-------+--------+| s_no | c_no | degree |+------+-------+--------+| 105 | 3-245 | 75 || 105 | 6-166 | 79 || 109 | 3-105 | 76 || 109 | 3-245 | 68 || 109 | 6-166 | 81 |+------+-------+--------+ 子查询 - 4查询所有任课 ( 在 course 表里有课程 ) 教师的 name 和 department 。 123456789SELECT name, department FROM teacher WHERE no IN (SELECT t_no FROM course);+--------+-----------------+| name | department |+--------+-----------------+| 李诚 | 计算机系 || 王萍 | 计算机系 || 刘冰 | 电子工程系 || 张旭 | 电子工程系 |+--------+-----------------+ 条件加组筛选查询 student 表中至少有 2 名男生的 class 。 12345678910111213141516171819202122232425-- 查看学生表信息SELECT * FROM student;+-----+-----------+-----+------------+-------+| no | name | sex | birthday | class |+-----+-----------+-----+------------+-------+| 101 | 曾华 | 男 | 1977-09-01 | 95033 || 102 | 匡明 | 男 | 1975-10-02 | 95031 || 103 | 王丽 | 女 | 1976-01-23 | 95033 || 104 | 李军 | 男 | 1976-02-20 | 95033 || 105 | 王芳 | 女 | 1975-02-10 | 95031 || 106 | 陆军 | 男 | 1974-06-03 | 95031 || 107 | 王尼玛 | 男 | 1976-02-20 | 95033 || 108 | 张全蛋 | 男 | 1975-02-10 | 95031 || 109 | 赵铁柱 | 男 | 1974-06-03 | 95031 || 110 | 张飞 | 男 | 1974-06-03 | 95038 |+-----+-----------+-----+------------+-------+-- 只查询性别为男，然后按 class 分组，并限制 class 行大于 1。SELECT class FROM student WHERE sex &#x3D; &#39;男&#39; GROUP BY class HAVING COUNT(*) &gt; 1;+-------+| class |+-------+| 95033 || 95031 |+-------+ NOTLIKE 模糊查询取反查询 student 表中不姓 “王” 的同学记录。 1234567891011121314-- NOT: 取反-- LIKE: 模糊查询mysql&gt; SELECT * FROM student WHERE name NOT LIKE &#39;王%&#39;;+-----+-----------+-----+------------+-------+| no | name | sex | birthday | class |+-----+-----------+-----+------------+-------+| 101 | 曾华 | 男 | 1977-09-01 | 95033 || 102 | 匡明 | 男 | 1975-10-02 | 95031 || 104 | 李军 | 男 | 1976-02-20 | 95033 || 106 | 陆军 | 男 | 1974-06-03 | 95031 || 108 | 张全蛋 | 男 | 1975-02-10 | 95031 || 109 | 赵铁柱 | 男 | 1974-06-03 | 95031 || 110 | 张飞 | 男 | 1974-06-03 | 95038 |+-----+-----------+-----+------------+-------+ YEAR 与 NOW 函数查询 student 表中每个学生的姓名和年龄。 12345678910111213141516-- 使用函数 YEAR(NOW()) 计算出当前年份，减去出生年份后得出年龄。SELECT name, YEAR(NOW()) - YEAR(birthday) as age FROM student;+-----------+------+| name | age |+-----------+------+| 曾华 | 42 || 匡明 | 44 || 王丽 | 43 || 李军 | 43 || 王芳 | 44 || 陆军 | 45 || 王尼玛 | 43 || 张全蛋 | 44 || 赵铁柱 | 45 || 张飞 | 45 |+-----------+------+ MAX 与 MIN 函数查询 student 表中最大和最小的 birthday 值。 123456SELECT MAX(birthday), MIN(birthday) FROM student;+---------------+---------------+| MAX(birthday) | MIN(birthday) |+---------------+---------------+| 1977-09-01 | 1974-06-03 |+---------------+---------------+ 多段排序以 class 和 birthday 从大到小的顺序查询 student 表。 123456789101112131415SELECT * FROM student ORDER BY class DESC, birthday;+-----+-----------+-----+------------+-------+| no | name | sex | birthday | class |+-----+-----------+-----+------------+-------+| 110 | 张飞 | 男 | 1974-06-03 | 95038 || 103 | 王丽 | 女 | 1976-01-23 | 95033 || 104 | 李军 | 男 | 1976-02-20 | 95033 || 107 | 王尼玛 | 男 | 1976-02-20 | 95033 || 101 | 曾华 | 男 | 1977-09-01 | 95033 || 106 | 陆军 | 男 | 1974-06-03 | 95031 || 109 | 赵铁柱 | 男 | 1974-06-03 | 95031 || 105 | 王芳 | 女 | 1975-02-10 | 95031 || 108 | 张全蛋 | 男 | 1975-02-10 | 95031 || 102 | 匡明 | 男 | 1975-10-02 | 95031 |+-----+-----------+-----+------------+-------+ 子查询 - 5查询 “男” 教师及其所上的课程。 1234567SELECT * FROM course WHERE t_no in (SELECT no FROM teacher WHERE sex &#x3D; &#39;男&#39;);+-------+--------------+------+| no | name | t_no |+-------+--------------+------+| 3-245 | 操作系统 | 804 || 6-166 | 数字电路 | 856 |+-------+--------------+------+ MAX 函数与子查询查询最高分同学的 score 表。 1234567891011-- 找出最高成绩（该查询只能有一个结果）SELECT MAX(degree) FROM score;-- 根据上面的条件筛选出所有最高成绩表，-- 该查询可能有多个结果，假设 degree 值多次符合条件。SELECT * FROM score WHERE degree &#x3D; (SELECT MAX(degree) FROM score);+------+-------+--------+| s_no | c_no | degree |+------+-------+--------+| 103 | 3-105 | 92 |+------+-------+--------+ 子查询 - 6查询和 “李军” 同性别的所有同学 name 。 123456789101112131415161718192021222324-- 首先将李军的性别作为条件取出来SELECT sex FROM student WHERE name &#x3D; &#39;李军&#39;;+-----+| sex |+-----+| 男 |+-----+-- 根据性别查询 name 和 sexSELECT name, sex FROM student WHERE sex &#x3D; ( SELECT sex FROM student WHERE name &#x3D; &#39;李军&#39;);+-----------+-----+| name | sex |+-----------+-----+| 曾华 | 男 || 匡明 | 男 || 李军 | 男 || 陆军 | 男 || 王尼玛 | 男 || 张全蛋 | 男 || 赵铁柱 | 男 || 张飞 | 男 |+-----------+-----+ 子查询 - 7查询和 “李军” 同性别且同班的同学 name 。 123456789101112SELECT name, sex, class FROM student WHERE sex &#x3D; ( SELECT sex FROM student WHERE name &#x3D; &#39;李军&#39;) AND class &#x3D; ( SELECT class FROM student WHERE name &#x3D; &#39;李军&#39;);+-----------+-----+-------+| name | sex | class |+-----------+-----+-------+| 曾华 | 男 | 95033 || 李军 | 男 | 95033 || 王尼玛 | 男 | 95033 |+-----------+-----+-------+ 子查询 - 8查询所有选修 “计算机导论” 课程的 “男” 同学成绩表。 需要的 “计算机导论” 和性别为 “男” 的编号可以在 course 和 student 表中找到。 12345678910111213SELECT * FROM score WHERE c_no &#x3D; ( SELECT no FROM course WHERE name &#x3D; &#39;计算机导论&#39;) AND s_no IN ( SELECT no FROM student WHERE sex &#x3D; &#39;男&#39;);+------+-------+--------+| s_no | c_no | degree |+------+-------+--------+| 101 | 3-105 | 90 || 102 | 3-105 | 91 || 104 | 3-105 | 89 || 109 | 3-105 | 76 |+------+-------+--------+ 按等级查询建立一个 grade 表代表学生的成绩等级，并插入数据： 12345678910111213141516171819202122CREATE TABLE grade ( low INT(3), upp INT(3), grade char(1));INSERT INTO grade VALUES (90, 100, &#39;A&#39;);INSERT INTO grade VALUES (80, 89, &#39;B&#39;);INSERT INTO grade VALUES (70, 79, &#39;C&#39;);INSERT INTO grade VALUES (60, 69, &#39;D&#39;);INSERT INTO grade VALUES (0, 59, &#39;E&#39;);SELECT * FROM grade;+------+------+-------+| low | upp | grade |+------+------+-------+| 90 | 100 | A || 80 | 89 | B || 70 | 79 | C || 60 | 69 | D || 0 | 59 | E |+------+------+-------+ 查询所有学生的 s_no 、c_no 和 grade 列。 思路是，使用区间 ( BETWEEN ) 查询，判断学生的成绩 ( degree ) 在 grade 表的 low 和 upp 之间。 123456789101112131415161718SELECT s_no, c_no, grade FROM score, grade WHERE degree BETWEEN low AND upp;+------+-------+-------+| s_no | c_no | grade |+------+-------+-------+| 101 | 3-105 | A || 102 | 3-105 | A || 103 | 3-105 | A || 103 | 3-245 | B || 103 | 6-166 | B || 104 | 3-105 | B || 105 | 3-105 | B || 105 | 3-245 | C || 105 | 6-166 | C || 109 | 3-105 | C || 109 | 3-245 | D || 109 | 6-166 | B |+------+-------+-------+ 连接查询准备用于测试连接查询的数据： 12345678910111213141516171819202122232425262728293031323334CREATE DATABASE testJoin;CREATE TABLE person ( id INT, name VARCHAR(20), cardId INT);CREATE TABLE card ( id INT, name VARCHAR(20));INSERT INTO card VALUES (1, &#39;饭卡&#39;), (2, &#39;建行卡&#39;), (3, &#39;农行卡&#39;), (4, &#39;工商卡&#39;), (5, &#39;邮政卡&#39;);SELECT * FROM card;+------+-----------+| id | name |+------+-----------+| 1 | 饭卡 || 2 | 建行卡 || 3 | 农行卡 || 4 | 工商卡 || 5 | 邮政卡 |+------+-----------+INSERT INTO person VALUES (1, &#39;张三&#39;, 1), (2, &#39;李四&#39;, 3), (3, &#39;王五&#39;, 6);SELECT * FROM person;+------+--------+--------+| id | name | cardId |+------+--------+--------+| 1 | 张三 | 1 || 2 | 李四 | 3 || 3 | 王五 | 6 |+------+--------+--------+ 分析两张表发现，person 表并没有为 cardId 字段设置一个在 card 表中对应的 id 外键。如果设置了的话，person 中 cardId 字段值为 6 的行就插不进去，因为该 cardId 值在 card 表中并没有。 内连接要查询这两张表中有关系的数据，可以使用 INNER JOIN ( 内连接 ) 将它们连接在一起。 123456789101112-- INNER JOIN: 表示为内连接，将两张表拼接在一起。-- on: 表示要执行某个条件。SELECT * FROM person INNER JOIN card on person.cardId &#x3D; card.id;+------+--------+--------+------+-----------+| id | name | cardId | id | name |+------+--------+--------+------+-----------+| 1 | 张三 | 1 | 1 | 饭卡 || 2 | 李四 | 3 | 3 | 农行卡 |+------+--------+--------+------+-----------+-- 将 INNER 关键字省略掉，结果也是一样的。-- SELECT * FROM person JOIN card on person.cardId &#x3D; card.id; 注意：card 的整张表被连接到了右边。 左外连接完整显示左边的表 ( person ) ，右边的表如果符合条件就显示，不符合则补 NULL 。 123456789-- LEFT JOIN 也叫做 LEFT OUTER JOIN，用这两种方式的查询结果是一样的。SELECT * FROM person LEFT JOIN card on person.cardId &#x3D; card.id;+------+--------+--------+------+-----------+| id | name | cardId | id | name |+------+--------+--------+------+-----------+| 1 | 张三 | 1 | 1 | 饭卡 || 2 | 李四 | 3 | 3 | 农行卡 || 3 | 王五 | 6 | NULL | NULL |+------+--------+--------+------+-----------+ 右外链接完整显示右边的表 ( card ) ，左边的表如果符合条件就显示，不符合则补 NULL 。 12345678910SELECT * FROM person RIGHT JOIN card on person.cardId &#x3D; card.id;+------+--------+--------+------+-----------+| id | name | cardId | id | name |+------+--------+--------+------+-----------+| 1 | 张三 | 1 | 1 | 饭卡 || 2 | 李四 | 3 | 3 | 农行卡 || NULL | NULL | NULL | 2 | 建行卡 || NULL | NULL | NULL | 4 | 工商卡 || NULL | NULL | NULL | 5 | 邮政卡 |+------+--------+--------+------+-----------+ 全外链接完整显示两张表的全部数据。 12345678910111213141516171819-- MySQL 不支持这种语法的全外连接-- SELECT * FROM person FULL JOIN card on person.cardId &#x3D; card.id;-- 出现错误：-- ERROR 1054 (42S22): Unknown column &#39;person.cardId&#39; in &#39;on clause&#39;-- MySQL全连接语法，使用 UNION 将两张表合并在一起。SELECT * FROM person LEFT JOIN card on person.cardId &#x3D; card.idUNIONSELECT * FROM person RIGHT JOIN card on person.cardId &#x3D; card.id;+------+--------+--------+------+-----------+| id | name | cardId | id | name |+------+--------+--------+------+-----------+| 1 | 张三 | 1 | 1 | 饭卡 || 2 | 李四 | 3 | 3 | 农行卡 || 3 | 王五 | 6 | NULL | NULL || NULL | NULL | NULL | 2 | 建行卡 || NULL | NULL | NULL | 4 | 工商卡 || NULL | NULL | NULL | 5 | 邮政卡 |+------+--------+--------+------+-----------+ 事务在 MySQL 中，事务其实是一个最小的不可分割的工作单元。事务能够保证一个业务的完整性。 比如我们的银行转账： 12345-- a -&gt; -100UPDATE user set money &#x3D; money - 100 WHERE name &#x3D; &#39;a&#39;;-- b -&gt; +100UPDATE user set money &#x3D; money + 100 WHERE name &#x3D; &#39;b&#39;; 在实际项目中，假设只有一条 SQL 语句执行成功，而另外一条执行失败了，就会出现数据前后不一致。 因此，在执行多条有关联 SQL 语句时，事务可能会要求这些 SQL 语句要么同时执行成功，要么就都执行失败。 如何控制事务 - COMMIT / ROLLBACK在 MySQL 中，事务的自动提交状态默认是开启的。 1234567-- 查询事务的自动提交状态SELECT @@AUTOCOMMIT;+--------------+| @@AUTOCOMMIT |+--------------+| 1 |+--------------+ 自动提交的作用：当我们执行一条 SQL 语句的时候，其产生的效果就会立即体现出来，且不能回滚。 什么是回滚？举个例子： 123456789101112131415161718CREATE DATABASE bank;USE bank;CREATE TABLE user ( id INT PRIMARY KEY, name VARCHAR(20), money INT);INSERT INTO user VALUES (1, &#39;a&#39;, 1000);SELECT * FROM user;+----+------+-------+| id | name | money |+----+------+-------+| 1 | a | 1000 |+----+------+-------+ 可以看到，在执行插入语句后数据立刻生效，原因是 MySQL 中的事务自动将它提交到了数据库中。那么所谓回滚的意思就是，撤销执行过的所有 SQL 语句，使其回滚到最后一次提交数据时的状态。 在 MySQL 中使用 ROLLBACK 执行回滚： 123456789-- 回滚到最后一次提交ROLLBACK;SELECT * FROM user;+----+------+-------+| id | name | money |+----+------+-------+| 1 | a | 1000 |+----+------+-------+ 由于所有执行过的 SQL 语句都已经被提交过了，所以数据并没有发生回滚。那如何让数据可以发生回滚？ 12345678910-- 关闭自动提交SET AUTOCOMMIT &#x3D; 0;-- 查询自动提交状态SELECT @@AUTOCOMMIT;+--------------+| @@AUTOCOMMIT |+--------------+| 0 |+--------------+ 将自动提交关闭后，测试数据回滚： 1234567891011121314151617181920212223242526272829INSERT INTO user VALUES (2, &#39;b&#39;, 1000);-- 关闭 AUTOCOMMIT 后，数据的变化是在一张虚拟的临时数据表中展示，-- 发生变化的数据并没有真正插入到数据表中。SELECT * FROM user;+----+------+-------+| id | name | money |+----+------+-------+| 1 | a | 1000 || 2 | b | 1000 |+----+------+-------+-- 数据表中的真实数据其实还是：+----+------+-------+| id | name | money |+----+------+-------+| 1 | a | 1000 |+----+------+-------+-- 由于数据还没有真正提交，可以使用回滚ROLLBACK;-- 再次查询SELECT * FROM user;+----+------+-------+| id | name | money |+----+------+-------+| 1 | a | 1000 |+----+------+-------+ 那如何将虚拟的数据真正提交到数据库中？使用 COMMIT : 12345678910111213141516INSERT INTO user VALUES (2, &#39;b&#39;, 1000);-- 手动提交数据（持久性），-- 将数据真正提交到数据库中，执行后不能再回滚提交过的数据。COMMIT;-- 提交后测试回滚ROLLBACK;-- 再次查询（回滚无效了）SELECT * FROM user;+----+------+-------+| id | name | money |+----+------+-------+| 1 | a | 1000 || 2 | b | 1000 |+----+------+-------+ 总结 自动提交 查看自动提交状态：SELECT @@AUTOCOMMIT ； 设置自动提交状态：SET AUTOCOMMIT = 0 。 手动提交 @@AUTOCOMMIT = 0 时，使用 COMMIT 命令提交事务。 事务回滚 @@AUTOCOMMIT = 0 时，使用 ROLLBACK 命令回滚事务。 事务的实际应用，让我们再回到银行转账项目： 12345678910111213-- 转账UPDATE user set money &#x3D; money - 100 WHERE name &#x3D; &#39;a&#39;;-- 到账UPDATE user set money &#x3D; money + 100 WHERE name &#x3D; &#39;b&#39;;SELECT * FROM user;+----+------+-------+| id | name | money |+----+------+-------+| 1 | a | 900 || 2 | b | 1100 |+----+------+-------+ 这时假设在转账时发生了意外，就可以使用 ROLLBACK 回滚到最后一次提交的状态： 12345678910-- 假设转账发生了意外，需要回滚。ROLLBACK;SELECT * FROM user;+----+------+-------+| id | name | money |+----+------+-------+| 1 | a | 1000 || 2 | b | 1000 |+----+------+-------+ 这时我们又回到了发生意外之前的状态，也就是说，事务给我们提供了一个可以反悔的机会。假设数据没有发生意外，这时可以手动将数据真正提交到数据表中：COMMIT 。 手动开启事务 - BEGIN / START TRANSACTION事务的默认提交被开启 ( @@AUTOCOMMIT = 1 ) 后，此时就不能使用事务回滚了。但是我们还可以手动开启一个事务处理事件，使其可以发生回滚： 1234567891011121314151617181920212223242526-- 使用 BEGIN 或者 START TRANSACTION 手动开启一个事务-- START TRANSACTION;BEGIN;UPDATE user set money &#x3D; money - 100 WHERE name &#x3D; &#39;a&#39;;UPDATE user set money &#x3D; money + 100 WHERE name &#x3D; &#39;b&#39;;-- 由于手动开启的事务没有开启自动提交，-- 此时发生变化的数据仍然是被保存在一张临时表中。SELECT * FROM user;+----+------+-------+| id | name | money |+----+------+-------+| 1 | a | 900 || 2 | b | 1100 |+----+------+-------+-- 测试回滚ROLLBACK;SELECT * FROM user;+----+------+-------+| id | name | money |+----+------+-------+| 1 | a | 1000 || 2 | b | 1000 |+----+------+-------+ 仍然使用 COMMIT 提交数据，提交后无法再发生本次事务的回滚。 1234567891011121314151617BEGIN;UPDATE user set money &#x3D; money - 100 WHERE name &#x3D; &#39;a&#39;;UPDATE user set money &#x3D; money + 100 WHERE name &#x3D; &#39;b&#39;;SELECT * FROM user;+----+------+-------+| id | name | money |+----+------+-------+| 1 | a | 900 || 2 | b | 1100 |+----+------+-------+-- 提交数据COMMIT;-- 测试回滚（无效，因为表的数据已经被提交）ROLLBACK; 事务的 ACID 特征与使用事务的四大特征： A 原子性：事务是最小的单位，不可以再分割； C 一致性：要求同一事务中的 SQL 语句，必须保证同时成功或者失败； I 隔离性：事务1 和 事务2 之间是具有隔离性的； D 持久性：事务一旦结束 ( COMMIT ) ，就不可以再返回了 ( ROLLBACK ) 。 事务的隔离性事务的隔离性可分为四种 ( 性能从低到高 ) ： READ UNCOMMITTED ( 读取未提交 ) 如果有多个事务，那么任意事务都可以看见其他事务的未提交数据。 READ COMMITTED ( 读取已提交 ) 只能读取到其他事务已经提交的数据。 REPEATABLE READ ( 可被重复读 ) 如果有多个连接都开启了事务，那么事务之间不能共享数据记录，否则只能共享已提交的记录。 SERIALIZABLE ( 串行化 ) 所有的事务都会按照固定顺序执行，执行完一个事务后再继续执行下一个事务的写入操作。 查看当前数据库的默认隔离级别： 123456789101112-- MySQL 8.x, GLOBAL 表示系统级别，不加表示会话级别。SELECT @@GLOBAL.TRANSACTION_ISOLATION;SELECT @@TRANSACTION_ISOLATION;+--------------------------------+| @@GLOBAL.TRANSACTION_ISOLATION |+--------------------------------+| REPEATABLE-READ | -- MySQL的默认隔离级别，可以重复读。+--------------------------------+-- MySQL 5.xSELECT @@GLOBAL.TX_ISOLATION;SELECT @@TX_ISOLATION; 修改隔离级别： 12345678910-- 设置系统隔离级别，LEVEL 后面表示要设置的隔离级别 (READ UNCOMMITTED)。SET GLOBAL TRANSACTION ISOLATION LEVEL READ UNCOMMITTED;-- 查询系统隔离级别，发现已经被修改。SELECT @@GLOBAL.TRANSACTION_ISOLATION;+--------------------------------+| @@GLOBAL.TRANSACTION_ISOLATION |+--------------------------------+| READ-UNCOMMITTED |+--------------------------------+ 脏读测试 READ UNCOMMITTED ( 读取未提交 ) 的隔离性： 1234567891011121314151617181920212223242526272829INSERT INTO user VALUES (3, &#39;小明&#39;, 1000);INSERT INTO user VALUES (4, &#39;淘宝店&#39;, 1000);SELECT * FROM user;+----+-----------+-------+| id | name | money |+----+-----------+-------+| 1 | a | 900 || 2 | b | 1100 || 3 | 小明 | 1000 || 4 | 淘宝店 | 1000 |+----+-----------+-------+-- 开启一个事务操作数据-- 假设小明在淘宝店买了一双800块钱的鞋子：START TRANSACTION;UPDATE user SET money &#x3D; money - 800 WHERE name &#x3D; &#39;小明&#39;;UPDATE user SET money &#x3D; money + 800 WHERE name &#x3D; &#39;淘宝店&#39;;-- 然后淘宝店在另一方查询结果，发现钱已到账。SELECT * FROM user;+----+-----------+-------+| id | name | money |+----+-----------+-------+| 1 | a | 900 || 2 | b | 1100 || 3 | 小明 | 200 || 4 | 淘宝店 | 1800 |+----+-----------+-------+ 由于小明的转账是在新开启的事务上进行操作的，而该操作的结果是可以被其他事务（另一方的淘宝店）看见的，因此淘宝店的查询结果是正确的，淘宝店确认到账。但就在这时，如果小明在它所处的事务上又执行了 ROLLBACK 命令，会发生什么？ 12345678910111213-- 小明所处的事务ROLLBACK;-- 此时无论对方是谁，如果再去查询结果就会发现：SELECT * FROM user;+----+-----------+-------+| id | name | money |+----+-----------+-------+| 1 | a | 900 || 2 | b | 1100 || 3 | 小明 | 1000 || 4 | 淘宝店 | 1000 |+----+-----------+-------+ 这就是所谓的脏读，一个事务读取到另外一个事务还未提交的数据。这在实际开发中是不允许出现的。 读取已提交把隔离级别设置为 READ COMMITTED ： 1234567SET GLOBAL TRANSACTION ISOLATION LEVEL READ COMMITTED;SELECT @@GLOBAL.TRANSACTION_ISOLATION;+--------------------------------+| @@GLOBAL.TRANSACTION_ISOLATION |+--------------------------------+| READ-COMMITTED |+--------------------------------+ 这样，再有新的事务连接进来时，它们就只能查询到已经提交过的事务数据了。但是对于当前事务来说，它们看到的还是未提交的数据，例如： 12345678910111213141516171819202122232425262728293031-- 正在操作数据事务（当前事务）START TRANSACTION;UPDATE user SET money &#x3D; money - 800 WHERE name &#x3D; &#39;小明&#39;;UPDATE user SET money &#x3D; money + 800 WHERE name &#x3D; &#39;淘宝店&#39;;-- 虽然隔离级别被设置为了 READ COMMITTED，但在当前事务中，-- 它看到的仍然是数据表中临时改变数据，而不是真正提交过的数据。SELECT * FROM user;+----+-----------+-------+| id | name | money |+----+-----------+-------+| 1 | a | 900 || 2 | b | 1100 || 3 | 小明 | 200 || 4 | 淘宝店 | 1800 |+----+-----------+-------+-- 假设此时在远程开启了一个新事务，连接到数据库。$ mysql -u root -p12345612-- 此时远程连接查询到的数据只能是已经提交过的SELECT * FROM user;+----+-----------+-------+| id | name | money |+----+-----------+-------+| 1 | a | 900 || 2 | b | 1100 || 3 | 小明 | 1000 || 4 | 淘宝店 | 1000 |+----+-----------+-------+ 但是这样还有问题，那就是假设一个事务在操作数据时，其他事务干扰了这个事务的数据。例如： 1234567891011121314151617181920212223242526272829303132333435-- 小张在查询数据的时候发现：SELECT * FROM user;+----+-----------+-------+| id | name | money |+----+-----------+-------+| 1 | a | 900 || 2 | b | 1100 || 3 | 小明 | 200 || 4 | 淘宝店 | 1800 |+----+-----------+-------+-- 在小张求表的 money 平均值之前，小王做了一个操作：START TRANSACTION;INSERT INTO user VALUES (5, &#39;c&#39;, 100);COMMIT;-- 此时表的真实数据是：SELECT * FROM user;+----+-----------+-------+| id | name | money |+----+-----------+-------+| 1 | a | 900 || 2 | b | 1100 || 3 | 小明 | 1000 || 4 | 淘宝店 | 1000 || 5 | c | 100 |+----+-----------+-------+-- 这时小张再求平均值的时候，就会出现计算不相符合的情况：SELECT AVG(money) FROM user;+------------+| AVG(money) |+------------+| 820.0000 |+------------+ 虽然 READ COMMITTED 让我们只能读取到其他事务已经提交的数据，但还是会出现问题，就是在读取同一个表的数据时，可能会发生前后不一致的情况。这被称为不可重复读现象 ( READ COMMITTED ) 。 幻读将隔离级别设置为 REPEATABLE READ ( 可被重复读取 ) : 1234567SET GLOBAL TRANSACTION ISOLATION LEVEL REPEATABLE READ;SELECT @@GLOBAL.TRANSACTION_ISOLATION;+--------------------------------+| @@GLOBAL.TRANSACTION_ISOLATION |+--------------------------------+| REPEATABLE-READ |+--------------------------------+ 测试 REPEATABLE READ ，假设在两个不同的连接上分别执行 START TRANSACTION : 123456789-- 小张 - 成都START TRANSACTION;INSERT INTO user VALUES (6, 'd', 1000);-- 小王 - 北京START TRANSACTION;-- 小张 - 成都COMMIT; 当前事务开启后，没提交之前，查询不到，提交后可以被查询到。但是，在提交之前其他事务被开启了，那么在这条事务线上，就不会查询到当前有操作事务的连接。相当于开辟出一条单独的线程。 无论小张是否执行过 COMMIT ，在小王这边，都不会查询到小张的事务记录，而是只会查询到自己所处事务的记录： 12345678910SELECT * FROM user;+----+-----------+-------+| id | name | money |+----+-----------+-------+| 1 | a | 900 || 2 | b | 1100 || 3 | 小明 | 1000 || 4 | 淘宝店 | 1000 || 5 | c | 100 |+----+-----------+-------+ 这是因为小王在此之前开启了一个新的事务 ( START TRANSACTION ) **，那么在他的这条新事务的线上，跟其他事务是没有联系的**，也就是说，此时如果其他事务正在操作数据，它是不知道的。 然而事实是，在真实的数据表中，小张已经插入了一条数据。但是小王此时并不知道，也插入了同一条数据，会发生什么呢？ 12INSERT INTO user VALUES (6, 'd', 1000);-- ERROR 1062 (23000): Duplicate entry '6' for key 'PRIMARY' 报错了，操作被告知已存在主键为 6 的字段。这种现象也被称为幻读，一个事务提交的数据，不能被其他事务读取到。 串行化顾名思义，就是所有事务的写入操作全都是串行化的。什么意思？把隔离级别修改成 SERIALIZABLE : 1234567SET GLOBAL TRANSACTION ISOLATION LEVEL SERIALIZABLE;SELECT @@GLOBAL.TRANSACTION_ISOLATION;+--------------------------------+| @@GLOBAL.TRANSACTION_ISOLATION |+--------------------------------+| SERIALIZABLE |+--------------------------------+ 还是拿小张和小王来举例： 123456789101112131415161718192021-- 小张 - 成都START TRANSACTION;-- 小王 - 北京START TRANSACTION;-- 开启事务之前先查询表，准备操作数据。SELECT * FROM user;+----+-----------+-------+| id | name | money |+----+-----------+-------+| 1 | a | 900 || 2 | b | 1100 || 3 | 小明 | 1000 || 4 | 淘宝店 | 1000 || 5 | c | 100 || 6 | d | 1000 |+----+-----------+-------+-- 发现没有 7 号王小花，于是插入一条数据：INSERT INTO user VALUES (7, &#39;王小花&#39;, 1000); 此时会发生什么呢？由于现在的隔离级别是 SERIALIZABLE ( 串行化 ) ，串行化的意思就是：假设把所有的事务都放在一个串行的队列中，那么所有的事务都会按照固定顺序执行，执行完一个事务后再继续执行下一个事务的写入操作 ( 这意味着队列中同时只能执行一个事务的写入操作 ) 。 根据这个解释，小王在插入数据时，会出现等待状态，直到小张执行 COMMIT 结束它所处的事务，或者出现等待超时。","tags":[{"name":"MySQL","slug":"MySQL","permalink":"http://yoursite.com/tags/MySQL/"}]},{"title":"leetcode_766","date":"2020-05-27T04:12:28.000Z","path":"2020/05/27/leetcode-766/","text":"托普利茨矩阵 给定一个矩阵，判断其是否为托普利茨矩阵（如果一个矩阵的每一方向由左上到右下的对角线上具有相同元素，那么这个矩阵是托普利茨矩阵）。 解： 要理解对角线在矩阵中的数学表达。 对于对角线上后来出现的元素，托普利茨矩阵要求其与左上角的元素，即同一对角线上先出现的元素相同，元素A[i][j]的左上角元素为A[i-1][j-1]，遍历除了第一行&amp;第一列外的所有元素，若全与左上角相同，则返回true，否则返回false。 12345678910bool isToeplitzMatrix(vector&lt;vector&lt;int&gt;&gt;&amp; matrix) &#123; if(matrix.size()==1 || matrix[0].size()==1) return true; for(int i=1; i&lt;matrix.size(); i++)&#123; for(int j=1; j&lt;matrix[0].size(); j++)&#123; if(matrix[i][j]!=matrix[i-1][j-1]) return false; &#125; &#125; return true;&#125; 复杂度时间复杂度：O(m*n)。 空间复杂度：O(1)。 Tip：C++中二维数组的列数为matrix.length，行数为matrix[0].length。","tags":[{"name":"array","slug":"array","permalink":"http://yoursite.com/tags/array/"}]},{"title":"leetcode_867","date":"2020-05-27T03:10:42.000Z","path":"2020/05/27/leetcode-867/","text":"867.转置矩阵 给定一个矩阵，要求返回其转置矩阵（矩阵由二维vector存储）。 解： m*n的矩阵转置后会得到n*m的矩阵，假设原矩阵为A，转置后矩阵为B，则A[i][j] =B[j][j]。 嵌套for循环对二维数组逐个赋值即可。 Tip：C++中VECTOR的容量问题。 方法 效果 size() 返回容器的大小 empty() 判断容器是否为空 max_size() 返回容器最大的可以存储的元素 capacity() 返回容器当前能够容纳的元素数量 如果v.push_back(1)，容器本身可以提供且存储的元素为n个，加入一个元素后空间不足，申请后大小变为原来的两倍，固得到的size为n+1，而得到的capacity为2n。","tags":[{"name":"array","slug":"array","permalink":"http://yoursite.com/tags/array/"}]},{"title":"HTML快查","date":"2020-05-21T09:41:14.000Z","path":"2020/05/21/HTML快查/","text":"HTML语法快查 HTML基本框架1234567891011121314151617&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;title&gt;文档标题&lt;&#x2F;title&gt;&lt;&#x2F;head&gt;&lt;body&gt;可见文本...&lt;&#x2F;body&gt;&lt;&#x2F;html&gt; 基本标签12345678910111213141516171819&lt;h1&gt;最大的标题&lt;&#x2F;h1&gt;&lt;h2&gt; . . . &lt;&#x2F;h2&gt;&lt;h3&gt; . . . &lt;&#x2F;h3&gt;&lt;h4&gt; . . . &lt;&#x2F;h4&gt;&lt;h5&gt; . . . &lt;&#x2F;h5&gt;&lt;h6&gt;最小的标题&lt;&#x2F;h6&gt;&lt;p&gt;这是一个段落。&lt;&#x2F;p&gt;&lt;br&gt; （换行）&lt;hr&gt; （水平线）&lt;!-- 这是注释 --&gt; 文本格式化123456789101112131415161718192021222324252627282930313233&lt;b&gt;粗体文本&lt;&#x2F;b&gt;&lt;code&gt;计算机代码&lt;&#x2F;code&gt;&lt;em&gt;强调文本&lt;&#x2F;em&gt;&lt;i&gt;斜体文本&lt;&#x2F;i&gt;&lt;kbd&gt;键盘输入&lt;&#x2F;kbd&gt;&lt;pre&gt;预格式化文本&lt;&#x2F;pre&gt;&lt;small&gt;更小的文本&lt;&#x2F;small&gt;&lt;strong&gt;重要的文本&lt;&#x2F;strong&gt;&lt;abbr&gt; （缩写）&lt;address&gt; （联系信息）&lt;bdo&gt; （文字方向）&lt;blockquote&gt; （从另一个源引用的部分）&lt;cite&gt; （工作的名称）&lt;del&gt; （删除的文本）&lt;ins&gt; （插入的文本）&lt;sub&gt; （下标文本）&lt;sup&gt; （上标文本） 链接123456789101112普通的链接：&lt;a href&#x3D;&quot;http:&#x2F;&#x2F;www.example.com&#x2F;&quot;&gt;链接文本&lt;&#x2F;a&gt;图像链接： &lt;a href&#x3D;&quot;http:&#x2F;&#x2F;www.example.com&#x2F;&quot;&gt;&lt;img src&#x3D;&quot;URL&quot;alt&#x3D;&quot;替换文本&quot;&gt;&lt;&#x2F;a&gt;邮件链接： &lt;a href&#x3D;&quot;mailto:webmaster@example.com&quot;&gt;发送e-mail&lt;&#x2F;a&gt;书签：&lt;a id&#x3D;&quot;tips&quot;&gt;提示部分&lt;&#x2F;a&gt;&lt;a href&#x3D;&quot;#tips&quot;&gt;跳到提示部分&lt;&#x2F;a&gt; 图片1&lt;img src&#x3D;&quot;URL&quot; alt&#x3D;&quot;替换文本&quot; height&#x3D;&quot;42&quot; width&#x3D;&quot;42&quot;&gt; 区块1234567891011&lt;style type&#x3D;&quot;text&#x2F;css&quot;&gt;h1 &#123;color:red;&#125;p &#123;color:blue;&#125;&lt;&#x2F;style&gt;&lt;div&gt;文档中的块级元素&lt;&#x2F;div&gt;&lt;span&gt;文档中的内联元素&lt;&#x2F;span&gt; 无序有序列表12345678910111213141516&lt;ul&gt; &lt;li&gt;项目&lt;&#x2F;li&gt; &lt;li&gt;项目&lt;&#x2F;li&gt;&lt;&#x2F;ul&gt;&lt;ol&gt; &lt;li&gt;第一项&lt;&#x2F;li&gt; &lt;li&gt;第二项&lt;&#x2F;li&gt;&lt;&#x2F;ol&gt; 定义列表1234567891011&lt;dl&gt; &lt;dt&gt;项目 1&lt;&#x2F;dt&gt; &lt;dd&gt;描述项目 1&lt;&#x2F;dd&gt; &lt;dt&gt;项目 2&lt;&#x2F;dt&gt; &lt;dd&gt;描述项目 2&lt;&#x2F;dd&gt;&lt;&#x2F;dl&gt; 表格12345678910111213141516171819&lt;table border&#x3D;&quot;1&quot;&gt; &lt;tr&gt; &lt;th&gt;表格标题&lt;&#x2F;th&gt; &lt;th&gt;表格标题&lt;&#x2F;th&gt; &lt;&#x2F;tr&gt; &lt;tr&gt; &lt;td&gt;表格数据&lt;&#x2F;td&gt; &lt;td&gt;表格数据&lt;&#x2F;td&gt; &lt;&#x2F;tr&gt;&lt;&#x2F;table&gt; 框架1&lt;iframe src&#x3D;&quot;demo_iframe.htm&quot;&gt;&lt;&#x2F;iframe&gt; 表单1234567891011121314151617181920212223242526272829&lt;form action&#x3D;&quot;demo_form.php&quot; method&#x3D;&quot;post&#x2F;get&quot;&gt;&lt;input type&#x3D;&quot;text&quot; name&#x3D;&quot;email&quot; size&#x3D;&quot;40&quot; maxlength&#x3D;&quot;50&quot;&gt;&lt;input type&#x3D;&quot;password&quot;&gt;&lt;input type&#x3D;&quot;checkbox&quot; checked&#x3D;&quot;checked&quot;&gt;&lt;input type&#x3D;&quot;radio&quot; checked&#x3D;&quot;checked&quot;&gt;&lt;input type&#x3D;&quot;submit&quot; value&#x3D;&quot;Send&quot;&gt;&lt;input type&#x3D;&quot;reset&quot;&gt;&lt;input type&#x3D;&quot;hidden&quot;&gt;&lt;select&gt;&lt;option&gt;苹果&lt;&#x2F;option&gt;&lt;option selected&#x3D;&quot;selected&quot;&gt;香蕉&lt;&#x2F;option&gt;&lt;option&gt;樱桃&lt;&#x2F;option&gt;&lt;&#x2F;select&gt;&lt;textarea name&#x3D;&quot;comment&quot; rows&#x3D;&quot;60&quot; cols&#x3D;&quot;20&quot;&gt;&lt;&#x2F;textarea&gt;&lt;&#x2F;form&gt; 实体12345&lt; 等同于 &lt;&gt; 等同于 &gt;&amp;#169; 等同于 ©","tags":[{"name":"HTML","slug":"HTML","permalink":"http://yoursite.com/tags/HTML/"}]},{"title":"HTML入门","date":"2020-05-21T09:30:54.000Z","path":"2020/05/21/HTML入门/","text":"HTML的入门学习 12345678910111213&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset&#x3D;&quot;utf-8&quot;&gt;&lt;title&gt;Vain&lt;&#x2F;title&gt;&lt;&#x2F;head&gt;&lt;body&gt;&lt;h1&gt;标题&lt;&#x2F;h1&gt;&lt;p&gt;段落。&lt;&#x2F;p&gt;&lt;&#x2F;body&gt;&lt;&#x2F;html&gt; &lt;!DOCTYPE html&gt; 声明为 HTML5 文档&lt;html&gt; 元素是 HTML 页面的根元素&lt;head&gt; 元素包含了文档的元（meta）数据，如 &lt;meta charset=”utf-8”&gt;定义网页编码格式为 utf-8（中文）。&lt;title&gt; 元素描述了文档的标题&lt;body&gt; 元素包含了可见的页面内容&lt;h1&gt; 元素定义一个大标题&lt;p&gt; 元素定义一个段落 …… 注：在浏览器的页面上使用键盘上的 F12 按键开启调试模式，就可以看到组成标签。 Hyper Text Markup Language——标记语言 HTML元素包括 &lt;标签&gt;内容&lt;/标签&gt; 开始标签-内容-结束标签 注：只有 &lt;body&gt;才会在浏览器中显示。 编译器Visual Studio Code（简称 VS Code）。 新建HTML文件另存为HTML文件在浏览器中运行这个 HTML 文件 元素 开始标签 含义 结束标签 &lt;p&gt; 这是一个段落 &lt;/p&gt; &lt;a href=”default.htm”&gt; 这是一个链接 &lt;/a&gt; &lt;br&gt; 换行 &lt;h1&gt; 这是一个标题 &lt;/h1&gt; 标题（Heading）是通过&lt;h1&gt;-&lt;h6&gt;标签进行定义的。&lt;h1&gt;定义最大的标题。&lt;h6&gt;定义最小的标题。请确保将HTML标题标签只用于标题。不要仅仅是为了生成粗体或大号的文本而使用标题。浏览器会自动地在标题的前后添加空行。 搜索引擎使用标题为您的网页的结构和内容编制索引。&lt;br&gt;就是没有关闭标签的空元素，但使用&lt;br/&gt;更正规。 &lt;hr&gt; 标签在 HTML 页面中创建水平线。 &lt;!– 这是一个注释 –&gt; &lt;body&gt; 定义文档的主体 标签使用小写。 属性 类型 作用 class 为html元素定义一个或多个类名 id 定义元素的唯一id style 规定元素的行内样式（inlinestyle） title 描述了元素的额外信息(作为工具条使用) 属性值应该始终被包括在双引号内；在某些个别的情况下，比如属性值本身就含有双引号，则使用单引号。 属性使用小写。 文本格式化&lt;b&gt;加粗文本&lt;/b&gt; &lt;i&gt;斜体文本&lt;/i&gt; &lt;code&gt;电脑自动输出&lt;/code&gt; 这是 &lt;sub&gt; 下标&lt;/sub&gt; 和 &lt;sup&gt; 上标&lt;/sup&gt; 链接&lt;p&gt;&lt;a href=”//www.microsoft.com/&quot;\\&gt;本文本\\&lt;/a&gt;是一个指向万维网上的页面的链接。&lt;/p&gt; 默认情况下：一个未访问过的链接显示为蓝色字体并带有下划线。访问过的链接显示为紫色并带有下划线。点击链接时，链接显示为红色并带有下划线。 可以通过属性定义链接，如target、id，已适应不同的场景和需求。可以对超链接设置CSS样式，展示样式会根据CSS的设定而显示。 头部&lt;head&gt;元素包含了所有的头部标签元素。在&lt;head&gt;元素中你可以插入脚本（scripts）,样式文件（CSS），及各种meta信息。 可以添加在头部区域的元素标签为:&lt;title&gt;,&lt;style&gt;,&lt;meta&gt;,&lt;link&gt;,&lt;script&gt;,&lt;noscript&gt;和&lt;base&gt;。&lt;script&gt;标签用于加载脚本文件，如：JavaScript。 标签 描述 &lt;head&gt; 定义了文档的信息 &lt;title&gt; 定义了文档的标题 &lt;base&gt; 定义了页面链接标签的默认链接地址 &lt;link&gt; 定义了一个文档和外部资源之间的关系 &lt;meta&gt; 定义了HTML文档中的元数据 &lt;script&gt; 定义了客户端的脚本文件 &lt;style&gt; 定义了HTML文档的样式文件 CSSCSS (Cascading Style Sheets) 用于渲染HTML元素标签的样式。 CSS可以通过以下方式添加到HTML中: 1·内联样式-在HTML元素中使用”style”属性； 2·内部样式表-在HTML文档头部&lt;head&gt;区域使用&lt;style&gt;元素来包含CSS； 3·外部引用-使用外部CSS文件。 最好的方式是通过外部引用CSS文件。 对于大部分标签，”内联”和”外引”两种方式均可，且修改父级标签，子级标签特性也会改变。但某些标签确无法通过修改父级标签来改变子级标签特性，如a标签，修改其颜色特性，必须直接修改a标签的特性才可。 图像&lt;img border=”0” src=”/images/pulpit.jpg” alt=”Pulpit rock” width=”304”height=”228”&gt; 加载页面时，要注意插入页面图像的路径，如果不能正确设置图像的位置，浏览器无法加载图片，图像标签就会显示一个破碎的图片。 表格表格由&lt;table&gt;标签来定义。每个表格均有若干行（由&lt;tr&gt;标签定义），每行被分割为若干单元格（由&lt;td&gt;标签定义）。字母td指表格数据（tabledata），即数据单元格的内容。数据单元格可以包含文本、图片、列表、段落、表单、水平线、表格等等。 列表等不赘述。 区块大多数HTML元素被定义为块级元素或内联元素。 ——块级元素在浏览器显示时，通常会以新行来开始（和结束）。 HTML&lt;div&gt;元素是块级元素，它可用于组合其他HTML元素的容器。 &lt;div&gt;元素没有特定的含义。除此之外，由于它属于块级元素，浏览器会在其前后显示折行。如果与CSS一同使用，&lt;div&gt;元素可用于对大的内容块设置样式属性。&lt;div&gt;元素的另一个常见的用途是文档布局。 ——内联元素在显示时通常不会以新行开始。 HTML&lt;span&gt;元素是内联元素，可用作文本的容器，&lt;span&gt;元素也没有特定的含义。 当与CSS一同使用时，&lt;span&gt;元素可用于为部分文本设置样式属性。 布局网页布局对改善网站的外观非常重要。 大多数网站可以使用&lt;div&gt;或者&lt;table&gt;元素来创建多列。CSS用于对元素进行定位，或者为页面创建背景以及色彩丰富的外观。 使用CSS最大的好处是，如果把CSS代码存放到外部样式表中，那么站点会更易于维护。通过编辑单一的文件，就可以改变所有页面的布局。 表单HTML 表单用于收集不同类型的用户输入。 表单是一个包含表单元素的区域。表单元素是允许用户在表单中输入内容,比如：文本域(textarea)、下拉列表、单选框(radio-buttons)、复选框(checkboxes)等等。表单使用表单标签&lt;form&gt;来设置。 文本域通过&lt;inputtype=”text”&gt;标签来设定，当用户要在表单中键入字母、数字等内容时，就会用到文本域。 密码字段通过标签&lt;input type=”password”&gt;来定义。 &lt;inputtype=”radio”&gt;标签定义了表单单选框选项。可以设置以下几个属性：value、name、checked。 &lt;inputtype=”checkbox”&gt;定义了复选框。用户需要从若干给定的选择中选取一个或若干选项。 &lt;inputtype=”submit”&gt;定义了提交按钮。当用户单击确认按钮时，表单的内容会被传送到另一个文件。表单的动作属性定义了目的文件的文件名。由动作属性定义的这个文件通常会对接收到的输入数据进行相关的处理。 此外还有下拉列表选项、计算结果等。 框架通过使用框架，可以在同一个浏览器窗口中显示不止一个页面。 iframe语法: &lt;iframesrc=”URL”&gt;&lt;/iframe&gt; 该URL指向不同的网页。 颜色HTML颜色由一个十六进制符号来定义，这个符号由红色、绿色和蓝色的值组成（RGB）。 每种颜色的最小值是0（十六进制：#00）。最大值是255（十六进制：#FF）。 RGBA的意思是（Red-Green-Blue-Alpha）它是在RGB上扩展包括了“alpha”通道，运行对颜色值设置透明度。 141个颜色名称是在HTML和CSS颜色规范定义的（17标准颜色，再加124）。 脚本JavaScript使HTML页面具有更强的动态和交互性。 &lt;script&gt;标签用于定义客户端脚本，比如JavaScript，其既可包含脚本语句，也可通过src属性指向外部脚本文件。 &lt;noscript&gt;标签提供无法使用脚本时的替代内容，比方在浏览器禁用脚本时，或浏览器不支持客户端脚本时；只有在浏览器不支持脚本或者禁用脚本时，才会显示&lt;noscript&gt;元素中的内容。 字符实体HTML中的预留字符必须被替换为字符实体，以防浏览器误认为它们是标签。 HTML中的常用字符实体是不间断空格(&amp;nbsp;)。浏览器总是会截短HTML页面中的空格。如果在文本中写10个空格，在显示该页面之前，浏览器会删除它们中的9个。如需在页面中增加空格的数量，则需要使用&nbsp;字符实体。 URLURL——统一资源定位器是一个网页地址。 常见的URL Scheme（定义因特网服务的类型）—— Scheme 访问 用于… http 超文本传输协议 以 http:// 开头的普通网页。不加密。 https 安全超文本传输协议 安全网页，加密所有信息交换。 ftp 文件传输协议 用于将文件下载或上传至网站。 file 您计算机上的文件。","tags":[{"name":"HTML","slug":"HTML","permalink":"http://yoursite.com/tags/HTML/"}]},{"title":"leetcode_1","date":"2020-05-21T06:41:24.000Z","path":"2020/05/21/leetcode-1/","text":"1.两数之和 给定一个数组以及一个目标值——在该数组中找出和为目标值的那两个整数，并返回他们的数组下标。 解： 暴力法—— 遍历数组，对于每一个函数x，都再次遍历数组查找是否存在于target-x相等的元素。 两遍哈希表—— Hash表支持以近似恒定的速度查找元素，通过以空间换取速度的方式。使用两次迭代，第一次迭代将每个元素的值和它的索引添加到表中，；第二次迭代检查每个元素所对应的目标元素target-x是否存在于表中。 12345678910111213class Solution &#123;public: vector&lt;int&gt; twoSum(vector&lt;int&gt;&amp; nums, int target) &#123; unordered_map&lt;int,int&gt; m; for(int i = 0; i&lt;nums.size(); i++) m[nums[i]] = i; //向map中添加元素 for(int i = 0; i&lt;nums.size(); i++)&#123; if(m.find(target-nums[i]) != m.end() &amp;&amp; m[target-nums[i]] != i)//如果m中存在对应的键值，且不为i return &#123;i, m[target-nums[i]]&#125;; &#125; return &#123;&#125;; &#125;&#125;; 复杂度暴力法 时间复杂度：O(n2)。对于每一个元素，都需要遍历整个数组来查找是否存在target-x。 空间复杂度：O(1)。 两遍哈希表 时间复杂度：O(n)。把数组遍历了两次，由于哈希表将查找时间缩短到O(1)，所以时间复杂度为O(n)。 空间复杂度：O(n)。所需的额外空间取决于哈希表中存储的元素数量，该表中存储了n个元素。 Tip：HashMap在resize、put的时候消耗了很多时间没有计算在内，但这些其实都属于初始化范畴，在实际开发中，其实是一次性开销。 Java集合类中的Map.containsKey()方法判断Map集合对象中是否包含指定的键名。如果Map集合中包含指定的键名，则返回true，否则返回false。 也去专门去查了hashMap.containsKey()的时间复杂度，使用指针指向数组引用，时间复杂度为O(1)，未命中时，才回去遍历红黑树，时间复杂度为O(n)，如果仔细地挑选哈希函数，在哈希表中进行查找的用时应当被摊销为O(1)。 C++中，在map中查找key为k的元素，返回指向它的迭代器。若k不存在，返回map::end，返回值是一个迭代器，成功返回迭代器指向要查找的元素，失败返回的迭代器指向end。 map unordered_map #include &lt;map&gt; #include &lt;unordered_map&gt; map内部实现了一个红黑树，该结构具有自动排序的功能，因此map内部的所有元素都是有序的，红黑树的效率决定了map的效率。 unordered_map内部实现了一个哈希表，因此其元素的排列顺序是杂乱的，无序的。 红黑树、有序、空间占用率高 哈希表、无序、耗费时间多 对于那些有顺序要求的问题，用map会更高效一些 对于查找问题，unordered_map会更加高效一些","tags":[{"name":"array","slug":"array","permalink":"http://yoursite.com/tags/array/"}]},{"title":"leetcode_167","date":"2020-05-21T03:39:09.000Z","path":"2020/05/21/leetcode-167/","text":"167.两数之和II -输入有序数组 给定一个升序排列的数组以及一个目标值——求数组中的两个元素和为目标值，并按序输出两个元素的下标。 解： 双指针法——分别记录第一个元素和最后一个元素，求和后与target值比较大小，偏大则移动尾指针（值变小），偏小则移动头指针（值变大），等于目标值则按序输出头尾指针。 复杂度时间复杂度：O(n)。每个元素最多被访问一次。 空间复杂度：O(1)。只是用了两个指针。 Tip：vector作为参数的三种传参方式 c++中常用的vector容器作为参数时（为说明问题，用二维vector）： function1(std::vector&lt;std::vector&lt;int&gt; &gt; vec)，传值 function2(std::vector&lt;std::vector&lt;int&gt; &gt;&amp; vec)，传引用 function3(std::vector&lt;std::vector&lt;int&gt; &gt;* vec)，传指针 三种方式对应的调用形式分别为： function1(vec)，传入值 function2(vec)，传入引用 function3(&amp;vec),传入地址 三种方式在函数调用时是否了vector的拷贝构造函数： 会发生拷贝构造 不会发生拷贝构造 不会发生拷贝构造 函数体 函数调用 拷贝构造函数 void 函数名(vector&lt;int&gt; obj); deal( vec ); void 函数名(vector&lt;int&gt;* pobj); deal( &amp;vec ); void 函数名(const vector&lt;int&gt;* pobj); deal( &amp;vec ); 调用时不会调用拷贝构造函数 void 函数名(vector&lt;int&gt;&amp; obj); deal( vec ); void 函数名(const vector&lt;int&gt;&amp; obj); deal( vec ); 调用时会调用拷贝构造函数 *如果需要在函数中对vector容器中数据调换顺序等操作需要是引用传递 1234567vector&lt;int&gt; twoSum(vector&lt;int&gt;&amp; numbers, int target) &#123; //… int low = 0, high = numbers.size() - 1; //… return &#123;low + 1, high + 1&#125;; //…&#125;","tags":[{"name":"array","slug":"array","permalink":"http://yoursite.com/tags/array/"}]},{"title":"leetcode_941","date":"2020-05-20T09:29:15.000Z","path":"2020/05/20/leetcode-941/","text":"941.有效的山脉数组 检查一个数组是否符合山脉数组——数组元素大于等于三个，且存在某中间元素，其前元素值为递增，其后元素值为递减。 解： 按照数组下标扫描即可，判断出峰元素（从1到length-1的前一个），然后检查其后是否递减，判断以及检查中若有相等或者相反变化的部分，则return false。","tags":[{"name":"array","slug":"array","permalink":"http://yoursite.com/tags/array/"}]},{"title":"leetcode_914","date":"2020-05-20T08:43:13.000Z","path":"2020/05/20/leetcode-914/","text":"914.卡牌分组 检查一个数组是否符合分组的规则——可以分成大小一样的若干数组且各个数组中的数字都一样（子数组长度最小为2）。 解： 统计各个数字出现的次数，然后求其是否存在最大公约数大于等于2。 12345678910111213141516//求最大公约数int gcd(int a,int b)&#123; if(b == 0) return a; return gcd(b,a%b);&#125;class Solution &#123;public: bool hasGroupsSizeX(vector\\&lt;int\\&gt;&amp; deck) &#123; int bucket[10000] = &#123;0&#125;; int g = 0; for (int d : deck) bucket[d]++; //基于范围的for循环(C++11) for (int b : bucket) g = gcd(b, g); return g \\&gt;= 2; &#125;&#125;; Tip： for 语句允许简单的范围迭代： 1234567891011int my_array[5] = &#123;1, 2, 3, 4, 5&#125;;// 每个数组元素乘于 2for (int &amp;x : my_array)&#123; x *= 2; cout &lt;&lt; x &lt;&lt; endl;&#125;// auto 类型也是 C++11 新标准中的，用来自动获取变量的类型for (auto &amp;x : my_array) &#123; x *= 2; cout &lt;&lt; x &lt;&lt; endl;&#125; 上面for述句的第一部分定义被用来做范围迭代的变量，就像被声明在一般for循环的变量一样，其作用域仅只于循环的范围。而在”:”之后的第二区块，代表将被迭代的范围。","tags":[{"name":"array","slug":"array","permalink":"http://yoursite.com/tags/array/"}]},{"title":"人物塑造-第二真","date":"2020-05-19T08:48:38.000Z","path":"2020/05/19/人物塑造-第二真/","text":"人的认知是片面独立的。 每个人对他人的认定大多源于某个既定影响，然后随着某个契机，这个印象不断完善，人的好奇心，对世界的感官，都在促使这件事的完成。 对这个契机的认知是价值观的体现，人们喜欢把想象中的自己沉浸在其中，用想象中的自己去判断一维的好坏。 是想象中的自己，因为人们对自己的认知偏颇难以避免，这种认知同样是片面的，人们在做决定的时候更多的是内心存在选择后，尝试去反驳和证明，反驳和证明都需要存在，这种公允的，中庸的冷静，在和渴望挂不上钩的时候是必然存在的，渴望存在前和是如此经历被琢磨的。 人们判断他人、事物的时候把想象中的自己带入，而判断的主角和法官都是自己的时候，人们把想象带入，这是更深一层的渴望，如果说上者人们还顾及道德和法律，在判断自己的人生时，人们的思绪更多像个辩论赛，这场辩论的比分则由理性的逻辑和感性的价值观决定了。 人们对自己的认知和对别人的认知是完全不同的存在，本文要讨论的就是对他人的认知。 对他人的认知是把想象中的自己带入去判决一维的正误。 人物的塑造譬如肖像描写，仅仅只是第一印象的加成，在文学艺术作品里，所谓人物塑造栩栩如生是需要后期的那个契机的，人物形象丰满必须要有的过程。 塑造人物的手法套路大多出于经验，很成熟的方法论，然而其内核就是完成对读者的认知引导。成功塑造人物需要第一印象的捏造以及后续的契机设立，这种解构的方式是对塑造手法的总结。 说回人们对他人的认知，人的内在逻辑其实是单向的，不仅仅是对体验结果的判决，更是对契机引起的变化的一种单向，这就是反差存在的逻辑。 被成功塑造的恶人，在肖像方面往往是文质彬彬甚至美轮美奂的，其恶当然不只是源于人们对他后续行径的一种价值观判决，更多的，是一种反差的存在，人们的内在逻辑简单化，一者，判决的理智会被这种曲线的填满，人们更倾向于坚信后来被说服的事情，这是源于对后悔的习性，轻车熟路的悔不当初并拍案叫绝；二者是对他人认知的成长判决的简单性，这种判决源于其反差的方向，和肖像的相对方向，这就是人们心中的预设期望。 预设期望源于对第一印象的判决，沉浸式判决加以经验，让肖像在人心里留下一个正或负的分数，而后的契机成长，如果正数的正向成长，人们会在逻辑上表示，哦，果然是这样，这就是毫无新意的普通好人或者坏人，但如果是负数的正向成长，那会给人以冲击，所谓丰满，就是让人们意识到自己的认知错误，人们感觉到成长，感官甚至人生层面上的丰满。 对于好人的预设是一样的，瑕疵感为后来的正向成长加分的，除了真实的不完美，更多的和负数的正面成长的逻辑相似，人们倾向于相信第二个真理。当然也可以简单理解为经验，譬如欲扬先抑或者是巴黎圣母院中的克洛德。 第二个真理的说服力是一个很强大的存在。 颠覆给人一种辩证的真实感，世界并不是非黑即白的，人物的塑造当然不只是为了正面这正误的共生性，更多的还是去引导这种逻辑，操控观者的认知过程，没有影视作品会想要用负数印象加一个正向成长来塑造负面形象的，即使这种负面形象是一种复杂的，难判定好与坏的人物形象，作品也会有偏颇，有初衷与结果。 第二个真理是引导思维认知的重要理论依据。","tags":[{"name":"随笔","slug":"随笔","permalink":"http://yoursite.com/tags/%E9%9A%8F%E7%AC%94/"}]},{"title":"lu","date":"2020-04-05T07:48:58.000Z","path":"2020/04/05/lu/","text":"热爱","tags":[{"name":"随笔","slug":"随笔","permalink":"http://yoursite.com/tags/%E9%9A%8F%E7%AC%94/"}]},{"title":"x","date":"2020-04-05T07:48:18.000Z","path":"2020/04/05/x/","text":"Practice in individual leetcode Three questions per article per day Tags and knowledge extension are important algorithm According to leetcode, summarize the application of various classical algorithms A single article to tabulate various algorithms python Grammar and application C++ Grammar and application artificial intelligence Scipy-python Sklearm-python Deep Learning(to realize machine learning) Machine learning taught by Wu enda Neural network(after the fifth lesson) (by 3Blue1Brow) Deep learning(a flower color book) by Ian Goodfellow Sequence modeling linux operation and maintenance development bottom layer","tags":[{"name":"x","slug":"x","permalink":"http://yoursite.com/tags/x/"}]}]