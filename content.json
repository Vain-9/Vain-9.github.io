[{"title":"leetcode_867","date":"2020-05-27T03:10:42.000Z","path":"2020/05/27/leetcode-867/","text":"867.转置矩阵 给定一个矩阵，要求返回其转置矩阵（矩阵由二维vector存储）。 解： m*n的矩阵转置后会得到n*m的矩阵，假设原矩阵为A，转置后矩阵为B，则A[i][j] =B[j][j]。 嵌套for循环对二维数组逐个赋值即可。 Tip：C++中VECTOR的容量问题。 方法 效果 size() 返回容器的大小 empty() 判断容器是否为空 max_size() 返回容器最大的可以存储的元素 capacity() 返回容器当前能够容纳的元素数量 如果v.push_back(1)，容器本身可以提供且存储的元素为n个，加入一个元素后空间不足，申请后大小变为原来的两倍，固得到的size为n+1，而得到的capacity为2n。","tags":[{"name":"array","slug":"array","permalink":"http://yoursite.com/tags/array/"}]},{"title":"HTML快查","date":"2020-05-21T09:41:14.000Z","path":"2020/05/21/HTML快查/","text":"HTML语法快查 HTML基本框架1234567891011121314151617&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;title&gt;文档标题&lt;&#x2F;title&gt;&lt;&#x2F;head&gt;&lt;body&gt;可见文本...&lt;&#x2F;body&gt;&lt;&#x2F;html&gt; 基本标签12345678910111213141516171819&lt;h1&gt;最大的标题&lt;&#x2F;h1&gt;&lt;h2&gt; . . . &lt;&#x2F;h2&gt;&lt;h3&gt; . . . &lt;&#x2F;h3&gt;&lt;h4&gt; . . . &lt;&#x2F;h4&gt;&lt;h5&gt; . . . &lt;&#x2F;h5&gt;&lt;h6&gt;最小的标题&lt;&#x2F;h6&gt;&lt;p&gt;这是一个段落。&lt;&#x2F;p&gt;&lt;br&gt; （换行）&lt;hr&gt; （水平线）&lt;!-- 这是注释 --&gt; 文本格式化123456789101112131415161718192021222324252627282930313233&lt;b&gt;粗体文本&lt;&#x2F;b&gt;&lt;code&gt;计算机代码&lt;&#x2F;code&gt;&lt;em&gt;强调文本&lt;&#x2F;em&gt;&lt;i&gt;斜体文本&lt;&#x2F;i&gt;&lt;kbd&gt;键盘输入&lt;&#x2F;kbd&gt;&lt;pre&gt;预格式化文本&lt;&#x2F;pre&gt;&lt;small&gt;更小的文本&lt;&#x2F;small&gt;&lt;strong&gt;重要的文本&lt;&#x2F;strong&gt;&lt;abbr&gt; （缩写）&lt;address&gt; （联系信息）&lt;bdo&gt; （文字方向）&lt;blockquote&gt; （从另一个源引用的部分）&lt;cite&gt; （工作的名称）&lt;del&gt; （删除的文本）&lt;ins&gt; （插入的文本）&lt;sub&gt; （下标文本）&lt;sup&gt; （上标文本） 链接123456789101112普通的链接：&lt;a href&#x3D;&quot;http:&#x2F;&#x2F;www.example.com&#x2F;&quot;&gt;链接文本&lt;&#x2F;a&gt;图像链接： &lt;a href&#x3D;&quot;http:&#x2F;&#x2F;www.example.com&#x2F;&quot;&gt;&lt;img src&#x3D;&quot;URL&quot;alt&#x3D;&quot;替换文本&quot;&gt;&lt;&#x2F;a&gt;邮件链接： &lt;a href&#x3D;&quot;mailto:webmaster@example.com&quot;&gt;发送e-mail&lt;&#x2F;a&gt;书签：&lt;a id&#x3D;&quot;tips&quot;&gt;提示部分&lt;&#x2F;a&gt;&lt;a href&#x3D;&quot;#tips&quot;&gt;跳到提示部分&lt;&#x2F;a&gt; 图片1&lt;img src&#x3D;&quot;URL&quot; alt&#x3D;&quot;替换文本&quot; height&#x3D;&quot;42&quot; width&#x3D;&quot;42&quot;&gt; 区块1234567891011&lt;style type&#x3D;&quot;text&#x2F;css&quot;&gt;h1 &#123;color:red;&#125;p &#123;color:blue;&#125;&lt;&#x2F;style&gt;&lt;div&gt;文档中的块级元素&lt;&#x2F;div&gt;&lt;span&gt;文档中的内联元素&lt;&#x2F;span&gt; 无序有序列表12345678910111213141516&lt;ul&gt; &lt;li&gt;项目&lt;&#x2F;li&gt; &lt;li&gt;项目&lt;&#x2F;li&gt;&lt;&#x2F;ul&gt;&lt;ol&gt; &lt;li&gt;第一项&lt;&#x2F;li&gt; &lt;li&gt;第二项&lt;&#x2F;li&gt;&lt;&#x2F;ol&gt; 定义列表1234567891011&lt;dl&gt; &lt;dt&gt;项目 1&lt;&#x2F;dt&gt; &lt;dd&gt;描述项目 1&lt;&#x2F;dd&gt; &lt;dt&gt;项目 2&lt;&#x2F;dt&gt; &lt;dd&gt;描述项目 2&lt;&#x2F;dd&gt;&lt;&#x2F;dl&gt; 表格12345678910111213141516171819&lt;table border&#x3D;&quot;1&quot;&gt; &lt;tr&gt; &lt;th&gt;表格标题&lt;&#x2F;th&gt; &lt;th&gt;表格标题&lt;&#x2F;th&gt; &lt;&#x2F;tr&gt; &lt;tr&gt; &lt;td&gt;表格数据&lt;&#x2F;td&gt; &lt;td&gt;表格数据&lt;&#x2F;td&gt; &lt;&#x2F;tr&gt;&lt;&#x2F;table&gt; 框架1&lt;iframe src&#x3D;&quot;demo_iframe.htm&quot;&gt;&lt;&#x2F;iframe&gt; 表单1234567891011121314151617181920212223242526272829&lt;form action&#x3D;&quot;demo_form.php&quot; method&#x3D;&quot;post&#x2F;get&quot;&gt;&lt;input type&#x3D;&quot;text&quot; name&#x3D;&quot;email&quot; size&#x3D;&quot;40&quot; maxlength&#x3D;&quot;50&quot;&gt;&lt;input type&#x3D;&quot;password&quot;&gt;&lt;input type&#x3D;&quot;checkbox&quot; checked&#x3D;&quot;checked&quot;&gt;&lt;input type&#x3D;&quot;radio&quot; checked&#x3D;&quot;checked&quot;&gt;&lt;input type&#x3D;&quot;submit&quot; value&#x3D;&quot;Send&quot;&gt;&lt;input type&#x3D;&quot;reset&quot;&gt;&lt;input type&#x3D;&quot;hidden&quot;&gt;&lt;select&gt;&lt;option&gt;苹果&lt;&#x2F;option&gt;&lt;option selected&#x3D;&quot;selected&quot;&gt;香蕉&lt;&#x2F;option&gt;&lt;option&gt;樱桃&lt;&#x2F;option&gt;&lt;&#x2F;select&gt;&lt;textarea name&#x3D;&quot;comment&quot; rows&#x3D;&quot;60&quot; cols&#x3D;&quot;20&quot;&gt;&lt;&#x2F;textarea&gt;&lt;&#x2F;form&gt; 实体12345&lt; 等同于 &lt;&gt; 等同于 &gt;&amp;#169; 等同于 ©","tags":[{"name":"HTML","slug":"HTML","permalink":"http://yoursite.com/tags/HTML/"}]},{"title":"HTML入门","date":"2020-05-21T09:30:54.000Z","path":"2020/05/21/HTML入门/","text":"HTML的入门学习 12345678910111213&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset&#x3D;&quot;utf-8&quot;&gt;&lt;title&gt;Vain&lt;&#x2F;title&gt;&lt;&#x2F;head&gt;&lt;body&gt;&lt;h1&gt;标题&lt;&#x2F;h1&gt;&lt;p&gt;段落。&lt;&#x2F;p&gt;&lt;&#x2F;body&gt;&lt;&#x2F;html&gt; &lt;!DOCTYPE html&gt; 声明为 HTML5 文档&lt;html&gt; 元素是 HTML 页面的根元素&lt;head&gt; 元素包含了文档的元（meta）数据，如 &lt;meta charset=”utf-8”&gt;定义网页编码格式为 utf-8（中文）。&lt;title&gt; 元素描述了文档的标题&lt;body&gt; 元素包含了可见的页面内容&lt;h1&gt; 元素定义一个大标题&lt;p&gt; 元素定义一个段落 …… 注：在浏览器的页面上使用键盘上的 F12 按键开启调试模式，就可以看到组成标签。 Hyper Text Markup Language——标记语言 HTML元素包括 &lt;标签&gt;内容&lt;/标签&gt; 开始标签-内容-结束标签 注：只有 &lt;body&gt;才会在浏览器中显示。 编译器Visual Studio Code（简称 VS Code）。 新建HTML文件另存为HTML文件在浏览器中运行这个 HTML 文件 元素 开始标签 含义 结束标签 &lt;p&gt; 这是一个段落 &lt;/p&gt; &lt;a href=”default.htm”&gt; 这是一个链接 &lt;/a&gt; &lt;br&gt; 换行 &lt;h1&gt; 这是一个标题 &lt;/h1&gt; 标题（Heading）是通过&lt;h1&gt;-&lt;h6&gt;标签进行定义的。&lt;h1&gt;定义最大的标题。&lt;h6&gt;定义最小的标题。请确保将HTML标题标签只用于标题。不要仅仅是为了生成粗体或大号的文本而使用标题。浏览器会自动地在标题的前后添加空行。 搜索引擎使用标题为您的网页的结构和内容编制索引。&lt;br&gt;就是没有关闭标签的空元素，但使用&lt;br/&gt;更正规。 &lt;hr&gt; 标签在 HTML 页面中创建水平线。 &lt;!– 这是一个注释 –&gt; &lt;body&gt; 定义文档的主体 标签使用小写。 属性 类型 作用 class 为html元素定义一个或多个类名 id 定义元素的唯一id style 规定元素的行内样式（inlinestyle） title 描述了元素的额外信息(作为工具条使用) 属性值应该始终被包括在双引号内；在某些个别的情况下，比如属性值本身就含有双引号，则使用单引号。 属性使用小写。 文本格式化&lt;b&gt;加粗文本&lt;/b&gt; &lt;i&gt;斜体文本&lt;/i&gt; &lt;code&gt;电脑自动输出&lt;/code&gt; 这是 &lt;sub&gt; 下标&lt;/sub&gt; 和 &lt;sup&gt; 上标&lt;/sup&gt; 链接&lt;p&gt;&lt;a href=”//www.microsoft.com/&quot;\\&gt;本文本\\&lt;/a&gt;是一个指向万维网上的页面的链接。&lt;/p&gt; 默认情况下：一个未访问过的链接显示为蓝色字体并带有下划线。访问过的链接显示为紫色并带有下划线。点击链接时，链接显示为红色并带有下划线。 可以通过属性定义链接，如target、id，已适应不同的场景和需求。可以对超链接设置CSS样式，展示样式会根据CSS的设定而显示。 头部&lt;head&gt;元素包含了所有的头部标签元素。在&lt;head&gt;元素中你可以插入脚本（scripts）,样式文件（CSS），及各种meta信息。 可以添加在头部区域的元素标签为:&lt;title&gt;,&lt;style&gt;,&lt;meta&gt;,&lt;link&gt;,&lt;script&gt;,&lt;noscript&gt;和&lt;base&gt;。&lt;script&gt;标签用于加载脚本文件，如：JavaScript。 标签 描述 &lt;head&gt; 定义了文档的信息 &lt;title&gt; 定义了文档的标题 &lt;base&gt; 定义了页面链接标签的默认链接地址 &lt;link&gt; 定义了一个文档和外部资源之间的关系 &lt;meta&gt; 定义了HTML文档中的元数据 &lt;script&gt; 定义了客户端的脚本文件 &lt;style&gt; 定义了HTML文档的样式文件 CSSCSS (Cascading Style Sheets) 用于渲染HTML元素标签的样式。 CSS可以通过以下方式添加到HTML中: 1·内联样式-在HTML元素中使用”style”属性； 2·内部样式表-在HTML文档头部&lt;head&gt;区域使用&lt;style&gt;元素来包含CSS； 3·外部引用-使用外部CSS文件。 最好的方式是通过外部引用CSS文件。 对于大部分标签，”内联”和”外引”两种方式均可，且修改父级标签，子级标签特性也会改变。但某些标签确无法通过修改父级标签来改变子级标签特性，如a标签，修改其颜色特性，必须直接修改a标签的特性才可。 图像&lt;img border=”0” src=”/images/pulpit.jpg” alt=”Pulpit rock” width=”304”height=”228”&gt; 加载页面时，要注意插入页面图像的路径，如果不能正确设置图像的位置，浏览器无法加载图片，图像标签就会显示一个破碎的图片。 表格表格由&lt;table&gt;标签来定义。每个表格均有若干行（由&lt;tr&gt;标签定义），每行被分割为若干单元格（由&lt;td&gt;标签定义）。字母td指表格数据（tabledata），即数据单元格的内容。数据单元格可以包含文本、图片、列表、段落、表单、水平线、表格等等。 列表等不赘述。 区块大多数HTML元素被定义为块级元素或内联元素。 ——块级元素在浏览器显示时，通常会以新行来开始（和结束）。 HTML&lt;div&gt;元素是块级元素，它可用于组合其他HTML元素的容器。 &lt;div&gt;元素没有特定的含义。除此之外，由于它属于块级元素，浏览器会在其前后显示折行。如果与CSS一同使用，&lt;div&gt;元素可用于对大的内容块设置样式属性。&lt;div&gt;元素的另一个常见的用途是文档布局。 ——内联元素在显示时通常不会以新行开始。 HTML&lt;span&gt;元素是内联元素，可用作文本的容器，&lt;span&gt;元素也没有特定的含义。 当与CSS一同使用时，&lt;span&gt;元素可用于为部分文本设置样式属性。 布局网页布局对改善网站的外观非常重要。 大多数网站可以使用&lt;div&gt;或者&lt;table&gt;元素来创建多列。CSS用于对元素进行定位，或者为页面创建背景以及色彩丰富的外观。 使用CSS最大的好处是，如果把CSS代码存放到外部样式表中，那么站点会更易于维护。通过编辑单一的文件，就可以改变所有页面的布局。 表单HTML 表单用于收集不同类型的用户输入。 表单是一个包含表单元素的区域。表单元素是允许用户在表单中输入内容,比如：文本域(textarea)、下拉列表、单选框(radio-buttons)、复选框(checkboxes)等等。表单使用表单标签&lt;form&gt;来设置。 文本域通过&lt;inputtype=”text”&gt;标签来设定，当用户要在表单中键入字母、数字等内容时，就会用到文本域。 密码字段通过标签&lt;input type=”password”&gt;来定义。 &lt;inputtype=”radio”&gt;标签定义了表单单选框选项。可以设置以下几个属性：value、name、checked。 &lt;inputtype=”checkbox”&gt;定义了复选框。用户需要从若干给定的选择中选取一个或若干选项。 &lt;inputtype=”submit”&gt;定义了提交按钮。当用户单击确认按钮时，表单的内容会被传送到另一个文件。表单的动作属性定义了目的文件的文件名。由动作属性定义的这个文件通常会对接收到的输入数据进行相关的处理。 此外还有下拉列表选项、计算结果等。 框架通过使用框架，可以在同一个浏览器窗口中显示不止一个页面。 iframe语法: &lt;iframesrc=”URL”&gt;&lt;/iframe&gt; 该URL指向不同的网页。 颜色HTML颜色由一个十六进制符号来定义，这个符号由红色、绿色和蓝色的值组成（RGB）。 每种颜色的最小值是0（十六进制：#00）。最大值是255（十六进制：#FF）。 RGBA的意思是（Red-Green-Blue-Alpha）它是在RGB上扩展包括了“alpha”通道，运行对颜色值设置透明度。 141个颜色名称是在HTML和CSS颜色规范定义的（17标准颜色，再加124）。 脚本JavaScript使HTML页面具有更强的动态和交互性。 &lt;script&gt;标签用于定义客户端脚本，比如JavaScript，其既可包含脚本语句，也可通过src属性指向外部脚本文件。 &lt;noscript&gt;标签提供无法使用脚本时的替代内容，比方在浏览器禁用脚本时，或浏览器不支持客户端脚本时；只有在浏览器不支持脚本或者禁用脚本时，才会显示&lt;noscript&gt;元素中的内容。 字符实体HTML中的预留字符必须被替换为字符实体，以防浏览器误认为它们是标签。 HTML中的常用字符实体是不间断空格(&amp;nbsp;)。浏览器总是会截短HTML页面中的空格。如果在文本中写10个空格，在显示该页面之前，浏览器会删除它们中的9个。如需在页面中增加空格的数量，则需要使用&nbsp;字符实体。 URLURL——统一资源定位器是一个网页地址。 常见的URL Scheme（定义因特网服务的类型）—— Scheme 访问 用于… http 超文本传输协议 以 http:// 开头的普通网页。不加密。 https 安全超文本传输协议 安全网页，加密所有信息交换。 ftp 文件传输协议 用于将文件下载或上传至网站。 file 您计算机上的文件。","tags":[{"name":"HTML","slug":"HTML","permalink":"http://yoursite.com/tags/HTML/"}]},{"title":"leetcode_1","date":"2020-05-21T06:41:24.000Z","path":"2020/05/21/leetcode-1/","text":"1.两数之和 给定一个数组以及一个目标值——在该数组中找出和为目标值的那两个整数，并返回他们的数组下标。 解： 暴力法—— 遍历数组，对于每一个函数x，都再次遍历数组查找是否存在于target-x相等的元素。 两遍哈希表—— Hash表支持以近似恒定的速度查找元素，通过以空间换取速度的方式。使用两次迭代，第一次迭代将每个元素的值和它的索引添加到表中，；第二次迭代检查每个元素所对应的目标元素target-x是否存在于表中。 12345678910111213class Solution &#123;public: vector&lt;int&gt; twoSum(vector&lt;int&gt;&amp; nums, int target) &#123; unordered_map&lt;int,int&gt; m; for(int i = 0; i&lt;nums.size(); i++) m[nums[i]] = i; //向map中添加元素 for(int i = 0; i&lt;nums.size(); i++)&#123; if(m.find(target-nums[i]) != m.end() &amp;&amp; m[target-nums[i]] != i)//如果m中存在对应的键值，且不为i return &#123;i, m[target-nums[i]]&#125;; &#125; return &#123;&#125;; &#125;&#125;; 复杂度暴力法 时间复杂度：O(n2)。对于每一个元素，都需要遍历整个数组来查找是否存在target-x。 空间复杂度：O(1)。 两遍哈希表 时间复杂度：O(n)。把数组遍历了两次，由于哈希表将查找时间缩短到O(1)，所以时间复杂度为O(n)。 空间复杂度：O(n)。所需的额外空间取决于哈希表中存储的元素数量，该表中存储了n个元素。 Tip：HashMap在resize、put的时候消耗了很多时间没有计算在内，但这些其实都属于初始化范畴，在实际开发中，其实是一次性开销。 Java集合类中的Map.containsKey()方法判断Map集合对象中是否包含指定的键名。如果Map集合中包含指定的键名，则返回true，否则返回false。 也去专门去查了hashMap.containsKey()的时间复杂度，使用指针指向数组引用，时间复杂度为O(1)，未命中时，才回去遍历红黑树，时间复杂度为O(n)，如果仔细地挑选哈希函数，在哈希表中进行查找的用时应当被摊销为O(1)。 C++中，在map中查找key为k的元素，返回指向它的迭代器。若k不存在，返回map::end，返回值是一个迭代器，成功返回迭代器指向要查找的元素，失败返回的迭代器指向end。 map unordered_map #include &lt;map&gt; #include &lt;unordered_map&gt; map内部实现了一个红黑树，该结构具有自动排序的功能，因此map内部的所有元素都是有序的，红黑树的效率决定了map的效率。 unordered_map内部实现了一个哈希表，因此其元素的排列顺序是杂乱的，无序的。 红黑树、有序、空间占用率高 哈希表、无序、耗费时间多 对于那些有顺序要求的问题，用map会更高效一些 对于查找问题，unordered_map会更加高效一些","tags":[{"name":"array","slug":"array","permalink":"http://yoursite.com/tags/array/"}]},{"title":"leetcode_167","date":"2020-05-21T03:39:09.000Z","path":"2020/05/21/leetcode-167/","text":"167.两数之和II -输入有序数组 给定一个升序排列的数组以及一个目标值——求数组中的两个元素和为目标值，并按序输出两个元素的下标。 解： 双指针法——分别记录第一个元素和最后一个元素，求和后与target值比较大小，偏大则移动尾指针（值变小），偏小则移动头指针（值变大），等于目标值则按序输出头尾指针。 复杂度时间复杂度：O(n)。每个元素最多被访问一次。 空间复杂度：O(1)。只是用了两个指针。 Tip：vector作为参数的三种传参方式 c++中常用的vector容器作为参数时（为说明问题，用二维vector）： function1(std::vector&lt;std::vector&lt;int&gt; &gt; vec)，传值 function2(std::vector&lt;std::vector&lt;int&gt; &gt;&amp; vec)，传引用 function3(std::vector&lt;std::vector&lt;int&gt; &gt;* vec)，传指针 三种方式对应的调用形式分别为： function1(vec)，传入值 function2(vec)，传入引用 function3(&amp;vec),传入地址 三种方式在函数调用时是否了vector的拷贝构造函数： 会发生拷贝构造 不会发生拷贝构造 不会发生拷贝构造 函数体 函数调用 拷贝构造函数 void 函数名(vector&lt;int&gt; obj); deal( vec ); void 函数名(vector&lt;int&gt;* pobj); deal( &amp;vec ); void 函数名(const vector&lt;int&gt;* pobj); deal( &amp;vec ); 调用时不会调用拷贝构造函数 void 函数名(vector&lt;int&gt;&amp; obj); deal( vec ); void 函数名(const vector&lt;int&gt;&amp; obj); deal( vec ); 调用时会调用拷贝构造函数 *如果需要在函数中对vector容器中数据调换顺序等操作需要是引用传递 1234567vector&lt;int&gt; twoSum(vector&lt;int&gt;&amp; numbers, int target) &#123; //… int low = 0, high = numbers.size() - 1; //… return &#123;low + 1, high + 1&#125;; //…&#125;","tags":[{"name":"array","slug":"array","permalink":"http://yoursite.com/tags/array/"}]},{"title":"leetcode_941","date":"2020-05-20T09:29:15.000Z","path":"2020/05/20/leetcode-941/","text":"941.有效的山脉数组 检查一个数组是否符合山脉数组——数组元素大于等于三个，且存在某中间元素，其前元素值为递增，其后元素值为递减。 解： 按照数组下标扫描即可，判断出峰元素（从1到length-1的前一个），然后检查其后是否递减，判断以及检查中若有相等或者相反变化的部分，则return false。","tags":[{"name":"array","slug":"array","permalink":"http://yoursite.com/tags/array/"}]},{"title":"leetcode_914","date":"2020-05-20T08:43:13.000Z","path":"2020/05/20/leetcode-914/","text":"914.卡牌分组 检查一个数组是否符合分组的规则——可以分成大小一样的若干数组且各个数组中的数字都一样（子数组长度最小为2）。 解： 统计各个数字出现的次数，然后求其是否存在最大公约数大于等于2。 12345678910111213141516//求最大公约数int gcd(int a,int b)&#123; if(b == 0) return a; return gcd(b,a%b);&#125;class Solution &#123;public: bool hasGroupsSizeX(vector\\&lt;int\\&gt;&amp; deck) &#123; int bucket[10000] = &#123;0&#125;; int g = 0; for (int d : deck) bucket[d]++; //基于范围的for循环(C++11) for (int b : bucket) g = gcd(b, g); return g \\&gt;= 2; &#125;&#125;; Tip： for 语句允许简单的范围迭代： 1234567891011int my_array[5] = &#123;1, 2, 3, 4, 5&#125;;// 每个数组元素乘于 2for (int &amp;x : my_array)&#123; x *= 2; cout &lt;&lt; x &lt;&lt; endl;&#125;// auto 类型也是 C++11 新标准中的，用来自动获取变量的类型for (auto &amp;x : my_array) &#123; x *= 2; cout &lt;&lt; x &lt;&lt; endl;&#125; 上面for述句的第一部分定义被用来做范围迭代的变量，就像被声明在一般for循环的变量一样，其作用域仅只于循环的范围。而在”:”之后的第二区块，代表将被迭代的范围。","tags":[{"name":"array","slug":"array","permalink":"http://yoursite.com/tags/array/"}]},{"title":"人物塑造-第二真","date":"2020-05-19T08:48:38.000Z","path":"2020/05/19/人物塑造-第二真/","text":"人的认知是片面独立的。 每个人对他人的认定大多源于某个既定影响，然后随着某个契机，这个印象不断完善，人的好奇心，对世界的感官，都在促使这件事的完成。 对这个契机的认知是价值观的体现，人们喜欢把想象中的自己沉浸在其中，用想象中的自己去判断一维的好坏。 是想象中的自己，因为人们对自己的认知偏颇难以避免，这种认知同样是片面的，人们在做决定的时候更多的是内心存在选择后，尝试去反驳和证明，反驳和证明都需要存在，这种公允的，中庸的冷静，在和渴望挂不上钩的时候是必然存在的，渴望存在前和是如此经历被琢磨的。 人们判断他人、事物的时候把想象中的自己带入，而判断的主角和法官都是自己的时候，人们把想象带入，这是更深一层的渴望，如果说上者人们还顾及道德和法律，在判断自己的人生时，人们的思绪更多像个辩论赛，这场辩论的比分则由理性的逻辑和感性的价值观决定了。 人们对自己的认知和对别人的认知是完全不同的存在，本文要讨论的就是对他人的认知。 对他人的认知是把想象中的自己带入去判决一维的正误。 人物的塑造譬如肖像描写，仅仅只是第一印象的加成，在文学艺术作品里，所谓人物塑造栩栩如生是需要后期的那个契机的，人物形象丰满必须要有的过程。 塑造人物的手法套路大多出于经验，很成熟的方法论，然而其内核就是完成对读者的认知引导。成功塑造人物需要第一印象的捏造以及后续的契机设立，这种解构的方式是对塑造手法的总结。 说回人们对他人的认知，人的内在逻辑其实是单向的，不仅仅是对体验结果的判决，更是对契机引起的变化的一种单向，这就是反差存在的逻辑。 被成功塑造的恶人，在肖像方面往往是文质彬彬甚至美轮美奂的，其恶当然不只是源于人们对他后续行径的一种价值观判决，更多的，是一种反差的存在，人们的内在逻辑简单化，一者，判决的理智会被这种曲线的填满，人们更倾向于坚信后来被说服的事情，这是源于对后悔的习性，轻车熟路的悔不当初并拍案叫绝；二者是对他人认知的成长判决的简单性，这种判决源于其反差的方向，和肖像的相对方向，这就是人们心中的预设期望。 预设期望源于对第一印象的判决，沉浸式判决加以经验，让肖像在人心里留下一个正或负的分数，而后的契机成长，如果正数的正向成长，人们会在逻辑上表示，哦，果然是这样，这就是毫无新意的普通好人或者坏人，但如果是负数的正向成长，那会给人以冲击，所谓丰满，就是让人们意识到自己的认知错误，人们感觉到成长，感官甚至人生层面上的丰满。 对于好人的预设是一样的，瑕疵感为后来的正向成长加分的，除了真实的不完美，更多的和负数的正面成长的逻辑相似，人们倾向于相信第二个真理。当然也可以简单理解为经验，譬如欲扬先抑或者是巴黎圣母院中的克洛德。 第二个真理的说服力是一个很强大的存在。 颠覆给人一种辩证的真实感，世界并不是非黑即白的，人物的塑造当然不只是为了正面这正误的共生性，更多的还是去引导这种逻辑，操控观者的认知过程，没有影视作品会想要用负数印象加一个正向成长来塑造负面形象的，即使这种负面形象是一种复杂的，难判定好与坏的人物形象，作品也会有偏颇，有初衷与结果。 第二个真理是引导思维认知的重要理论依据。","tags":[{"name":"随笔","slug":"随笔","permalink":"http://yoursite.com/tags/%E9%9A%8F%E7%AC%94/"}]},{"title":"lu","date":"2020-04-05T07:48:58.000Z","path":"2020/04/05/lu/","text":"热爱","tags":[{"name":"随笔","slug":"随笔","permalink":"http://yoursite.com/tags/%E9%9A%8F%E7%AC%94/"}]},{"title":"x","date":"2020-04-05T07:48:18.000Z","path":"2020/04/05/x/","text":"Practice in individual leetcode Three questions per article per day Tags and knowledge extension are important algorithm According to leetcode, summarize the application of various classical algorithms A single article to tabulate various algorithms python Grammar and application C++ Grammar and application artificial intelligence Scipy-python Sklearm-python Deep Learning(to realize machine learning) Machine learning taught by Wu enda Neural network(after the fifth lesson) (by 3Blue1Brow) Deep learning(a flower color book) by Ian Goodfellow Sequence modeling linux operation and maintenance development bottom layer","tags":[{"name":"x","slug":"x","permalink":"http://yoursite.com/tags/x/"}]}]