[{"title":"独居的灵魂","date":"2020-09-25T02:43:39.000Z","path":"2020/09/25/独居的灵魂/","text":"wait. 独居的某夜里我喝了一口肉体刺鼻的温热在口腔中爆炸微醺的灵魂在狭窄的黑里碰撞 漂移 有人叫作床的东西是肉体的容器拾起人海里我一滴滴填满这里在关键时刻浇灭着火的书籍 即使没有这容器肉体也安然的在这里几平米的徒壁肉体在空调机下蒸发依附于墙面的沟壑 那扇窗啊是为了抵挡雨滴肉体支离破碎时裸露的灵魂会随着窗外流入山河星辰里 良夜的始末肉体也算安分守己它和它都不提及灵魂昨晚的离家出走因为今天它还要好好工作好好学习","tags":[{"name":"x","slug":"x","permalink":"http://yoursite.com/tags/x/"}]},{"title":"朋友们","date":"2020-08-18T05:22:52.000Z","path":"2020/08/18/朋友们/","text":"wait. 我常常和他们对话侧耳专心地听他们呢喃关于他们的温度气味和颜色他们大概是一个个的有些相似也可能是一只在这时空里千变万化再与我相遇温热和刺骨清漓和粘腻钻进我的身体里或者喧哗着又或是无声息我无意打搅无需拥抱我的朋友们不管在荒漠里还是山涧旁高楼的三十三层亦或是姥姥的旧床单上你们总在我身旁当我寂静你们就靠近我提醒我今天我想问问你们你们到底是阳光雨露微风还是时光","tags":[{"name":"x","slug":"x","permalink":"http://yoursite.com/tags/x/"}]},{"title":"灰色","date":"2020-08-14T11:51:55.000Z","path":"2020/08/14/灰色/","text":"wait. 刺眼的灰色啊跟随着我趁我宿醉闯进我的世界我的领地可是光也一样闪耀着就算有黑夜她也从未熄灭在我的脑海中四季都在跳动不止灰色啊我与你就此告别了决意不再重复我要拥抱生活拥抱鲜活的跳动的心脏赤裸着感受血液的奔涌和温润的皮肤灰色啊你大可以继续呢喃可以翻涌可以扑向我但你自然不会开花结果我是有光的树我是有血有肉的生活是锋利的苟且不是安静的灰色","tags":[{"name":"x","slug":"x","permalink":"http://yoursite.com/tags/x/"}]},{"title":"一只梦","date":"2020-08-14T11:51:40.000Z","path":"2020/08/14/一只梦/","text":"wait. 独居的某夜里我喝了一口肉体刺鼻的温热在口腔中爆炸微醺的灵魂在狭窄的黑里碰撞 漂移 有人叫作床的东西是肉体的容器拾起人海里我一滴滴填满这里在关键时刻浇灭着火的书籍 即使没有这容器肉体也安然的在这里几平米的徒壁肉体在空调机下蒸发依附于墙面的沟壑 那扇窗啊是为了抵挡雨滴肉体支离破碎时裸露的灵魂会随着窗外流入山河星辰里 良夜的始末肉体也算安分守己它和它都不提及灵魂昨晚的离家出走因为今天它还要好好工作好好学习","tags":[{"name":"x","slug":"x","permalink":"http://yoursite.com/tags/x/"}]},{"title":"病","date":"2020-08-14T11:51:20.000Z","path":"2020/08/14/病/","text":"wait. 灵魂的病无药可救医者从不仁慈只会喧嚣着讨伐病人是异己者 活着没有放弃是为了找一个同病相怜为此不惜假装成另一种病人一瘸一拐的顺着人流挪动 被欺骗者自认病入膏肓沮丧着宁可苟活也不再期盼什么 被谩骂者拥抱着自己的病温柔地诉说能与谁的绝症相拥入墓也会被谁歌颂 我来到这世上从不为了医治什么寻得一位生病的正常人或是我的偏见也是我的自豪 我的良医啊你不要放弃我我愿意为你痊愈愿意携你沉默耳语，挪动或是奔跑","tags":[{"name":"x","slug":"x","permalink":"http://yoursite.com/tags/x/"}]},{"title":"spring入门","date":"2020-08-11T05:54:36.000Z","path":"2020/08/11/spring入门/","text":"Spring Boot，Spring Cloud，Spring Cloud Data Flow。Spring Cloud Data Flow又可以分为Spring Integration和Spring Batch两部分。 针对Spring的学习，第一步就是理解IoC和AOP；这是基础；然后学习SpringMVC,其实还是Java EE开发，如果要理解这个框架，就要知道没有这个框架之前，使用的是什么技术。 Spring：SE/EE开发的一站式框架。 一站式框架：有EE开发的每一层解决方案。 WEB层 SpringMVC Service层 Spring的Bean管理，Spring声明式事务 DAO层 Spring的Jdbc模板，Spring的ORM模块 IOC即控制反转——把本应由程序员创建和维护的bean交给spring管理。就是对象的创建交给外部容器（IOC容器）完成。Spring使用注入依赖来实现对象之间的依赖关系。由于控制反转，资源管理更集中，易于对资源的合理配置，同时降低了使用资源双方的依赖度（耦合度）。可以理解为，交易（对象的创建与销毁）托管给第三方（IOC容器），可以变得更可靠灵活。 IoC和DI其实是同一个概念的不同角度描述，DI相对IoC而言，明确描述了“被注入对象依赖IoC容器配置依赖对象” AOP即面向切面编程——解决一些系统交叉业务的织入，如日志事务。一个交叉业务就是切入系统的一个方面，为了交叉业务的编程问题，AOP把交叉业务模块化，做法是把切面代码移动到原始方法周围——把方法内部的交叉业务代码写在方法调用前后。 关于AOP的底层原理：动态代理其实就是代理对象调用目标对象的同名方法，并在调用前后加增强代码。 模块化就是把交叉业务的代码放在一个切面上，作为一个抽象的切面类，以方便管理。 AOP能够将那些与业务无关，却为业务模块所共同调用的逻辑或责任（例如事务处理、日志管理、权限控制等）封装起来，便于减少系统的重复代码，降低模块间的耦合度，并有利于未来的可拓展性和可维护性。 在我们的控制器中注入service层对象，Spring依赖注入的对象并不一定是我们自己写的类的实例，也可能是我们UserServiceImpl的代理对象。 如果给UserServiceImpl加了@Transactional 注解，Spring读取到这个注解，便知道我们要使用事务。而我们编写的UserService类中并没有包含任何事务相关的代码。这里便发生了动态代理。（如果不加@Transactional，那么Controller层注入的就是普通的userServiceImpl，而加了以后返回的实际是代理对象） 有一种观点是把spring看作一种容器，但spring不只是一种map，真正存单例对象的map只是factorybean的的一个字段。 就拿ApplicationContext来讲，它也实现了BeanFactory接口，但是作为容器，其实它是用来包含各种各样的组件的，而不是存bean。虽然applicationcontext实现（包括）了beanfactory，但这两者（都是接口）也都有其自己的子类，如注解驱动开发时，Spring中最关键的就是AnnotationConfigApplicationContext和DefaultListableBeanFactory。 容器的概念在java中你最熟悉的莫过于Tomcat了，它正是一个运行Servlet的web容器，而Spring要想实现依赖注入功能，就离不开对象生产的容器——如果没有容器负责对象的创建管理，你的程序代码只是喊要对象了，Spring也无处给你啊。实际上，容器是Spring框架实现功能的核心，容器不只是帮我们创建了对象那么简单，它负责了对象整个的生命周期的管理——创建、装配、销毁。 IOC容器可以归为两大类，一是bean工厂（beanfactory，功能简单），二是应用上下文（applicationcontext，功能强大） Spring是通过后置处理器（在applicationcontext中实现）来实现事务代码的织入。后置处理器是spring的扩展点之一，类型如下： 扩展接口 作用 Beanfactorypostprocess 处理bean前对beanfactory进行预处理 Beandefinitionregistrypostprocess 可以添加自定义的bean Beanpostprocess 对初始化前后的bean进行处理 Applicationcontextaware 可以获得applicationcontext以及其bean Initializingbean Bean创建完成且所有属性注入完成后执行 Disposablebean 在bean销毁前执行 Applicationlistener 监听发生的应用事件 后置处理器——实现一个接口，某些相关方法就会被调用并传入一个对象，其实明面上是一个接口，但该接口包含着bean的初始化创建和各种支持的方法，随着接口调用，spring框架会判断调用该接口中有关的各种方法和操作。 这就是控制反转样式。 后置处理器是接口的核心。 ApplicationContext保存了ioc的整个应用上下文，可以通过其中的beanfactory获取到任意到bean； BeanFactory主要的作用是根据beandefinition来创建具体的bean； BeanWrapper是对Bean的包装，一般情况下是在springioc内部使用，提供了访问bean的属性值、属性编辑器注册、类型转换等功能，方便ioc容器用统一的方式来访问bean的属性； FactoryBean通过getObject方法返回实际的bean对象，例如motan框架中referer对service的动态代理就是通过FactoryBean来实现的。 Spring首先会扫描解析指定位置的所有的类得到Resources，然后依照TypeFilter和@Conditional注解决定是否将这个类解析为BeanDefinition，稍后再把一个个BeanDefinition取出实例化成Bean（BeanDefinition是bean在spring中的描述，有了BeanDefinition我们就可以创建Bean） BeanDefiniton向上分类： BeanMetadataElement接口：BeanDefinition元数据，返回该Bean的来源 AttributeAccessor接口：提供对BeanDefinition属性操作能力 Bean是如何在容器中加载创建的： Refresh方法中，刷新容器，设置容器参数性质，obtainfreshbeanfactory方法设置了bean的加载——先销毁已存在的beanfactory容器，然后创建新的容器，设置id和定制化属性（如bean的定义是否可覆盖、是否允许循环依赖），加载bean的定义进入beandefinition容器中，然后是对容器做配置，并读取配置文件以及加载（通过for循环全部读取加载并返回数量），把配置文件加载为document类文件并转化为element，判断element是否为bean的标签并注册beandefinition，然后对beandefinition进行解析，如果是默认标签就直接解析（多个ifelse语句判断），其他方法解析定制化标签，解析后设置描述性信息，对beandefinition注册进容器，注册后即可以使用beandefinition进行实例化，在方法finishbeanfactoryinglaitons中，判断是否为factorybean中的，如果是，要判断是加载器本身还是其创建的bean，如果是factorybean就把bean前面的and去掉，getsingleton方法的三级缓存是为了解决循环依赖，若缓存中不为空，仍判断是普通bean还是factorybean，如果是后者，要返回的是factorybean要创建的bean，如果自己没有bean就去其父母容器去找，如果bean是单例的（单例bean与原型bean，singletonScope与prototypeScope，singletonScope，即单例Bean，顾名思义具有单例模式的所有特性，在spring容器里面只会初始化出一个bean实例，存于缓存中。后续的请求都公用这个对象。最简单的创建单例bean的方式，就是直接在类名上面加@Service注解。prototypeScope，即原型Bean，每次请求时都会创建新的bean实例直接使用。创建原型Bean，需要显示指定scope属性，相比原例bean，单例bean可以减少系统新建实例浪费的资源，jvm垃圾回收，并且容易在缓存中快速找到bean，但其缺点为在并发环境下的线程不安全）。 第1步：调用bean的构造方法创建bean； 第2步：通过反射调用setter方法进行属性的依赖注入； 第3步：如果实现BeanNameAware接口的话，会设置bean的name； 第4步：如果实现了BeanFactoryAware，会把bean factory设置给bean； 第5步：如果实现了ApplicationContextAware，会给bean设置ApplictionContext； 第6步：如果实现了BeanPostProcessor接口，则执行前置处理方法； 第7步：实现了InitializingBean接口的话，执行afterPropertiesSet方法； 第8步：执行自定义的init方法； 第9步：执行BeanPostProcessor接口的后置处理方法。这时，就完成了bean的创建过程。在使用完bean需要销毁时，会先执行DisposableBean接口的destroy方法，然后在执行自定义的destroy方法。 配置对象的方法大致可以分为三种——使用XML文件配置、使用注释来配置、使用JavaConfig来配置（现在用的比较多的是注解和javaConfig的形式配置）。 spring4中的jar包一共有20个 Core部分包含4个模块—— spring-core：依赖注入IoC与DI的最基本实现 spring-beans：Bean工厂与bean的装配 spring-context：spring的context上下文即IoC容器 spring-expression：spring表达式语言 AOP部分包含4个模块—— spring-aop：面向切面编程 spring-aspects：集成AspectJ spring-instrument：提供一些类级的工具支持和ClassLoader级的实现，用于服务器 spring-instrument-tomcat：针对tomcat的instrument实现 Data Access/Integration部分包含5个模块—— spring-jdbc：jdbc的支持 spring-tx：事务控制 spring-orm：对象关系映射，集成orm框架 spring-oxm：对象xml映射 spring-jms：java消息服务 Web部分包含3个模块—— spring-web：基础web功能，如文件上传 spring-webmvc：mvc实现 spring-webmvc-portlet：基于portlet的mvc实现 spring-websocket：为web应用提供的高效通信工具 Test部分一个模块—— spring-test：spring测试，提供junit与mock测试功能 剩下的包是—— spring-messaging：用于构建基于消息的应用程序 spring-context-support：spring额外支持包，比如邮件服务、视图解析等","tags":[{"name":"spring","slug":"spring","permalink":"http://yoursite.com/tags/spring/"}]},{"title":"TCP/IP","date":"2020-07-29T12:50:55.000Z","path":"2020/07/29/TCP-IP/","text":"TCP/IP 为了灵活，方便实习和维护，且更标准化，计算机网络使用了分层结构—— 标准化组织ISO制定了七层的互联基本参考模型OSI/RM，但较为复杂且难以实现；业界约定的四层的TCP/IP体系结构（实际应用），它包含应用层，运输层，网际层和网络接口层，为了清晰完善，综合OSI和TCP/IP的优点，采用一种只有五层协议的体系结构来进行分析学习。 TCP/IP OSI 五层协议 四层 七层 五层 应用层、运输层、网际层和网络接口层 应用层、表示层、会话层、运输层、网络层、数据链路层、物理层 应用层、运输层、网络层，数据链路层和物理层 TCP（传输控制协议）和IP（网际协议）是最先定义的两个核心协议，所以才统称为TCP/IP协议族。 下面逐层解析运输层—— 负责向两台主机进程之间的通信提供通用的数据传输服务。应用进程利用该服务传送应用层报文。主要使用以下协议：传输控制协议-TCP-提供面向连接的，可靠的数据传输服务；用户数据协议-UDP-提供无连接的，不保证数据传输的可靠性。 UDP TCP 无连接 面向连接 不可靠传输-无流控和拥控 可靠传输-有流控和拥控 可多对多 只能一对一 报文 字节流 首部8bit 首部20bit-60bit 适用于实时如视频电话 适用于可靠如文件传输 相应的应用层协议—— 应用进程间的通信和交互的规则。对于不同的网络应用需要不同的应用层协议。在互联网中应用层协议很多，如域名系统DNS，支持万维网应用的HTTP协议，支持电子邮件的SMTP协议等等。 运行在TCP协议上的协议： HTTP（Hypertext Transfer Protocol，超文本传输协议），主要用于普通浏览。 HTTPS（HTTP over SSL，安全超文本传输协议），HTTP协议的安全版本。 FTP（File Transfer Protocol，文件传输协议），用于文件传输。 POP3（Post Office Protocol, version 3，邮局协议），收邮件用。 SMTP（Simple Mail Transfer Protocol，简单邮件传输协议），用来发送电子邮件。 TELNET（Teletype over theNetwork，网络电传），通过一个终端（terminal）登陆到网络。 SSH（Secure Shell，用于替代安全性差的TELNET），用于加密安全登陆用。 运行在UDP协议上的协议： BOOTP（Boot Protocol，启动协议），应用于无盘设备。 NTP（Network Time Protocol，网络时间协议），用于网络同步。 DHCP（Dynamic Host Configuration Protocol，动态主机配置协议），动态配置IP地址。 运行在TCP和UDP协议上： DNS（Domain Name Service，域名服务），用于完成地址查找，邮件转发等工作。 网络层—— 选择合适的网间路由和交换结点，确保计算机通信的数据及时传送。在TCP/IP体系结构中，由于网络层使用IP协议，因此分组也叫IP数据报，简称数据报。互联网使用的网络层协议是无连接的网际协议（IntertPrococol）和许多路由选择协议。网络层也叫做网际层或IP层。 数据链路层—— 在两个相邻节点之间传送数据时，数据链路层将网络层交下来的 IP数据报组装成帧，在两个相邻节点间的链路上传送帧。每一帧包括数据和必要的控制信息（如同步信息，地址信息，差错控制等）。在接收数据时，控制信息使接收端能够知道一个帧从哪个比特开始和到哪个比特结束。 物理层—— 实现相邻计算机节点之间比特流的透明传送，尽可能屏蔽掉具体传输介质和物理设备的差异。在物理层上所传送的数据单位是比特，“透明传送比特流”表示经实际电路传送后的比特流没有发生变化，对传送的比特流来说，这个电路好像是看不见的。 发送和接受的过程是增加头部和删除头部的过程。 发送时，应用层是HTTP数据，到传输层加TCP首部，到网络层加IP头部，到链路层加以太网头部；接受时反之，逐层删除头部。 三次握手四次挥手TCP头部结构： 序号：seq序号，占32位，用来标识从TCP源端向目的端发送的字节流，发起方发送数据时对此进行标记。 确认序号：ack序号，占32位，只有ACK标志位为1时，确认序号字段才有效，ack=seq+1。 标志位：共6个，即URG（紧急指针有效）、ACK（确认序号有效）、PSH（优先交给应用层）、RST（重置连接）、SYN（发起新连接）、FIN（释放连接）等。 三次握手建立连接：第一次确认了客户端有发送能力(SYN=1)，第二次确认了服务端有发送和接收能力(SYN=1,ACK=1)，第三次确定了客户端有接收能力(ACK=1)。 四次挥手关闭连接：第一次客户端停止发送(FIN=1)，第二次服务端停止接受(ACK=1)，第三次服务端停止发送(FIN=1,ACK=1)，第四次客户端停止接受(ACK=1)。 客户端发出第四次挥手的确认报文后要等2*MSL（报文段最大生存时间）的时间才能释放TCP连接，是考虑到第四次挥手的报文丢失（丢包），服务端没收到确认ack报文（收到代表同意客户端停止接受）就会重发第三次挥手的报文，这样报文来回最长时间即为2MSL，这样就可以确定第四次挥手的报文被客户端收到了。 已连接的TCP，客户端故障，TCP有保活计时器，每收到一次客户端的请求后都会重新复位这个计时器，若计时器两小时内还没有收到客户端的任何数据，服务器就会发送一个探测报文段，以后每隔75秒钟发送一次。若一连发送10个探测报文仍然没反应，服务器就认为客户端出了故障，接着就关闭连接。 长连接和短连接的产生在于 Client 和 Server采取的关闭策略。短连接一般只在C和S间传递一次读写操作，随后C和S都可以发起close操作，便于管理，且存在连接都是有用的；长连接不会自动关闭，连接过多会使S压力过大，因此S通过某些策略进行关闭连接，如限制客户端最大连接数。 TCP存在粘包、拆包，因为UDP是基于报文发送的，首部采用16bit来指出UDP的报文长度，而TCP基于字节流，数据大小不等且无边界，所以会发生粘包、拆包的问题。 粘包可能是两个数据包完全被接收端当作一个，拆包则是当作两个数据包，但其中间边界分割出错。 具体原因有：要发送的数据大于 TCP发送缓冲区剩余空间大小，将会发生拆包；待发送数据大于 MSS（最大报文长度），TCP在传输前将进行拆包；要发送的数据小于 TCP 发送缓冲区的大小，TCP将多次写入缓冲区的数据一次发送出去，将会发生粘包；接收数据端的应用层没有及时读取接收缓冲区中的数据，将发生粘包； 解决办法（只能通过上层的应用协议栈设计来解决）： 消息定长：发送端将每个数据包封装为固定长度（不够的可以通过补 0填充），这样接收端每次接收缓冲区中读取固定长度的数据就自然而然的把每个数据包拆分开来。 设置消息边界：服务端从网络流中按消息边界分离出消息内容。在包尾增加回车换行符进行分割，例如FTP 协议。 将消息分为消息头和消息体：消息头中包含表示消息总长度（或者消息体长度）的字段。 更复杂的应用层协议比如 Netty 中实现的一些协议都对粘包、拆包做了很好的处理。 TCP使用超时重传来实现可靠传输：如果一个已经发送的报文段在超时时间（略大于RTTs（=(1-a)*RTTs+a*RTT，RTTs为加权平均往返时间））内没有收到确认，那么就重传这个报文段。 TCP滑动窗口，以便客户端、服务端控制发送和接受速率。 TCP流量控制，控制发送方发送速率，接收方发送的确认报文中的窗口字段可以用来控制发送方窗口大小，从而影响发送方的发送速率。 为了避免此问题的产生，发送端主机会时不时的发送一个叫做窗口探测的数据段，此数据段仅包含一个字节来获取最新的窗口大小信息。 TCP拥塞控制，主要通过慢开始、拥塞避免、快重传、快恢复 四个算法来控制。 《TCP/IP详解 卷1:协议》：TCP状态变迁图 HTTPHTTP是两点间传输文字、图片、音频、视频等超文本数据的约定和规范。运行在TCP连接上，无证书不加密，客服两端无法互相验证。 HTTPS运行在SSL上，SSL运行在TCP上，有加密，需证书，安全性更强。 HTTP协议中定义了浏览器和服务器进行交互的不同方法，基本方法有4种，分别是GET，POST，PUT，DELETE。分别为浏览器对服务器资源的查，改，增，删。 就发送的数据的安全性，分为对称加密（快、不安全）和非对称加密（慢、安全）。 对称密钥加密是指加密和解密使用同一个密钥的方式。 非对称加密是指发送密文的一方使用对方的公钥进行加密处理，对方接收到加密信息后，使用自己的私钥进行解密。 HTTP2在HTTP的基础上中引入了多路复用的技术，从而解决了同一个域名下的请求数量的限制问题，实现了同一个TCP，传输所有请求。 Cookie和Session都是方便服务器来辨认用户身份的小文件（单个cookie小于4k），cookie数据存放在客户端上，安全性较差，session数据放在服务器上，安全性相对更高，但存放在服务器上会占用服务器性能，一般使用cookie。 Token的定义：Token是服务端生成的一串字符串，以作客户端进行请求的一个令牌，当第一次登录后，服务器生成一个Token便将此Token返回给客户端，以后客户端只需带上这个Token前来请求数据即可，无需再次带上用户名和密码。 使用Token的目的：Token的目的是为了减轻服务器的压力，减少频繁的查询数据库，使服务器更加高效。 Token是在服务端产生的。如果前端使用用户名/密码向服务端请求认证，服务端认证成功，那么在服务端会返回Token给前端。前端可以在每次请求的时候带上Token证明自己的合法地位 禁用Cookie会导致得不到Session，因为Session是用SessionID来确定当前对话所对应的服务器Session，而SessionID是通过Cookie来传递的，禁用Cookie相当于失去了SessionID，也就得不到Session了。除非通过手动传递或者保存Session ID。 下次学习总结TCP的效率优化。","tags":[{"name":"TCP","slug":"TCP","permalink":"http://yoursite.com/tags/TCP/"}]},{"title":"leetcode-581","date":"2020-07-22T14:40:58.000Z","path":"2020/07/22/leetcode-581/","text":"581.最短无序连续子数组 给定一个整数数组（可能含重复元素），你需要寻找一个连续的子数组，如果对这个子数组进行升序排序，那么整个数组都会变为升序排序。找到的子数组应是最短的，请输出它的长度。 解： 这题经典。 第一反映是动态的检查子数组的左右距离，重复思考，觉得可以对移动的元素轨迹进行标红，但如果有重复的部分也无法处理；最粗暴的方法，就是把数组排序，然后对比不同的元素，从而确定最小子数组长度。 暴力解法： 遍历每一个元素，每次都尝试在正确顺序的数组中找到其位置，若真的找到了，则标记其位置作为无序数组的边界，然后每次更新。时间复杂度：O(n^2)。 排序法： 直接对原数组进行排序，然后查询最左和最右的不匹配元素的位置，即为最短无序子数组的边界。快排的时间/空间复杂度：O(nlogn)/O(n)。 最小无序数组特征法： 无序子数组中最小元素的正确位置可以决定左边界，最大元素的正确位置可以决定右边界。先进行正序遍历找到逆序部分的值标记为min，同样进行逆序遍历找到逆序部分的值标记为max，遍历过程中不断更新，然后再遍历两遍，找到min和max应该放置的位置，这两个位置就是最小无序子数组的左右边界。时间复杂度：O(n)，使用了4个O(n)的循环。 栈解法： 以左边界的确定为例，遍历数组，向栈内压入元素的同时，检查是否逆序，若逆序，则进行出栈操作，直到栈顶大于逆序的元素，找到了该逆序元素应该放置的位置，继续记录，重复操作，直到栈空，找到的下标最小值就是左边界。玩转栈才是精髓。 对于没有清晰思路的题目，要寻找解题关键点的特征，比如该题，给出一个数组，要找一个最短的无序子数组（非升序），那么该题的关键就是“最小无序数组”的特征，无序指非升序，则头部一定是逆序的，即降序，则可以通过从数组尾部开始遍历，找到最左的逆序的元素组即可，尾部的边界同样的，在一个升序的主旋律里应该是降序的，同样可以通过从头部遍历来找到最右边的逆序元素组。所以最小无序数组，相对于整体升序的情况下，其特点就是头部元素相对与最靠近头部的最小元素是降序，尾部同理。 123456789101112131415161718192021class Solution &#123; public int findUnsortedSubarray(int[] nums) &#123; int len = nums.length; int max = nums[0]; int min = nums[len-1]; int l = 0, r = -1; for(int i=0;i&lt;len;i++)&#123; if(max&gt;nums[i])&#123; r = i; &#125;else&#123; max = nums[i]; &#125; if(min&lt;nums[len-i-1])&#123; l = len-i-1; &#125;else&#123; min = nums[len-i-1]; &#125; &#125; return r-l+1; &#125;&#125; 本解法的思路以最小无序数组的左边界为例来解释：从整个数组的尾部开始向前遍历，维护一个最小值min和一个左边界下标，当移动指针所到的下一个元素比min小，说明该部分是正序（降序）的，则更新min的值，若遇到的下一个元素比min大，说明该部分逆序，则更新左边界下标，但不更新min值，继续移动以找到min的当前元素应该放置的最终位置（比min大的元素左一个位置），则找到了最终的最小无序子数组的左边界。 复杂度 最优解：时间复杂度：O(N)；空间复杂度：O(1) Tip： 寻找最短无序连续子数组！ 为实现数组升序排列，以最小无序数组的左边界为例来解释： 从整个数组的尾部开始向前遍历，维护一个最小值min和一个左边界下标，当移动指针所到的下一个元素比min小，说明该部分是正序（降序）的，则更新min的值，若遇到的下一个元素比min大，说明该部分逆序，则更新左边界下标，但不更新min值，继续移动以找到min的当前元素应该放置的最终位置（比min大的元素左一个位置），则找到了最终的最小无序子数组的左边界。 最短无序子数组（原数组升序）的本质就是：左边界即为从右到左中发生逆序元素中的最小元素应该放置的位置，右边界同理。遍历中，通过不断更新最小值来找到最小逆序元素，遇到比该元素大的才进行记录和更新边界值。","tags":[{"name":"array","slug":"array","permalink":"http://yoursite.com/tags/array/"}]},{"title":"leetcode-1470","date":"2020-07-20T13:29:38.000Z","path":"2020/07/20/leetcode-1470/","text":"1470.重新排列数组 给定一个数组 nums ，数组中有 2n 个元素，按 [x1,x2,…,xn,y1,y2,…,yn]的格式排列。要求将数组按 [x1,y1,x2,y2,…,xn,yn]格式重新排列，返回重排后的数组。 解： 这题的题意很好理解，就是给定一个偶数项的数组，把后半部分和前半部分交叉放置后重新输出即可，时间复杂度O(n)很好实现，最简单的思路，创建一个新数组，一次循环把1-n和n-2n位置的元素分别放入新数组，新数组下标一次循环种两次自增即可。 没有想到的比较巧妙的方法是空间复杂度为O(n)的解法，答主注意到了题目限制的元素的取值范围为1-1000之间且元素个数也小于1000，解法如下： 一是通过位计算来节省空间，因为单个元素小于1000，意味着一个元素只占据了 10 个bit（2^10 - 1 = 1023 &gt; 1000），而一个 int 有 32 个 bit。 在下面的代码中，每一个 nums[i] 的最低的十个 bit（0-9 位），我们用来存储原来nums[i] 的数字；再往前的十个 bit（10-19位），我们用来存储重新排列后正确的数字是什么。在循环中，我们每次首先计算 nums[i]对应的重新排列后的索引 j，之后，取 nums[i] 的低 10 位（nums[i] &amp; 1023），即nums[i] 的原始信息，把他放到 nums[j] 的高十位上。最后，每个元素都取高 10位的信息(e &gt;&gt; 10)，即是答案。 123456789101112class Solution &#123;public: vector&lt;int&gt; shuffle(vector&lt;int&gt;&amp; nums, int n) &#123; for(int i = 0; i &lt; 2 * n; i ++)&#123; int j = i &lt; n ? 2 * i : 2 * (i - n) + 1; nums[j] |= (nums[i] &amp; 1023) &lt;&lt; 10; &#125; for(int&amp; e: nums) e &gt;&gt;= 10; return nums; &#125;&#125;; 第二种方法的思想要反复学习巩固——双状态标记顺位遍历链式放置原地排序法！ 为了原地排序，这是一种很经典的方法，具体的思想是这样的：使用两种状态的标记，即可实现有规律的原地排序，并且避免覆盖而产生的问题。 本题中刚好数组元素都大于0，则可以选择使用负数来标记已完成排序的元素。以本题为例——外层一个for循环遍历数组，每次判断要处理的元素是否大于0，若大于0，说明该元素还未归位，若小于0，则说明该元素已经处理过并正确放置；具体的处理方法是一个while循环（循环条件为a处元素大于0），当处理元素a时候，计算出a应该放置的位置，并与其交换的同时将其命为相反数（小于0，已放置完毕），然后继续下一轮循环，处理a处的元素（需要维持一个变量来记录a处元素原本的位置，以便进行正确交换放置），直到a处元素变为负数，说明和a位置有关的元素已经都放置完毕，便可以继续下一轮for循环。原地排序的情况下，每个元素只需要处理一次，即每次循环都正确放置了一个元素，所以时间复杂度为O(n)。 12345678910111213141516171819202122232425262728class Solution &#123;public: vector&lt;int&gt; shuffle(vector&lt;int&gt;&amp; nums, int n) &#123; for(int i = 0; i &lt; 2 * n; i ++) if(nums[i] &gt; 0)&#123; // j 描述当前的 nums[i] 对应的索引，初始为 i int j = i; while(nums[i] &gt; 0)&#123; // 计算 j 索引的元素，也就是现在的 nums[i]，应该放置的索引 j = j &lt; n ? 2 * j : 2 * (j - n) + 1; // 把 nums[i] 放置到 j 的位置， // 同时，把 nums[j] 放到 i 的位置，在下一轮循环继续处理 swap(nums[i], nums[j]); // 使用负号标记上，现在 j 位置存储的元素已经是正确的元素了 nums[j] = -nums[j]; &#125; &#125; for(int&amp; e: nums) e = -e; return nums; &#125;&#125;; 推广一下：就是依次检查每个位置，维持一个循环，反复将该位置的元素与其目标位置的元素交换，并进行标记（维持一个变量，每次交换后储存该位置元素原本的位置），直到和该位置有关的交换链上的元素都放置完毕（该位置元素为已放置），则检查下一个位置是否放置完毕，直至遍历结束。该方法的时间复杂度为O(n)，空间复杂度为O(1)。 复杂度 最优解：时间复杂度：O(N)；空间复杂度：O(1) Tip：Java提供的位运算符有：左移( &lt;&lt; )、右移( &gt;&gt; ) 、无符号右移( &gt;&gt;&gt; ) 、位与( &amp; ) 、位或( | )、位非( ~ )、位异或( ^ )，除了位非( ~ )是一元操作符外，其它的都是二元操作符。 双状态标记顺位遍历链式放置原地排序法—— 为了原地排序，这是一种很经典的方法，具体的思想是这样的：使用两种状态的标记，即可实现有规律的原地排序，并且避免覆盖而产生的问题。 就是依次检查每个位置，维持一个循环，反复将该位置的元素与其目标位置的元素交换，并进行标记（维持一个变量，每次交换后储存该位置元素原本的位置），直到和该位置有关的交换链上的元素都放置完毕（该位置元素为已放置），则检查下一个位置是否放置完毕，直至遍历结束。 该方法的时间复杂度为O(n)，空间复杂度为O(1)。","tags":[{"name":"array","slug":"array","permalink":"http://yoursite.com/tags/array/"}]},{"title":"leetcode-905","date":"2020-07-19T12:52:20.000Z","path":"2020/07/19/leetcode-905/","text":"905.按奇偶排序数组 给定一个非负整数数组A，返回一个数组，在该数组中，A的所有偶数元素之后跟着所有奇数元素。你可以返回满足此条件的任何数组作为答案。 解： 这题的标准答案不唯一，所以要追求更好的复杂度情况。 个人的方法（双指针）：对于新建数组的高空间复杂度的方法不做讨论，维护一个指针遍历数组，出现的第一个奇数的位置后停止，同时再维护一个指针，沿着该位置继续移动，若遇到偶数，则与第一个指针所记录的位置的元素进行交换，而后继续移动第一个指针寻找下一个奇数，若第一个奇数后再无偶数，即第二个指针遍历结束也未遇到偶数，则跳出两层循环，算法结束。代码如下： 123456789101112131415161718class Solution &#123; public int[] sortArrayByParity(int[] A) &#123; int i = 0, j = A.length-1; while(j!=i &amp;&amp; i!=A.length-1)&#123; if(A[i]%2 != 0)&#123; while(A[j]%2 != 0 &amp;&amp; j&gt;i)&#123; j--; &#125; int temp = A[i]; A[i] = A[j]; A[j] = temp; &#125; i++; &#125; return A; &#125;&#125; 下面是官方解法：一方面是最简单的，创建新数组，两轮扫描分别按要求放置，时间/空间复杂度都为O(n)；其次可以使用快速排序，直接按照模2的结果排序—— 123456789101112131415161718192021class Solution &#123; public int[] sortArrayByParity(int[] A) &#123; Integer[] B = new Integer[A.length]; for (int t = 0; t &lt; A.length; ++t) B[t] = A[t]; Arrays.sort(B, (a, b) -&gt; Integer.compare(a%2, b%2)); for (int t = 0; t &lt; A.length; ++t) A[t] = B[t]; return A; /* Alternative: return Arrays.stream(A) .boxed() .sorted((a, b) -&gt; Integer.compare(a%2, b%2)) .mapToInt(i -&gt; i) .toArray(); */ &#125;&#125; 然后是重点学习的方法——快排： 维护两个指针i和j，循环保证每刻小于i的变量都是偶数（也就是A[k]%2==0当k&lt;i），所有大于j的都是奇数。 所以，4种情况针对(A[i]%2,A[j]%2)： 如果是(0,1)，那么万事大吉i++并且j–。 如果是(1,0)，那么交换两个元素，然后继续。 如果是(0,0)，那么说明i位置是正确的，只能i++。 如果是(1,1)，那么说明j位置是正确的，只能j–。 通过这4种情况，循环不变量得以维护，并且j-i不断变小。最终就可以得到奇偶有序的数组。 1234567891011121314151617class Solution &#123; public int[] sortArrayByParity(int[] A) &#123; int i = 0, j = A.length - 1; while (i &lt; j) &#123; if (A[i] % 2 &gt; A[j] % 2) &#123; int tmp = A[i]; A[i] = A[j]; A[j] = tmp; &#125; if (A[i] % 2 == 0) i++; if (A[j] % 2 == 1) j--; &#125; return A; &#125;&#125; 复杂度 最佳方法：时间复杂度：O(N)；空间复杂度：O(1)，个人方法和官方的第三种思路类似。 Tip：Java 中数组的排序以及合并等问题常常用到双指针法可以实现低时间/空间复杂度。 判断奇偶： 判断奇数：不可以通过a%2==1来判断，因为负奇数对2取余的结果为-1；可以使用a%2!=0来判断。 此外，可以使用位操作，性能更高，即通过(a&amp;1)==1来判断是否为奇数。 判断偶数：在Java中0%2的结果是商0余0，通过a%2==0来判断即可。 在while循环中，如果涉及到数组下标，而且循环体中有指针的自增或者自减，则一定要在循环体或者循环条件中体现出限制范围，否则会因为超出数组下标的范围限制而报错。 同样的，循环体一定要有跳出中断点。 双指针中指针移动的控制很重要，移动的条件时机是一方面，更多的错误出在最后一步，该题当双指针相遇的时候停止移动，需要注意控制（指针移动，一个指针扫描奇元素，扫描到的时候另一个指针扫描偶元素，使用while循环扫描，在循环条件中要写明扫描的元素内容，何时停止，以及什么情况下终止扫描，即扫描结束，该题中当两个指针相遇即扫描结束，需要在两个指针的while中都进行体现）。","tags":[{"name":"array","slug":"array","permalink":"http://yoursite.com/tags/array/"}]},{"title":"leetcode-922","date":"2020-07-17T07:17:30.000Z","path":"2020/07/17/leetcode-922/","text":"922.按奇偶排序数组Ⅱ 给定一个非负整数数组A，A中一半整数是奇数，一半整数是偶数。对数组进行排序，以便当A[i]为奇数时，i也是奇数；当A[i]为偶数时，i也是偶数。你可以返回任何满足上述条件的数组作为答案。 解： 这题的标准答案不唯一，所以要追求更好的复杂度情况。 就个人的第一反映，最复杂的应该是创建新的数组，然后遍历原数组，把奇数项放奇数位置，偶数同理，这里就需要两个指针分别指向新数组的奇数位置和偶数位置，这个方法的时间/空间复杂度是n，所以使用双指针原地排序可能更高效；设置两个指针分别指向奇数位置和偶数位置，因为题目中说明了一半的一半，所以可以维护两个指针都指向位置不符（即奇数位置放偶数或偶数位置放奇数的下标），同时不符的时候进行交换即可，这个方法的空间复杂度是常量级，时间复杂度为O(n)。 为了代码的方便书写，重新校准思路——维护两个指针，分别指向奇/偶，奇数为主循环，每次移动两个单位，当奇数位置的数为偶数时，移动偶数指针直到其位置上为奇数，交换，而后继续移动奇数指针即可。 复杂度 方法一：时间复杂度：O(N)；空间复杂度：O(N) 方法二：时间复杂度：O(N)；空间复杂度：O(1) Tip：Java 中数组的排序以及合并等问题常常用到双指针法可以实现低时间/空间复杂度。 代码思路梳理时要注意编码只能实现单线程，所以调整方法在移动指针时候要考虑到先后主次。","tags":[{"name":"array","slug":"array","permalink":"http://yoursite.com/tags/array/"}]},{"title":"leetcode-m10.01","date":"2020-07-15T14:03:22.000Z","path":"2020/07/15/leetcode-m10-01/","text":"M10.01.合并排序的数组 给定两个排序后的数组A和B，其中A的末端有足够（刚好）的缓冲空间容纳B。编写一个方法，将B合并入A并排序。 解： 这题是经典的有序数组合并，几个方法逐步优化—— 1·直接把B中的元素复制到A中，然后进行排序即可，快排的平均时间复杂度为O(nlogn)，空间复杂度为O(logn)，在C++中即为最经典的sort函数。 2·第一个方法没有用到数组原本有序的条件，于是可以使用双指针，建立一个空数组大小为AB的和，然后逐步比较，最后把剩余的未放置的元素放入目标数组即可，空间复杂度未O(n)。 3·第二个方法使用了额外的空间，题目中说明了A末端有足够的空间放置元素，则可以使用逆双指针法。这里很容易有一个误区，就是认为放置中可能会覆盖A原本的未放置元素，但其实很容易证明——两个指针分别指向A和B的末端，分几种情况来思考，当B的元素都放进A中，是刚刚好的，A并不需要进行排序和多余操作，当B放置一部分，A也放置一部分的话，A的这部分刚好是A后端的元素，放置的同时给多余的B腾出了位置，所以不论如何操作，A末端的位置都是动态符合要求的，而且放置完B就不需要再处理A数组了，即使先放置完A，剩余的空间也总是符合B的需求的。 具体的操作就是比较双指针所在元素的大小，然后依次放置，判断当A或B的指针到达头部时停止，然后把B中的剩余元素都放入A即可。时间复杂度为O(n)，空间复杂度为O(1)。 复杂度 方法一：对于快速排序，复杂度为O(nlogn)，空间复杂度为O(logn)； 方法二、三：双指针的时间复杂度大多为O(m+n)，原地排序的空间复杂度为常数级。 Tip：就合并有序数组而言，要充分利用题目所给的有序性和空间，双指针的移动可以充分利用有序性，而原地排序可以达到最小的空间复杂度。","tags":[]},{"title":"leetcode-977","date":"2020-07-15T12:29:58.000Z","path":"2020/07/15/leetcode-977/","text":"977.有序数组的平方 给定一个按非递减顺序排序的整数数组A（元素有正有负可重复），返回每个数字的平方组成的新数组，要求也按非递减顺序排序。 解： 这题的重点在于处理负数，本身数组是有序的，但是平方后前面的负数会变大到后面，整体思路有两种，重点学习第二种（时间复杂度更低）。 第一种很直接，即再创建一个空数组，然后把原来数组中的元素全部平方，放入空数组中再进行排序即可。 方法二为双指针法，同样建立一个空数组，使用两个指针，分别负责记录最大的负数和最小的非负数，然后逐次比较两者的平方值，把小的放入新数组中（前部），当某个指针到头后，停止比较，并把另一个指针剩余的部分都放入目标数组中（正负都进行放置，可以省略区分是哪个指针到达的边界的判断）。 双指针法可以进行改进，从两头直接开始向中间移动（最小的负数和最大的正数），可以免去寻找中间正负拐点的步骤，同时目标数组的指针需要从前至后添加元素。对应的边界判断成了，哪个指针对应的元素先变为0，然后同样的把另一个指针（两个都操作，同上）到0元素的值都放入目标数组即可。如果有不止一个元素为0，这个方法是没有进行处理的，但因为建立数组的时候前几项默认为0，所以不处理中间的多个0元素也不影响最终结果。 复杂度 方法一：时间复杂度：O(NlogN)；空间复杂度：O(N) 方法二：时间复杂度：O(N)；空间复杂度：O(N) Tip：Java中数组A的元素个数（长度）为A.length，对于length属性，length()方法，size()方法的区分如下。 length属性 length()方法 size() 数组的长度 字符串的长度 泛型集合类的元素个数 arr.length s.length() list.size() 以及对数组ans进行排序（原地排序）为Arrays.sort(ans)。","tags":[{"name":"array","slug":"array","permalink":"http://yoursite.com/tags/array/"}]},{"title":"ago","date":"2020-07-13T13:22:40.000Z","path":"2020/07/13/ago/","text":"曾经的诗歌 写过的东西会丢掉，这些都是自己曾经赤裸面对自己的痕迹，除了学会的知识和道理，写过的诗便是最沉重的我和我，是坟头的土壤，亦是骨灰里不燃的结石。本文仅记录2020年7月前的部分诗歌。 习惯了不让别人失望，于是被人打一个嘴巴，也要鞠躬道歉，祈祷祝福，直到自己感动落泪才善罢甘休。 2016.1.14 雨。 雨水终于打碎了粘稠容一片透明留在了窗台上我慵懒地一口吞下任她像你一样抚顺我心底的彷徨 我看见一载火车拖着你走过了绿色身旁她眯着眼不是因为风沙或泛起的浪 没有阳光没有你她和我都一样毕竟花儿不是你的她也不需要阳光 2016.4.16 肉与灵灵魂分明捆不住肉体她早在狭长的细缝里吐出了干巴的靡靡灵魂长成了刚脱下的蛇皮吸吮着拼命吸吮着水和空气她便被榨成了干薪一碰泥土就烧成了灰烬 2016.4.16 最后的情书。 梦的终章终于写下就像我的葬礼一样那么辉煌人们在手边我却触及不到你欢笑我庆幸我还能带给你些许凉爽黑夜终于吻上了太阳雨里的祷告流离的小草也钻进了我的眼眶可惜的是它干枯如你就好像操场上的塑料最后一封情书已再无言讨好苦水和着泥土让我品尝远眺他说你也不幸让我怎么是好难道默默的嘶吼难道再跪着替你祈祷还好天人两隔让我不用再想象除了心疼便也就是怀念我有血液的心脏 2016.4.16 Rain大雨冲洗着一颗芽尖上的糖甜味散入泥土长成了一片晴朗花儿的眼泪本没有味道落在泥土里却染上了芬芳 2016.4.16 我只想找一个人厮守。喜欢的时候可以毫无顾虑，有牺牲全世界的勇气，累的时候可以抱着，不累的时候安心的靠着，不用担心会失去，不用担心会陨落，一个人的时候可以想念，想念的时候不用感觉卑微，讨好的时候不用像乞讨，可以心疼你的心疼，偷偷看你的时候你也在看我。 我只想找一个人陪伴，爱情里没有一点背叛，时间再长也会嫌短，默默的不用说话也很温暖，你睡觉的时候我看着你的眉尖，你醒着的时候我吻着你的眉眼，不用嫉妒不用唯恐失去，感动的时候没有心酸。 我只想找一个人喜欢，可以陪我走过万水千山，我可以给你的生活，你不会嫌太淡或太咸，我会拉着你去冒险，抱着你淋雨或攀岩，从荒凉的沙漠到繁华的街景，我看你笑的肆无忌惮。 我只想找一个人留恋，在我眼里你永远是最美的红线，我会去买菜做饭，从后面搂着你一起洗碗，今天可能堵车停电，刚好我们可以拉着手眯着眼，你不要抱怨，我和你一起看着世界毁灭。 我只想找一个人松绑，一起走过生活的多艰，当你生病时我会待在眼前，当我失落时你会说有你陪伴，我会爱着你的每一个雀斑，当初的感觉不会幻灭，孩子可能会贪玩，我会耐心告诉他世界的明灭。 我只想找一个人流连，流连繁华的危险的世界，等我们年近中年，我依然会逗你开心，拉着手时会红了脸，爱情绝不会有半点衰减，生活更不会无情或下贱，这社会里富裕或穷苦，而你就是我的整个世界。 我只想找一个人冷却，等到天荒地灭，等到你看不清我的皱纹，我也快看不清你的眉眼，虽然可惜时间已晚，但我仍然愿意吻你的脸，等到你睡去的那一刻，我会抱着你说，路上一定要拥着你的笑嫣。 我只想找一个人爱我，来让我刚好也爱着你，带你写一本童话，不管有多累，我都不会懒。 只是对不起，被当成了刻意的打扰，只是对不起，我还视若珍宝。 有人说过，当你爱上一个人，就已经在想象里和她度过了一生。 所以， 珍惜我，不然离开我，我宁愿让疼痛在梦里开花结果。 2016.4.23 阴天。 不明不白的云间映出无辜的天低头凝视悲伤安心靠在窗前失落感像个孩子无名地喧闹哭喊全世界像个聋子还以为是花落无言 2016.4.26 下午雨后的小楼有一张大大的床厚厚的被子把枕头放好被子盖好把闹钟关掉任由雨声流进无由的梦 雨是陈旧的染料洗去那层土打湿时间和旧梦小楼在沉睡着鼾声却泛了黄 2016.4.27 爱 我想品尝你所有的甜嘴边却就着我的苦涩让你溶进我的血液看见我生活里的颜色我想你立刻就爱上我影子烧成一团火拥抱着你尝一口夕阳任黑夜躲进花朵 过去，现在 当过去被盖上了棺盖，不满和不舍也只剩干枯的无奈，当无奈的现在把过去掩埋，希望也好像就不请自来。 2016.5.6 经过了每每的乐极生悲，我宁愿不乐不悲，等人群都散尽，只留下你。活得如此歇斯底里。 可能最好的就是等着不用期待不用推脱没有失望没有折磨不用为了谁不成熟 懒得同情自己。不敢祈求你相信我。是因为怕失望。怕你不再感动，怕我面目全非。 一个人不太纠缠另一个也许就会沦陷。也许心计不够，不经意就会变成反目的仇人。 不执着于过去，不妥协于现在。最可悲的不是自己否定自己，而是自己不敢否定自己，是认命了，悲哀也认了，达不到也认了，不挣扎了，生活也死了。 愿勇敢，愿坚强。愿生活给我所有的理由去拼命挣扎，绝不认命，绝不让生活死去。 勇敢，相信自己。相信所有的挣扎，相信所有的歇斯底里，相信所有的感动，相信所有的热泪盈眶。决不低头。 不晓得自己的身上和心上在以后还会添多少伤疤，但不论如何，我都仍会毫不犹豫的拥抱自己热爱的东西，即使粗糙，就像生活，就像你。 在疼痛感的包围中一点点变的坚韧，曾因为失去而有过的歇斯底里，曾因为感动而有过的热泪盈眶，渐渐地愈发清晰，清晰地刻在我的生命里，而在这血水融着泪水的大雨里，我能仍旧认真地雕刻时光，认真地哭和笑，何尝不是属于我的一种灿烂和美好。 狂躁的伤心绝望居然也可以变得优雅。 不再向全世界公示告知，只是自私地偷偷给欣赏自己。 狂躁的伤心绝望终于可以变得优雅。 只是不再向全世界公示告知，只是从此自私地偷偷给欣赏自己。 原来，我以为，只要能让你幸福，我的尊严无所谓，多苦多累无所谓，路有多长无所谓，一生的烙印无所谓，后来，我发现，这些只是因为我爱你，只是因为我爱你可以让我幸福。 我本从没羡慕过谁，但我却嫉妒你的他到疯。 虽然压着生活的韵，却难免也会不如诗。 亲爱的，我从来不愿承认除你以外的什么人也会让我凌乱。 Dream what you want to dream,go where you want to go,be what you want to be,because you have only one life and one chance to do all the things you want to do. What matters most is that you should have a passion for life. I am heading for my life. If you weeped for the missing sunset,you would miss all the shining stars. 我遇到过很多比你好的人，却没遇到你。 我还想，年少下去，但我更不想去伤害你，更不想把世界让给那些我鄙夷的人。记得，我爱你呢，你知道的，我很爱呢，比我见过的故事，听过的故事，都轰轰烈烈，奋不顾身呢。请让我继续相信这个世界是我的。加油。 总会有人去爱她，总会有人会被她爱， 我的世界里，她从未有过的存在。 You are right.I need my life back.That is not me at all.Her is never her,but i am still myself.No praying.No blessing.No regret.No illusion.Just go,And win. Good night.Hold the faith.Live my life, forget her,and let myself off. Sweet dream. Life should be cherished regardless of anywhere we are as well as in any case. I see,you are the epitaph of me. 不记日记，是因为受不住物是人非的提醒。 2016.5.11 人存在意义的浅层探究。自然界，人类社会，思维学－哲学脑科学的开发，思维的四维性，唯物与唯心的关系，感性凌驾理性说，数学哲学与世俗局限性的冲突，冥想与思维开发的联系，爱因斯坦，鲁迅木心，顾城海子，杰克凯鲁亚克 米兰昆德拉马克思的多方向中国的限制性与美帝开放日本自由严苛的局限性 虚伪的努力。你是不是只为了押生命的韵，而忘了自己的感受和感情。 柏拉图式爱情，想当人渣装不了，变得高尚又不够无私纯白 物质与精神，科技与思想的不统一性 论。顾城的爱 与一生。 2016.5.13 终点。 一百年的终点是你生命的终结思想潜入土壤意识灰飞烟灭 三十年的终点是你青春的终结面容起了皱褶笑颜偷偷变浅 十三年的终点是你童年的终结沙堡染上灰尘天空涂上雾霾 可是呢时间并没有如此温柔容不得你纵观一生就已经把你带走 一天的终点一小时的终点一分钟的终点一秒钟的终点 你是昂首挺胸还是选择苟且 一片夜的终点一朵花的终点一涟雨的终点一次转身的终点 我知道你看不见看不见那点的始终和失落的喜悦 惶恐无助悔恨 洒脱知足淡然 生命里无数的点组成了世界 不时的生命像雨水冲刷着每一寸皮肤脚下聚成了沼泽还是成就了夜的花园 2016.5.14 把生活解的明朗，往往会抹去了美好的希望，把人性看的透明，幸福和痛苦感觉会一样。 如果我继续想，继续想，也想得透，把生活变成空气和阳光， 可是 太过本质的，就会硬，太过深刻的，都变脏。 2016.5.22 Ready go，19中19考场，十点前，冥想打坐。 像渴望呼吸一样渴望，，， 如何进入思维状态。我眼里没有时间，我手里不长枝叶。此刻，念起念落，此生，皆为妄作。An appetite for life77t，700f，乂，jiva。重离。中午辅导课，中午生物课本听记，晚自习词汇和新东方高考阅读背，大晚自习新东方作文积累和写作记忆，一天十篇古诗文默写，周末英语3500地毯式背诵，周末英语阅读高考题回顾思考，每日英语完形题思考感悟，早晨语文答题及诗歌背诵，早晨英语美文完形诵读，上午语文，下午英语，晚上英语阅读真题，五年真题古文精每字必译，两天一份理综卷，290以上，一份数学卷，140以上，否则加量，数学物理化学生物平时和剩余时间训练，浏览生物化学课本，框架主干总结整理框图化，特殊时间，特殊突击。 化学卷子默刷 后青春。 114天高考，情人节失眠。我要去北大，我要骑自行车到北京，我要徒步陪一个女生在汾河岸边伴着星光如痴如醉，我要去爬黄山，我要考进全省前十，数学理综满分，英语扣十分，语文扣四十分，我要健身，我要了解商圈，我要游泳，我要唱歌，我要和她看鬼片，我要英语走托福，我要哭，我要笑，我要赢，我要赢，我要赢，我要好好睡一觉，我要努力。 晚安。但愿我再也不矫情。忘了所有该忘掉的人。吞下所以不该被蒸发的泪。等到应该有的未来。 好好过。 高考后 黄山徒步旅行自行车骑行去北京英语托福口语养宠物猪，小盒子吃菠萝蜜鬼步舞双截棍家教，高中物理培优刷题，模型总结诗歌app有奖励制度（研究一个的收益方式）英语流利说练口语VOA四级词汇及阅读读三本英语原著买个小沙漏和女友去十天的冥想课程 69天高考，700分，120+150+140+290。 生活真是神奇，能笑得出来的都是好汉。 味觉记录仪家教中介机构红牛咖啡糖中国管理层文化思想闭关锁国数卷子器半导体生产应用在中国建一个最大的迷宫，不只一层，地下地上上善之水第三极小型拍照扫描打印仪远距离充电 2016.6.6 高考 正确的方式做错误的事情， 过于强调积极正面的影响，忽略负面的影响，也许可以使人心沸腾，但现实现任更加微妙。当世界看起来不是那么的善意美好时，形势大好就成了无聊的空话。 当你在解决一个问题时，首先要考虑的其实不是解决方法，而是问题产生的原因。 有时候，做事情要对未来进行评估，尤其是决策时，如小庙招来大和尚，如果不准备把庙在短时间内扩张，完全没有必要。 旧雨。 雨过午后天地陈旧如同心情透明的旧纸屑铺天盖地散散的飘落让树叶都生了锈时光和灯光都燃着柴火旧旧的湿湿的懒懒的任由颜色慢慢染黄了下午雨后的小楼我想应该有一张大大的床厚厚的被子把枕头放好把闹钟关掉一个人任由雨声流进无由的梦 2016.6.13 此处大雨倾盆多想和你在陌生的城市窄窄的屋檐将近傍晚的夜灯乘一地落地窗 靠着相顾无言一点点变老 2017.7.14 不容反抗的善意，或许跟恶意并没有太大分别。 2017.7.28 很多思维方向太固化了最低的思考是以一个标准下，去争论对错往上是以不同标准和价值体系构架意义再往上是考察价值体系存在根源和本源目的已经思维方式再往上是几个不同思维方式和习惯的根源，文化语言生存经历对其塑造的作用再往上是思维维度的升华，跳出本源思维去考察更多面的新定义与新价值 2017.8.5 满天繁星，温热的屋顶蝉鸣山雨的风我的眼睛和你 2017.8.19 2017.8.24 如果你要走我该怎么挽留呢是不是在限制你的自由又该用什么姿态等着到那会儿所有喜欢和丝毫贪念都被叫作自私吧我想留下你又不能作任何挽留 即阻碍我想等你又不能作任何喜欢 即阻碍我不想放你走想你回来这想法就是自私就是罪恶就是对你伤害我喜欢你不能伤害你我如何想如何做如何姿态此处的碑上刻着恶言恶语我怎么爬出坟墓还不刨开土破坏了风景用哪把刀温柔地刻划去我的名字 2017.9.8 好正经啊，是的，前些日子的歇斯底里丧心病狂，也吓到了我，何况是你。我要想办法停下来，有些疼，但那毕竟不是什么好看的浪漫和坚定。不会假，都是有血有肉的所以惶恐不安，生怕嬉皮笑脸却发现只有自己在尴尬的讨喜，却并不讨喜。 然后然后居然想了半天，我们之前是为了什么，去那样我是为什么而失心疯居然忘了…… 你是甚好的对我来说，是最好的我爱你这一点是我改都改不了的 没有白爱毕竟你让我这样幸福，我也让你哭让你笑，让你难受失望恐惧无奈痛苦，很丰满了，我们可以共度余生了吧哈哈哈哈好 是真爱 2017.9.18 但愿 但愿没有秋雨但愿没有晚夜但愿没有灌木丛里的小路以及昏黄的路灯和青石板但愿没有温热但愿没有绒毛但愿没有一声叹息换来的回眸和风化了时间的一串留念但愿你我不曾相遇相知但愿你还是你我还是我世界还是这个世界你就住在你的小窝里我就住在我的小家里各晒各的太阳各眨各的眼 2017.11.16 遇到你 遇到你自私就开始泛滥像颜料找到了纸张开始蔓延遇到你太阳也变得皎洁夜晚闪着光梦回西海湾遇到你是水含住了烟一口吞下不舍得嚼碎便心心相念遇到你是生命的和谐禅意至此也源于你的眼睛你的鼻息和血液 2017.11.16 晚雨述秋 秋风细雨斜灯火长在土里纤瘦又漫长借了月色煮一壶酒澄清如铜镜浑浊如月光月光也种在土里混着细雨浇灭了灯火灌醉了橘绿橙黄 2017.11.17 百年一如四季被春絮埋了枯骨也铸新衣夏蝉无眠倚着晚风行舟没于困意待着秋叶铺了几层垫在心底借着月光偷听雪花落于湖心而我呢我就藏在湖底的泥里长眠者忘掉鄙夷梦到休戚自顾自生长长在时间的樯里四季声张高墙之外的墙无人提起 2017.9.6 下弦月月色如旧旧铁如锈时光如午后旧人如痴眸何痴烛火愁先愁灭月色后愁灭星流 无杯可盛此夜愁千方流转醉凉风莫若童叟欺前路不谓良人饮貔貅 2017.10.26 初冬的雨光明正大地划破了叶子的尸体没有谁能抓住十一月的尾巴没有谁能叫醒难过的树枝十二月的早晨只有不值钱的感情和不值钱的天气日复一日又怎么能看到年复一年的所幸干枯的身体啊干枯的眼睛榨干了心力点不着了空气十一月的苟且成了十二月不值钱的武器杀死我吧杀死我请划破我干枯的身体 2017.12.1 难过和失落是我不能承受的罪恶作为常青的叶子却不能靠近生存的根他们和彩蝶是枝干想要的生活我和我只能是黑夜里干枯的种子阳光里乘凉坠落的自惭形愧的我向往着触不可及的根 2017.12.5 如若我的思念至苦爱至锋利如若我的五官并不光滑心头的血液也未凝结得干净 我的脑海里在闹鬼勇气都去上了吊温柔都在发烧感冒现实的光线都远来自远在三千米外的窗子来到我待的屋子里没有墙时间刺穿我的胸口既害羞又内疚于是缩回到碰触之前血哪里流的出来她比时间还害羞躲在房顶既不哭也不笑可怜可怜我吧帮我杀了他 2017.12.27 南方的雨 南方的雨终究是温柔的她教会了灯笼怎么游泳又催我们长出了鳃和鳍一月把梧桐做成了桨碎了柏油路变成了沙地和那面北方的镜子不同夜里的棉花没有那么锋利安静的揉了揉时间的尘土岁末岁末向谁表达感激南方的雨终究是温柔的你把手捂着我的耳朵毛绒了淅淅沥沥手指悄悄扯平了被角种子的哈欠眨了眨眼睛和北方的那场战斗不同在最旧的房子里我们发酵着困意抚平了心跳和呼吸岁末岁末向谁耳语感激南方的雨终究是温柔的她纤细的身体温热着骨头和鼻息空气从饱的肚子到眉间的平地高台是泡沫的高台黑夜是太阳的新衣蹭蹭你的肩膀亲吻你的脚心从鼻子到眼睛是我最高耸的山是我的屋顶和墙壁北方的火炉边有一只猫她的毯子遮住了晨曦岁末岁末向谁递去感激在南方，我有你我有你 2018.1.2 满城烟火醉人疑寒冬春雪碎心机暖月红霞惊人梦冷雨白露背人心 2018.2.23 月亮是月亮月球是月球白马非马我举杯对影匆忙奔跑于原地于山丘你不是看客我不是屠夫戏子举刀策马于山海于枝桠只想为你煲汤为你熬粥 _脚底的月亮 2018.3.3 阴霾杀死了你雷声劈开肉体雨水血水除了泪水都磅礴都坦荡坦荡地认命收尸灵魂涂满夜色夜色堵住耳朵夜色大口呼吸 2018.3.4 异乡清明 作为一只孤独的鬼衣衫褴褛终日躲在消瘦的楼里面对脑壳废墟蝇虫侵蚀我的肢体骨缝里干枯成花纹的遗迹奄奄一息的清明千年以后狂风乍起用水灌醒我用雷劈醒我带我回到远方的墓地插一朵炽热的雪花在异乡人的梦里 我曾经也决绝，忍着碾碎耗着，然后进化成长，后来我乐于此。快乐打折，越发廉价，绝望和放弃，也越发廉价，不断进化成长进化成长，长到我悔恨不已 2018.4.5 时间的流刺破了眼睛贯穿了白昼的波纹影子开天辟地星星消失了冷的变温热柔软的变坚硬时间的流留下枉然堵住耳朵和鼻息云不再动了水停泊在半空中灵魂住进没有桥的大山里皮肤冷了石碑硬了谷仓还未填满过时间的流自顾自地妄为着改变是徒劳了救活我于死人堆里一丛一丛的尸体斑驳洗不干净渐入安然之境变软的皮肤接受时间的矛头接受消失的星掉进没有桥的大山里堵住眼睛时间的流不食人间烟火味看破离人伤头七 2018.4.6 枯枝细雨无路青泥残瓦有屋 2018.4.6 我曾嚣张跋扈地立于山海而却活不到你眯着的眼缝里终长成喧闹的孩童 生存体验艺术照 热情和直觉 枯黄，她杀死了我在昨天 _明天的诗 天空包容黑色的树叶没有街灯、影子、床单和枕头白色的你没有言不由衷 _说谎 天空窄窄的，像一棵草那滴露水却像凝住的冰雹 _泪眼 又是柳絮纷飞的时候，又有爱情来又开始等待一场大雨偷偷打湿所有的裙摆 _初夏 影子所在处的人人所在处的影子喜欢我的你 _不存在的哲学意义 天空被枯枝刺破是一转眼还是我遣词造句的细长的夜晚 _时间 时间洗干净了树干雨水洗干净了灵魂以苟且之名 做播种的人 中学有很多个瞬间我坐在教室里午后还未困乏开着窗户外面的风吹进来外面的光让我眯着眼 在我本以为的瞬间里昏黄和耀眼的光都在我身后我躲在苟且的影子里背对着窗子和风 _逃避的念头 镂空的楼梯走在昏黄的苟且里耀眼的是天台上的风 风化了我的骨头骨髓汁液 一只年轻的孤魂野鬼走在柏油路上害怕黑夜的黑 _年轻的我 皱纹更深了思念更浅了故乡更远了 _三年 播种人的苟且存活于秋天死于春夏冬的黑红时间 _播种人 我是一座只剩时针的钟往返于起点和终点的圆圈是故乡的月和汗水填满的皱纹 2018.4.15 整理 替代品的好是意外的惊喜替代品的坏繁茂在意料之中替代品不是期待只是无奈 _替代品 2018.4.18 执念值钱吗，还是避之不及。我早磨坏了，还不舍得拿到面子上看看补补，藏着掖着假装坚不可摧磨坏了，不是释怀了是真的坏了，彻底坏了 2018.6.26 峨眉屹远多曲斜辰客逐日冥幕切收尽天下若无路谁言蜀道望山巅 2018.7.9 给你找好的托词归咎于人性的恶臭我们入围继续表演痛不欲生 2018.7.31 瓦墨砖白青水色石冷茶暖温性情苏园林中 2018.9.24 阴影 有一块镜子曾经碎在了时间的枕头底碎成了桌椅板凳满满当当的挤在那个房间里我生活在梦里每当昼的墨色蔓延微凉的草色沉淀到每个罐子的瓶底有什么在被折射着舞动的空气手牵着原木牛皮纸和希望 有一片阴影一直都藏在草底的泥土里发霉发酵成了四季填不满大块的墨色窗子昏黄的也不行我生活在黑暗将至的白炽灯光里阴影清凉在发梢与脸颊的间隙有什么沙沙作响开嗓的虫儿叶儿牵挂着秋末与日末的距离 后来啊后来镜子碎到了拾不起阴影长成了凌乱的斑点夜色忘了和昏沉缠绵我丢失了罐子和朴素的场景 后来啊后来我变得愈发透明阴影和我融为了一体镜子里千万个我填满了窗子牛皮纸和空气 后来啊后来眼泪都成了尸体晴空万里的祥云是墨色虫儿叶儿住在四季里最后一只我躲在了草底的泥土里 大口呼吸大口呼吸 2018.12.1 期待-等待雨淅淅沥沥一场完整的几经破碎 正大光明地填满了沟壑填满了叶脉填满了原本空荡的一周的空 现在他们都走了一干二净空空如也 关于雪季也一推再推变成了阴云密布的三角恋 四海的雪啊四海的晴空装不下这小小的念想小小的一朵云彩 雨淅淅沥沥的一颗完整的将近破碎 如果阴云还是等不到雪就把我的影子刻在那里让我的轮廓包裹下一场 下一场里破碎的一颗泪滴 2018.12.8 如果可以切开灵魂如果可以分离意识和身体如果白天黑夜住在一起如果时间和空间反目成仇如果我的横剖面是彩色的大概可以渲染周围的墙体和远方的不及如果我听的到疼痛和悔意如果我触摸的到众多的秘密如果我本可以掰开你洗干净与我有关的意义如果我只在你怀里做疯子傻子不舍昼夜灵魂都与你充饥如果我最后遇到另一个你人间的五谷杂粮人间蒸发的蒸汽人间撕裂的遗憾无家可归的灵魂无处取暖的孤鬼饥肠饿肚的肉体罪恶与佛性手枪与紧箍如果我还记着你我想象与自己的寒暄数年之久照顾花草也照顾藏进木头的心脏用火柴取暖我小声的嘶吼在无人之地人海喧嚣里拥挤的几个我都向你行礼如果骨头就此不再生长煲的汤喂饱你的血与肉如果四季轮回停止在高烧前祈祷不多一丝一毫瓜葛千丝万缕如果我们都成了碎片请让我燃烧为你取暖请喃喃细语说我为你而死我为你而亡 2018.12.5 有风有雨有山有树石头和砖瓦灵魂和草木也奔跑摸黑打鼓信了宿命迷了道途 时间是我们停下脚步花开进山谷老鼠和野兔 铿锵的雨变成河绝不惋惜绝不顿悟 你和我变得庸俗住进高楼藏一捧那里的土 2017.8.18 末日啊仅仅用路人的痛苦便可以覆盖街道每一寸的柏油路黑色温柔无坚不摧黏腻夜色里的苟且夺取黑色的眼睛灵魂里的苍白沉默了少年的垂朽末日啊可是日末或是晨微之际榨不干的血肉悬挂着千丝万缕还未曾放手末日啊末日是不枯的花环我们在环上走时间从环里流 2019.2.10 我走出了图书馆不得不面对又半日的徒劳外面风雨交加透过身体摇晃着五脏六腑我感觉自己好像一棵树绷的很紧有些东西挂在后半生而那些东西此时此刻 沙沙作响 成年人是贪婪而脆弱的软体而木讷的无知的坚硬的顽童才肯去燃烧燃烧的才会逃跑摔倒的并不会碎裂只会弄脏变成泥泞的纸浆 反义词并不能概括矛盾不能如此拘谨而徘徊 最可惜的是时光大好我们有伞和面包有玻璃和围栏我们优雅端庄却在安静和喧嚣时都变得紧张 可笑的是喃喃自语胡言乱语比树枝还乱挂着的摇晃的是夜半的梦天一亮风平浪静岁月静好报告还是报告代码还是代码那些被人欣赏赞美的老去的花儿无处倾诉我也不讥笑他们但我偷偷把这前言后语告诉我的爱人让她陪我不知所措 我们就看着她们凋落好像从未行走过离开过 我还要告诉她我回到宿舍了 扭啊扭 这是 杏仁绿的色调喝干大海的难事笑声桂竹香贝壳蚕豆玻璃黑人寂静石板瓦后果欧楂小丑。 2019.3.21 喧嚣于夜色中沸腾快乐啊快乐从我身边呼啸而过风雨停留在树梢枝丫高处藏着万物指尖却空空是什么填满了人间淹没我钻进了身体里面快乐啊快乐停在远处我踉跄走去快乐堆在背后像一叠地底的山丘驱壳里是什么填满了我是什么在我的空腔里爆炸又是什么堵住了所有出口快乐啊快乐老了爬不上楼为了躲开噪声钻进泥土中我面朝大地和他们一起倒立行走擦掉耳朵细嗅弄脏的眼睛和手 2019.3.23 生如尘土伴随萤火一旁自当为平凡准备了充分的满足感 偶尔成为别人的光随机赠送跌宕与安详 更多的去追寻熄灭了视野狂奔落入泥土生根 为大地献上自己的心脏 2019.3.28 挣扎的人归纳生活是场修行终归是想目睹平静的大隐于市是凡人凡人挣扎归于繁琐的吵闹生根于喧嚣圣人缄默心脏为了什么炽热就为了什么变脏欲求不满求而不得无是耳朵和眼睛的诉求而是身体是念念想的琐碎破旧我想要的不是光和宽慰承诺热闹的总意外死亡念想即空届时沉默的是顿悟欲无底而无为护着命须有念无邪而坚无可摧为悟迟 2019.3.31 时间困了不再吱声就自顾自蹒跚了绿叶困了不再起舞就靠着棕色的床安睡了暖阳困了不再振奋就裹着灰色的棉被慵懒着公园里的孩童也困了藏回襁褓决绝温热消失了困意如同烈酒眼睑起皱了不愿沉浸的人们啊可是七八点钟的灵魂还是沮丧的人海仍由礁石拍打着不痛不痒了我也困了山河沸腾着一时间脚下的泥土空无一人了 2019.4.2 清明节风和日丽今天没有扮演理所应当的悲切人们放弃了辛苦的日子 2019.4.5 后来的我们 我往往失而怅寥最痴情者就独自自言自语自导一场自剜痴情是最自封的也自觉的好像偷盗者的自我开脱假装满足的不辜负生活不悔决绝的断舍是洗心革面坏人可会自悲博人怜悯背后才把感情里的最杂碎洗干净成了美味也供下一位唾弃或饱食心满意足听说那些厌恶感和欲处刑自己的也感激涕零了 如若宛然重复自当祝福着不哭不闹安静地以死谢罪挫骨扬灰 2019.4.6 雨夜四月伊始 火热的雨啊轰轰烈烈炮火未伤及大地分毫却把墨色不舍昼夜 刺眼的墨绿啊昏暗里洗净铅华犹如故人归握手言和释尽前嫌 这样的降温刺骨触手可及的冰雨水使我感到高尚奴性的欲望被释放肮脏被冻成霜她死而后生交合里大喜而悲冷静的讨好自己片刻里感激而失望 心脏麻木了穹顶有节奏的压迫我躺在水滩里面若冰内心却心花怒放 嘿杀死我的你我将有无数的热情迸发的血液与你狂欢向你致敬我的膝盖可以弯曲触底永世为奴喂饱你供刀口牙尖食用我有干净的肉体温顺的眼睛嘴里漠然祈祷依靠着依赖着透明的胸腔里满载我和你的点滴 一针一线万里无云请用舌尖寻找纹理鲜美丰富温热坚决熄灭的是为燃尽安详的是绝唱请将我蚕食而尽请撕毁我波兰的爱经 2019.4.9 上帝是孤儿佛祖是恶人他们玩弄凡界的命运教人们受苦自作清高一副 人不渡己佛不渡人经书做了厕纸一撇一捺正堂里为凡人供奉闭门不见虔诚善美嬉笑着用劫数杀人 正主的副业是屠夫将真善的凡人用伪善抽筋拔骨活下来的是信徒死去的都是奴仆 罪业漫天不渡己何以渡人渡己为魔佛堕在恶道贪嗔痴慢也造作为业渡己者不入佛道业障不散不得超生 肉体凡胎何以渡佛 2019.4.16 毒辣的光蒸煮着大雨将至绝望搅拌着困意默默倒数最后几次呼吸 好像一场热情被冷水浇灌发芽的理性长成参天大树顿悟整整七分钟重复着不断地顿悟孩童撕开腐败的血肉重见光明 残忍啊温顺啊路过的人伞下嬉戏打闹路过的人伞下沉声哀悼 我藏在树下一秒一秒使我感冒的不是浪漫是最后一次的日夜颠倒 2019.4.18 雨水在天空中铺成河叶子蒙冤在河里影影绰绰 是河神是水鬼张罗旗鼓正义的人啊贫穷而孱弱 我佛不渡无缘者他买不起香火他吞不下行粮灵魂蒙冤堕入业障 大开杀戒吧杀死信徒染红僧服河可以洗净冤屈做河的奴仆 喝酒的人大鱼大肉从不信地上的佛穷 2019.4.29 路灯是夕阳熄灭时的暖衬托着蓝绿色里的灰白把灵感重新点燃草木味把空气雕刻成有形状的冰匆匆一瞥感性包围沦陷淹没随即万劫不复你可还记着那天路灯下你回头，我站定出了神悲离散后就悲悲得沉重而拖泥带水一个人干干净净沙哑到声嘶力竭你任由我壮烈摸着黑就找不到距离就触而可及就不会停下才知道夕阳是路灯熄灭前的狂欢温文尔雅文过饰非 2019.5.22 我每走过一盏路灯就有一只影子从我身边擦肩而过每一只影子路过都把我的灵魂冻结直到下一盏灯把我的肉体火化完成一次重生这样壮烈的过程冷清地重复着死去努力活着死去努力感受活着我越靠近灯影子就越远我越远离灯影子也陪我奄奄一息临死前颜色的界限还是分明的往前爬一步混为一谈的是我和我活下来的不是光和影 2019.5.27 正义是一种文化正义是一个观点正义是最后的结果正义是法律正义是人多势众正义是权势正义是人们认为是理所应该正义是更多人的利益和安稳正义是感情的波澜壮阔正义是公平的下怀正义是强者的哼唱和锦衣正义是弱者的稻草正义在某些地方是这个时代的罪大恶极者的微笑是尸首的最后一片棺盖 2019.7.19 有些爱情就像朝圣心怀崇敬与仰慕用一副凡胎肉体寻求灵魂时常自卑始终忠贞灵验与否并不要紧我爱你是我的信仰但求心安 2019.8.3 时间伊始如草木生生不息像尘埃从半空飘落轰鸣声与交响乐点燃了大地颜色慢慢炸开水面上芭蕾的练习飘落相依关于风畏惧着也祈祷着起名为命运我还看不到底万丈深渊里电闪雷鸣与我一起坠落的你奢华的锦衣瘙痒或者大意一瞥以为到了底赴死可是场盛宴还是一次别离抽筋拔骨梦里的一粒尘埃落地蚊子血已经凝固来不及来不及结束我们可能就不经意地忘记时间是被玩坏的音乐盒掉了漆请赐给我一双手吸附着你然后再融入大地 下定义是危险的，无论是自己还是别人。当你发现一个陈述的如此合理，符合逻辑而且灵光一闪，令人臣服，那要注意了，世间万物，越是非单一物质底的事物，其定义更多要涉及到立场，如果别人的定义的逻辑性和未知性，利用了你的求知欲和好奇心，那可能只是他在把你拉进他的立场，而他的立场往往可能是舆论，是大众的，人是如何迷失自我的，是如何放弃独立思考的，大致就是在一个个看似合理的定义中，深信不疑，在一件件匪夷所思里，不是被启发，而是被告知。人可以是人，也可以是一个喇叭，一个没有智力和理性的传播者，无知感性激起的是动力，传遍的是别人的一面之词和虚假不公的自私立场。 2020.2.28","tags":[{"name":"x","slug":"x","permalink":"http://yoursite.com/tags/x/"}]},{"title":"leetcode-985","date":"2020-07-13T12:45:56.000Z","path":"2020/07/13/leetcode-985/","text":"985.查询后的偶数和 给出一个整数数组A，以及一个查询数组，对于第 i 次查询，有 val = queries[i][0], index = queries[i][1]，我们会把 val 加到 A[index] 上。然后，第 i 次查询的答案是A中偶数值的和。 解： 这题不难，简单讲一下，大意就是查询数组是二维的，每列的目的是把第一个数加在A中以第二个数为下标的整数上，然后每次输出A中的偶数和。 由于需要判断奇偶，可以尽可能把判断的行为提前，这样就可以尽早分类，从而避免不必要的计算。 先计算出原本的A中的偶数和sum，然后每次判断第一个数是奇数还是偶数，奇数可以忽略，偶数需要更新sum，每次输出更新后的sum即可。 复杂度 时间复杂度： O(N+Q)，其中N是数组A的长度，Q是询问queries的数量。 Tip：Java 中的for循环可以简写为（for(元素类型t 元素变量x : 遍历对象obj){}）（求A数组元素的偶数和）： 123for (int x: A) //增强for循环x为a的一个元素 if (x % 2 == 0) S += x; java中的集合有两种形式Collection，Map&lt;K,V&gt; 在JAVA7中遍历有一下几种方式： 123456789101112131415List&lt;String&gt; list = Arrays.asList(\"aaaa\",\"bbbb\");//for循环for (int i=0;i&lt; list.size();i++)&#123; System.out.println(list.get(i));&#125;//增强for循环for(String str : list)&#123; System.out.println(str);&#125;//迭代器Iterator&lt;String&gt; iterator = list.iterator();while (iterator.hasNext())&#123; System.out.println(iterator.next());&#125; 在JAVA8中还可以使用forEach来遍历： 123456list.forEach(new Consumer&lt;String&gt;() &#123; @Override public void accept(String s) &#123; System.out.println(s); &#125;&#125;);","tags":[{"name":"array","slug":"array","permalink":"http://yoursite.com/tags/array/"}]},{"title":"leetcode-414","date":"2020-07-13T09:54:24.000Z","path":"2020/07/13/leetcode-414/","text":"414.第三大的数 给定一个非空数组，要求返回该数组中第三大的数，如果不存在，就返回数组中最大值（数组中的值可能重复），要求时间复杂度为O(n)。 解： 用三个变量存储该数组中第一、二、三大的元素，遍历数组，判断是否比一大&amp;小于一大于二&amp;小于二大于三&amp;小于三或等于某一个，对三个变量进行操作。最后返回第三个元素，若不存在，则返回第一个元素。 此外还有一个方法，就是维护一个三节点的红黑树，时间复杂度为O(n*log3)==O(n)。 代码如下： 1234567891011121314class Solution &#123; public int thirdMax(int[] nums) &#123; if (nums == null || nums.length == 0) throw new RuntimeException(\"error\"); TreeSet&lt;Integer&gt; set = new TreeSet&lt;&gt;(); for (Integer elem : nums) &#123; set.add(elem); if (set.size() &gt; 3) set.remove(set.first()); &#125; return set.size() &lt; 3 ? set.last() : set.first(); // set.last() 里面最大的元素 &#125;&#125;//作者：happy_yuxuan 复杂度 时间复杂度：O(n)。 空间复杂度：O(1)。 Tip：C++中的最大值与最小值的表达—— private long MIN = Long.MIN_VALUE; // MIN代表没有在值 另外，INT_MAX和INT_MIN都被包含在一个叫&lt;climits&gt;的头文件中，包括，UCHAR_MAX（unsigned char 最大值），LONG_MAX、LONG_MIN（long最大/小值），FLT_MIN（保留全部精度的float类型正数最小值）等。 其实，INT_MAX就是0x7fffffff的一个宏定义罢了。 红黑树—— 二叉查找树（BST），左子树（右子树）上的结点都小于（大于）根结点，且左右子树分别为一颗二叉查找树——二分查找。 查找次数最多为二叉查找树的高度，但是插入操作可能会使二叉树的高度大大增加（从根节点开始逐步向下比较），为了降低二叉查找树的高度，使二叉查找树更平衡，需要一些策略——红黑树（平衡二叉树要求更严格）（当数据以升序或降序插入时，二叉搜索树的性能就会下降到最低，但是红黑树的自我修复功能保证了即使在最坏的情况下，也能保证时间复杂度在O(logN)的级别上）。 红黑树是一种自平衡查找二叉树——除了要符合二叉查找树的性质外，还要求根节点和每个叶子节点都是黑色，且叶子节点是空节点（NIL节点），从每个叶子到根的所有路径上不能有两个连续的红色节点，且从任一节点到其每个叶子的所有路径都包含相同数目的黑色节点。 红黑树的特征为——从根到叶子的最长路径不会超过最短路径的两倍。 向红黑树中插入节点（为红色）时，若其父节点是黑色，则不会破坏红黑树，若是红色，则需要做一些调整——变色和旋转 变色——为了防止到根节点的路径上出现两个连续红色节点，将插入的节点（红色）的父亲节点变色，并按路径向上逐个变色（同样为了防止两个红色节点连续出现），直到根节点的子节点层。 旋转——分为左右两种，都是以一个子树为目标，左旋转为子树根节点和其右子节点变为左子结点和根节点（逆时针），右旋转则为子树根节点和其左子结点（顺时针）。子树中的其他节点注意按照二叉查找树的性质妥善安置。 以下是红黑树的源码（Java）—— 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517518519520521522523524525526527528529530531532533534535536537538539540541542543544545546547548549550551552553554555556557558559560561562563564565566567568package tree;/** * @description implementation of Red-Black Tree by Java * @author eson_15 * @param &lt;T&gt; * @date 2016-4-18 19:27:28 */public class RBTree&lt;T extends Comparable&lt;T&gt;&gt; &#123; private RBNode&lt;T&gt; root; //根节点 private static final boolean RED = false; //定义红黑树标志 private static final boolean BLACK = true; //内部类：节点类 public class RBNode&lt;T extends Comparable&lt;T&gt;&gt;&#123; boolean color; //颜色 T key; //关键字(键值) RBNode&lt;T&gt; left; //左子节点 RBNode&lt;T&gt; right; //右子节点 RBNode&lt;T&gt; parent; //父节点 public RBNode(T key, boolean color, RBNode&lt;T&gt; parent, RBNode&lt;T&gt; left, RBNode&lt;T&gt; right) &#123; this.key = key; this.color = color; this.parent = parent; this.left = left; this.right = right; &#125; public T getKey() &#123; return key; &#125; public String toString() &#123; return \"\" + key + (this.color == RED? \"R\" : \"B\"); &#125; &#125; public RBTree() &#123; root = null; &#125; public RBNode&lt;T&gt; parentOf(RBNode&lt;T&gt; node) &#123; //获得父节点 return node != null? node.parent : null; &#125; public void setParent(RBNode&lt;T&gt; node, RBNode&lt;T&gt; parent) &#123; //设置父节点 if(node != null) node.parent = parent; &#125; public boolean colorOf(RBNode&lt;T&gt; node) &#123; //获得节点的颜色 return node != null? node.color : BLACK; &#125; public boolean isRed(RBNode&lt;T&gt; node) &#123; //判断节点的颜色 return (node != null)&amp;&amp;(node.color == RED)? true : false; &#125; public boolean isBlack(RBNode&lt;T&gt; node) &#123; return !isRed(node); &#125; public void setRed(RBNode&lt;T&gt; node) &#123; //设置节点的颜色 if(node != null) node.color = RED; &#125; public void setBlack(RBNode&lt;T&gt; node) &#123; if(node != null) &#123; node.color = BLACK; &#125; &#125; public void setColor(RBNode&lt;T&gt; node, boolean color) &#123; if(node != null) node.color = color; &#125; /***************** 前序遍历红黑树 *********************/ public void preOrder() &#123; preOrder(root); &#125; private void preOrder(RBNode&lt;T&gt; tree) &#123; if(tree != null) &#123; System.out.print(tree.key + \" \"); preOrder(tree.left); preOrder(tree.right); &#125; &#125; /***************** 中序遍历红黑树 *********************/ public void inOrder() &#123; inOrder(root); &#125; private void inOrder(RBNode&lt;T&gt; tree) &#123; if(tree != null) &#123; preOrder(tree.left); System.out.print(tree.key + \" \"); preOrder(tree.right); &#125; &#125; /***************** 后序遍历红黑树 *********************/ public void postOrder() &#123; postOrder(root); &#125; private void postOrder(RBNode&lt;T&gt; tree) &#123; if(tree != null) &#123; preOrder(tree.left); preOrder(tree.right); System.out.print(tree.key + \" \"); &#125; &#125; /**************** 查找红黑树中键值为key的节点 ***************/ public RBNode&lt;T&gt; search(T key) &#123; return search(root, key);// return search2(root, key); //使用递归的方法，本质一样的 &#125; private RBNode&lt;T&gt; search(RBNode&lt;T&gt; x, T key) &#123; while(x != null) &#123; int cmp = key.compareTo(x.key); if(cmp &lt; 0) x = x.left; else if(cmp &gt; 0) x = x.right; else return x; &#125; return x; &#125; //使用递归 private RBNode&lt;T&gt; search2(RBNode&lt;T&gt; x, T key) &#123; if(x == null) return x; int cmp = key.compareTo(x.key); if(cmp &lt; 0) return search2(x.left, key); else if(cmp &gt; 0) return search2(x.right, key); else return x; &#125; /**************** 查找最小节点的值 **********************/ public T minValue() &#123; RBNode&lt;T&gt; node = minNode(root); if(node != null) return node.key; return null; &#125; private RBNode&lt;T&gt; minNode(RBNode&lt;T&gt; tree) &#123; if(tree == null) return null; while(tree.left != null) &#123; tree = tree.left; &#125; return tree; &#125; /******************** 查找最大节点的值 *******************/ public T maxValue() &#123; RBNode&lt;T&gt; node = maxNode(root); if(node != null) return node.key; return null; &#125; private RBNode&lt;T&gt; maxNode(RBNode&lt;T&gt; tree) &#123; if(tree == null) return null; while(tree.right != null) tree = tree.right; return tree; &#125; /********* 查找节点x的后继节点,即大于节点x的最小节点 ***********/ public RBNode&lt;T&gt; successor(RBNode&lt;T&gt; x) &#123; //如果x有右子节点，那么后继节点为“以右子节点为根的子树的最小节点” if(x.right != null) return minNode(x.right); //如果x没有右子节点，会出现以下两种情况： //1. x是其父节点的左子节点，则x的后继节点为它的父节点 //2. x是其父节点的右子节点，则先查找x的父节点p，然后对p再次进行这两个条件的判断 RBNode&lt;T&gt; p = x.parent; while((p != null) &amp;&amp; (x == p.right)) &#123; //对应情况2 x = p; p = x.parent; &#125; return p; //对应情况1 &#125; /********* 查找节点x的前驱节点，即小于节点x的最大节点 ************/ public RBNode&lt;T&gt; predecessor(RBNode&lt;T&gt; x) &#123; //如果x有左子节点，那么前驱结点为“左子节点为根的子树的最大节点” if(x.left != null) return maxNode(x.left); //如果x没有左子节点，会出现以下两种情况： //1. x是其父节点的右子节点，则x的前驱节点是它的父节点 //2. x是其父节点的左子节点，则先查找x的父节点p，然后对p再次进行这两个条件的判断 RBNode&lt;T&gt; p = x.parent; while((p != null) &amp;&amp; (x == p.left)) &#123; //对应情况2 x = p; p = x.parent; &#125; return p; //对应情况1 &#125; /*************对红黑树节点x进行左旋操作 ******************/ /* * 左旋示意图：对节点x进行左旋 * p p * / / * x y * / \\ / \\ * lx y -----&gt; x ry * / \\ / \\ * ly ry lx ly * 左旋做了三件事： * 1. 将y的左子节点赋给x的右子节点,并将x赋给y左子节点的父节点(y左子节点非空时) * 2. 将x的父节点p(非空时)赋给y的父节点，同时更新p的子节点为y(左或右) * 3. 将y的左子节点设为x，将x的父节点设为y */ private void leftRotate(RBNode&lt;T&gt; x) &#123; //1. 将y的左子节点赋给x的右子节点，并将x赋给y左子节点的父节点(y左子节点非空时) RBNode&lt;T&gt; y = x.right; x.right = y.left; if(y.left != null) y.left.parent = x; //2. 将x的父节点p(非空时)赋给y的父节点，同时更新p的子节点为y(左或右) y.parent = x.parent; if(x.parent == null) &#123; this.root = y; //如果x的父节点为空，则将y设为父节点 &#125; else &#123; if(x == x.parent.left) //如果x是左子节点 x.parent.left = y; //则也将y设为左子节点 else x.parent.right = y;//否则将y设为右子节点 &#125; //3. 将y的左子节点设为x，将x的父节点设为y y.left = x; x.parent = y; &#125; /*************对红黑树节点y进行右旋操作 ******************/ /* * 左旋示意图：对节点y进行右旋 * p p * / / * y x * / \\ / \\ * x ry -----&gt; lx y * / \\ / \\ * lx rx rx ry * 右旋做了三件事： * 1. 将x的右子节点赋给y的左子节点,并将y赋给x右子节点的父节点(x右子节点非空时) * 2. 将y的父节点p(非空时)赋给x的父节点，同时更新p的子节点为x(左或右) * 3. 将x的右子节点设为y，将y的父节点设为x */ private void rightRotate(RBNode&lt;T&gt; y) &#123; //1. 将y的左子节点赋给x的右子节点，并将x赋给y左子节点的父节点(y左子节点非空时) RBNode&lt;T&gt; x = y.left; y.left = x.right; if(x.right != null) x.right.parent = y; //2. 将x的父节点p(非空时)赋给y的父节点，同时更新p的子节点为y(左或右) x.parent = y.parent; if(y.parent == null) &#123; this.root = x; //如果x的父节点为空，则将y设为父节点 &#125; else &#123; if(y == y.parent.right) //如果x是左子节点 y.parent.right = x; //则也将y设为左子节点 else y.parent.left = x;//否则将y设为右子节点 &#125; //3. 将y的左子节点设为x，将x的父节点设为y x.right = y; y.parent = x; &#125; /*********************** 向红黑树中插入节点 **********************/ public void insert(T key) &#123; RBNode&lt;T&gt; node = new RBNode&lt;T&gt;(key, RED, null, null, null); if(node != null) insert(node); &#125; //将节点插入到红黑树中，这个过程与二叉搜索树是一样的 private void insert(RBNode&lt;T&gt; node) &#123; RBNode&lt;T&gt; current = null; //表示最后node的父节点 RBNode&lt;T&gt; x = this.root; //用来向下搜索用的 //1. 找到插入的位置 while(x != null) &#123; current = x; int cmp = node.key.compareTo(x.key); if(cmp &lt; 0) x = x.left; else x = x.right; &#125; node.parent = current; //找到了位置，将当前current作为node的父节点 //2. 接下来判断node是插在左子节点还是右子节点 if(current != null) &#123; int cmp = node.key.compareTo(current.key); if(cmp &lt; 0) current.left = node; else current.right = node; &#125; else &#123; this.root = node; &#125; //3. 将它重新修整为一颗红黑树 insertFixUp(node); &#125; private void insertFixUp(RBNode&lt;T&gt; node) &#123; RBNode&lt;T&gt; parent, gparent; //定义父节点和祖父节点 //需要修整的条件：父节点存在，且父节点的颜色是红色 while(((parent = parentOf(node)) != null) &amp;&amp; isRed(parent)) &#123; gparent = parentOf(parent);//获得祖父节点 //若父节点是祖父节点的左子节点，下面else与其相反 if(parent == gparent.left) &#123; RBNode&lt;T&gt; uncle = gparent.right; //获得叔叔节点 //case1: 叔叔节点也是红色 if(uncle != null &amp;&amp; isRed(uncle)) &#123; setBlack(parent); //把父节点和叔叔节点涂黑 setBlack(uncle); setRed(gparent); //把祖父节点涂红 node = gparent; //将位置放到祖父节点处 continue; //继续while，重新判断 &#125; //case2: 叔叔节点是黑色，且当前节点是右子节点 if(node == parent.right) &#123; leftRotate(parent); //从父节点处左旋 RBNode&lt;T&gt; tmp = parent; //然后将父节点和自己调换一下，为下面右旋做准备 parent = node; node = tmp; &#125; //case3: 叔叔节点是黑色，且当前节点是左子节点 setBlack(parent); setRed(gparent); rightRotate(gparent); &#125; else &#123; //若父节点是祖父节点的右子节点,与上面的完全相反，本质一样的 RBNode&lt;T&gt; uncle = gparent.left; //case1: 叔叔节点也是红色 if(uncle != null &amp; isRed(uncle)) &#123; setBlack(parent); setBlack(uncle); setRed(gparent); node = gparent; continue; &#125; //case2: 叔叔节点是黑色的，且当前节点是左子节点 if(node == parent.left) &#123; rightRotate(parent); RBNode&lt;T&gt; tmp = parent; parent = node; node = tmp; &#125; //case3: 叔叔节点是黑色的，且当前节点是右子节点 setBlack(parent); setRed(gparent); leftRotate(gparent); &#125; &#125; //将根节点设置为黑色 setBlack(this.root); &#125; /*********************** 删除红黑树中的节点 **********************/ public void remove(T key) &#123; RBNode&lt;T&gt; node; if((node = search(root, key)) != null) remove(node); &#125; private void remove(RBNode&lt;T&gt; node) &#123; RBNode&lt;T&gt; child, parent; boolean color; //1. 被删除的节点“左右子节点都不为空”的情况 if((node.left != null) &amp;&amp; (node.right != null)) &#123; //先找到被删除节点的后继节点，用它来取代被删除节点的位置 RBNode&lt;T&gt; replace = node; // 1). 获取后继节点 replace = replace.right; while(replace.left != null) replace = replace.left; // 2). 处理“后继节点”和“被删除节点的父节点”之间的关系 if(parentOf(node) != null) &#123; //要删除的节点不是根节点 if(node == parentOf(node).left) parentOf(node).left = replace; else parentOf(node).right = replace; &#125; else &#123; //否则 this.root = replace; &#125; // 3). 处理“后继节点的子节点”和“被删除节点的子节点”之间的关系 child = replace.right; //后继节点肯定不存在左子节点！ parent = parentOf(replace); color = colorOf(replace);//保存后继节点的颜色 if(parent == node) &#123; //后继节点是被删除节点的子节点 parent = replace; &#125; else &#123; //否则 if(child != null) setParent(child, parent); parent.left = child; replace.right = node.right; setParent(node.right, replace); &#125; replace.parent = node.parent; replace.color = node.color; //保持原来位置的颜色 replace.left = node.left; node.left.parent = replace; if(color == BLACK) &#123; //4. 如果移走的后继节点颜色是黑色，重新修整红黑树 removeFixUp(child, parent);//将后继节点的child和parent传进去 &#125; node = null; return; &#125; &#125; //node表示待修正的节点，即后继节点的子节点（因为后继节点被挪到删除节点的位置去了） private void removeFixUp(RBNode&lt;T&gt; node, RBNode&lt;T&gt; parent) &#123; RBNode&lt;T&gt; other; while((node == null || isBlack(node)) &amp;&amp; (node != this.root)) &#123; if(parent.left == node) &#123; //node是左子节点，下面else与这里的刚好相反 other = parent.right; //node的兄弟节点 if(isRed(other)) &#123; //case1: node的兄弟节点other是红色的 setBlack(other); setRed(parent); leftRotate(parent); other = parent.right; &#125; //case2: node的兄弟节点other是黑色的，且other的两个子节点也都是黑色的 if((other.left == null || isBlack(other.left)) &amp;&amp; (other.right == null || isBlack(other.right))) &#123; setRed(other); node = parent; parent = parentOf(node); &#125; else &#123; //case3: node的兄弟节点other是黑色的，且other的左子节点是红色，右子节点是黑色 if(other.right == null || isBlack(other.right)) &#123; setBlack(other.left); setRed(other); rightRotate(other); other = parent.right; &#125; //case4: node的兄弟节点other是黑色的，且other的右子节点是红色，左子节点任意颜色 setColor(other, colorOf(parent)); setBlack(parent); setBlack(other.right); leftRotate(parent); node = this.root; break; &#125; &#125; else &#123; //与上面的对称 other = parent.left; if (isRed(other)) &#123; // Case 1: node的兄弟other是红色的 setBlack(other); setRed(parent); rightRotate(parent); other = parent.left; &#125; if ((other.left==null || isBlack(other.left)) &amp;&amp; (other.right==null || isBlack(other.right))) &#123; // Case 2: node的兄弟other是黑色，且other的俩个子节点都是黑色的 setRed(other); node = parent; parent = parentOf(node); &#125; else &#123; if (other.left==null || isBlack(other.left)) &#123; // Case 3: node的兄弟other是黑色的，并且other的左子节点是红色，右子节点为黑色。 setBlack(other.right); setRed(other); leftRotate(other); other = parent.left; &#125; // Case 4: node的兄弟other是黑色的；并且other的左子节点是红色的，右子节点任意颜色 setColor(other, colorOf(parent)); setBlack(parent); setBlack(other.left); rightRotate(parent); node = this.root; break; &#125; &#125; &#125; if (node!=null) setBlack(node); &#125; /****************** 销毁红黑树 *********************/ public void clear() &#123; destroy(root); root = null; &#125; private void destroy(RBNode&lt;T&gt; tree) &#123; if(tree == null) return; if(tree.left != null) destroy(tree.left); if(tree.right != null) destroy(tree.right); tree = null; &#125; /******************* 打印红黑树 *********************/ public void print() &#123; if(root != null) &#123; print(root, root.key, 0); &#125; &#125; /* * key---节点的键值 * direction--- 0:表示该节点是根节点 * 1:表示该节点是它的父节点的左子节点 * 2:表示该节点是它的父节点的右子节点 */ private void print(RBNode&lt;T&gt; tree, T key, int direction) &#123; if(tree != null) &#123; if(0 == direction) System.out.printf(\"%2d(B) is root\\n\", tree.key); else System.out.printf(\"%2d(%s) is %2d's %6s child\\n\", tree.key, isRed(tree)?\"R\":\"b\", key, direction == 1?\"right\":\"left\"); print(tree.left, tree.key, -1); print(tree.right, tree.key, 1); &#125; &#125;&#125;","tags":[{"name":"array","slug":"array","permalink":"http://yoursite.com/tags/array/"}]},{"title":"PONDER","date":"2020-07-11T12:08:40.000Z","path":"2020/07/11/PONDER/","text":"关于行业&amp;领域的一些思考——产品溢价&amp;AR/VR&amp;机器学习的落地 产品溢价首先产品溢价是一个自创的概念，我把它定义为由于某产品的价值较高，而导致其周边产品的价值也偏高的现象。 品牌溢价是我们所熟悉的，而且很多企业都很好的利用了这种“感情价值”，这是一种消费心理所导致的现象，其直接表现就是品牌的附加值，这部分投入其实在一定程度是集中在了运营和市场，以及现在很火热的舆情。 这其实也属于我们所期待的市场的一种形态。 高附加值产品就是一个长久的资本企业所追求的核心要义，只不过市场让其变得复杂了，这种高附加值可以通过技术的垄断、资源的占有、市场和品牌的运营、甚至甲方的愚蠢（信息不对等）而产生。 附加价值是企业通过生产过程所新增加的价值;或者，从企业的销售额中扣除供生产之用而自其他企业购人的原材料成本，也就是企业的纯生产额。 到底怎么样的附加值产生方式更健康，很难靠一家之言蔽之。我想要讨论的也是一种附加价值的产生方式——产品溢价的方式。 众所周知，苹果手机的手机壳比小米手机的手机壳要昂贵很多，又比如同样非品牌的咖啡店，昂贵地段的咖啡的周边要比便宜地段咖啡的周边售价高很多，现有（也可能是我仍未知的）的一些价值理论无法解释这种情况，这并不是简单的附加价值，其仅仅是由于该产品所服务的产品价值更高，所以该产品相对价值更高。我将其称为产品溢价。 其实这是一种公知或者说是常识，我们想当然的认为装珍珠的袋子比装石头的袋子更加精致（当然有些情况下确实如此），所以面对价值更高的产品，我们会在后续愿意花费更多钱在相关的产品上，价值更高包括售价更高，但不限于此。比如二次元手办，其价值不只是来源于精致的细节刻画，更多的来源于消费者对其原型的一种感情价值，消费者愿意为此买单，但周边手办不全是创造原型的产业生产的，这就出现了产品溢价——二次元形象被创出的时候成本包括设计到剧本人设故事情节到美工以及后期的市场运营，涉及到甲公司的方方面面，这些时间人力物力成本造就了这个产品，但甲公司的收益大头往往是直接的版权费以及一部分周边带来的盈利，但其产品，如设计的二次元形象，还有很多的潜在价值尚未被利用和挖掘，比如众多需要被授权才能商用的方面——邮票、游戏、图书、舞台剧等等，如果是拿到了版权费，那说明这是一个健康的市场，但更多情况，大型的IP是无法保证不被侵权的，这种情况下的周边，就是产品溢价的情况，其利用了原作品的价值的溢价（高附加值也好，感情价值也好），来提高了周边的产品价值，从而获得了商业利益。下面把原作品称作主产品，原作品的周边、延申、配件等称作从产品。 类似案例还有很多，很多情况下不涉及侵权，而可以正大光明的利用产品溢价来提高我们的产品价值，从而获得利益。其不限于影视艺术作品的这种溢价（不得不说这种情况很常见），包括汽车内饰，同样的摆件，作为礼物可能只有十五元，但作为汽车摆件就需要五十元（汽车是主产品）；同样的计时器，用于做饭只能卖十元，但当作番茄闹钟用于自习（番茄闹钟学习法和学习本身是主产品），就可以卖一百元…这种情况还很多，如果可以找到合适的又具有很大市场的主产品，就可以通过产品溢价的原理，由从产品获得很大的利益。 这是一种商业思路，同时也是一种产品设计思路，本文仅仅举例阐述产品溢价这种规律和效应，由于用例有限，还只能作为一种思想，有待调整和证明。 AR/VRAR和VR是我一直关注的领域（我把MR视为AR的升级和迭代，一定要区分的话，MR更侧重虚拟图像的现实感，AR更侧重信息量，但MR的要求明显更高，AR包括MR）。 我一直相信这两个领域会在以后让人们的生活方式发生翻天覆地的变化，就像电视，就像手机等，其不仅仅是一种更真实的画面处理，其在客户端是一场人机交互的革命。 不论是各大巨头（微软、苹果为首），还是各种新型创业公司（亮风台等）都早已入场，B端用户也在试图找到出口（如腾讯），但效果都不如人意。由于5G技术的发展，AR和VR又站在了资本的舞台上，我的理解里，5G更多的是降低AR和VR的运动到成像的时延，其价值后文再进行深究。 AR\\VR领域已经发展十余年了，其仍旧更像是一个概念，和人们的生活相距甚远。微软已经把AR推向了工业生产，更安全、高效的辅助道具，从软件到硬件，国内的领头羊也把toB作为了主要方向，这是很多人尝试后的结果，但即便如此，此领域的公司盈利还遥遥无期。 我多次思考，这个技术到底缺了什么，是交互性，是成本过高，亦或是落地困难…当一件事找不到答案时，我们习惯于在以往的经验中进行类比思考。 我认为AR和VR的核心是交互革命，而这种交互对自然语言的处理要求更高，用户需要通过更简单的方式，更小的可佩戴硬件，向计算机传达指令，有一种方式十分适合AR/VR——手势，这就需要人工智能以及机器学习的帮助，自然语言识别的增强和反馈。 成本从来都不应该给用户来考虑，如果无法普及，只能证明工业生产和资本运作的方式不对，以至于一个有价值的技术和产品只限于少数人，当然这个技术或者产品必须是有价值的，最好解决了用户的痛点（汽车），或者其娱乐性所向睥睨（影视），我认为，为了行业的发展，这个技术的切入点的最佳解可能并不是优化生产效率，我认为一款足够优秀的游戏作品可以吸引更多的用户，更多的用户可以吸引更多的资本，如此才能把整个行业盘活。3A大作并不少，或许游戏会像电影促进建模仿生技术发展那样，促进AR和VR的发展呢。 落地需要更实际的场景，人工智能的落地其实并不如人意，但人工智能有前面的大数据和后面的云服务，两座浪把人工智能推的舒舒服服的，AR\\VR领域就缺少了这种相关领域，所以才会感觉后劲不足，但这个领域的价值如果存在，那么找到靠山其实并不困难，这需要我更深造，学的更广泛和深刻，才能感知到两种技术可能发生的化学反应吧。 我在淘宝上看到了一款很基础的AR游戏——射箭（通过手机屏幕，连接实体的发射器，实现AR）。这很上面的分析和观点论证——一种技术的兴起，能称之为革命，一定是解决了巨大的痛点或者是在娱乐（消费）方面有所突破，而游戏正正拥有着这个娱乐时代的顶流，FPS类游戏的核心就是第一人称视角对真实战争的模拟，强调代入感，而大型游戏机中的射击类游戏也很受欢迎，这正是AR或者VR的用武之地。但就FPS游戏的设计角度，需要实现游戏中第一人称移动方面的人机交互，更吸引玩家和资本的RPG类游戏中，移动方面的人机交互也是核心，如果实现了这种交互方式，那么加上VR技术，我想应该可以把游戏体验提高到一个很高的高度了。 AR和VR的应用面还很广泛，很多前辈和老师也在探索，就我认为，家装和游戏应该是两个很好的方向，资本很足，也解决了足够的痛点，但家装只是提高服务方面的用户体验，并不属于用户买单的核心产品，所以用户可能并不会为此买单，即使现有的案例中可以看出效果其实尚可。接下来我会尽可能深刻一些的分析游戏中移动方面的交互实现方向以及可能的方式。 先从人机交互说起。 人机交互现在最大最热的几个方向技术——语音交互技术、图像识别技术、AR和VR以及体感交互技术。语音交互自然不必多说，这可以说是现在处理自然语言最成熟的技术，键盘鼠标相对原始的人机交互，需要人类自己通过学习，把希望表达的内容和信息转化为字符，再从输入设备输入，而语音交互则不需要用户进行这样的学习，其交互更接近人类的生活习惯，国内的科大讯飞在这方面很成功。当然不论是文本的输入，还是语音的信息处理输入，都是建立在广义的自然语言识别（NLP）的基础上进行的，由于自然语言的种类情景多变，但传达的信息却可以分类，所以随着机器学习的兴起，NLP也成了大热的研究方向，通过聚类的分析等（学识有限），对自然语言进行识别处理，随后进行计算，再通过自然语言生成系统输出，这也就是计算机作为一种工具，在用户层最本质的逻辑。 已经说到了这些机器学习的大热方向，也就这样的方向继续聊聊吧。 当下计算机的算法方面比较火热的三个方面，自然语言识别（NLP）、计算机视觉（CV）、推荐系统。这三个方面都和大热的机器学习有些关联，NLP是分割字段，提取关键词后构建语义向量，然后再将语义组合，通过机器学习进行聚类等分析；CV则是先通过边缘监测，提取图中的核心区域，然后通过特征选择，一般为过滤法（还包括包裹式和嵌入式），进行降维和泛化，然后进行分类，再训练学习器；推荐系统则分为选择用户还是产品，以用户为例，提取其物品特征，然后构建网络进行分类，对其进行打分和聚类分析，训练学习器。 可以看出，三个方面大热的主要原因都在学习器，学习器大大降低了本来的数据分析成本，而深度学习正是由大数据延伸出的技术，推荐系统正是大数据浪潮中的数据分析的常用模型，由于巨大的商业价值（用户粘性）而站在了，而NLP和CV则都用到了表征学习方面的内容，如向量化后构建网络，深度学习则是更基础的内容。常用的深度学习框架又有深度神经网络、卷积神经网络、深度置信网络和循环神经网络等。 深度学习是一种对数据进行表征学习的算法，如用向量去表示关键词和子图，然后用（非）监督学习对目标特征提取。表征学习的特点我引用维基百科上的描述：“表征学习的目标是寻求更好的表示方法并创建更好的模型来从大规模未标记数据中学习这些表示方法。表示方法来自神经科学，并松散地创建在类似神经系统中的信息处理和对通信模式的理解上”。 人工智能+大数据&gt;机器学习&gt;深度学习&gt;神经网络，而这些数据的类型的不同则决定了深度学习所发力的领域了。 扯到了很远，但其实都很基础，计算机发展迅速，若想在学术上有所造诣，只能专精一个方向啊，但是如果是商业实现，那么重点在落地了，这也是本文第三部分想说的东西。说回人机交互的大热领域，解释完了语音识别后，图像识别也就是CV的方向了，也使用了深度学习的模型，只不过是更明确的目标，可以使用监督学习来达到目标。 AR、VR以及体感技术，前两者是本节主要讨论的目标，把他们归类在交互中其实有所牵强，因为这两个的目的都是沉浸感，不仅仅是交互，其中重点更是在移动和显示等方面，可以理解为上面的自然语言生成的一种革命，而其余的交互更多的是自然语言处理的进化，我想这个道理还是想的明白的。体感技术则是人们通过肢体动作，与周围环境和装置直接互动，相比于语音、语言，这种交互的情况更复杂，类型更多，我的学识有限，并不知道是否一样可以通过向量化来进行处理，并通过训练学习器来优化这种处理效率和结果。 一样的，面对陌生的无头绪的问题，我们可以通过类似的案例，进行类比分析来找到出路，接下来我将介绍和分析科大讯飞的人机交互解决方案AIUI。 AIUI除了升级了无效拒识、纠错、上下文理解能力，还加入了语境和情感分析，在交互的角度来看，AIUI在交互链路中增加了语音唤醒系统。AIUI的人机交互流程分为感知、认知、处理、表达四部分。在AIUI中有3种不同交互理解功能的设计：任务完成型的交互理解、基于知识图谱的知识问答类型、基于问答库的闲聊或问答。而这些技术中最核心和困难的就是语义的提取，语义提取又分为显规则提取和基于深度学习的语义提取。对于自然语言的处理（NLP），需要更多的依靠深度学习中的RNN循环神经网络和CNN卷积神经网络。而语义提取其实是NLP中的自然语言理解（NLU）的工作，而NLU的困难同时也是核心工作，其实是对文本序列背后的特定语义结构进行预测，这是中文分词、词性标注、命名实体识别、共指消解、句法分析、语义角色标注等工作的基础，这需要更完备高效的语义结构，这样才能进行归类和预测。 相比于更倾向于办公效率优化和辅助的AR（增强现实），我认为VR更容易造就游戏界的革命，最追求沉浸式体验的产业当属游戏领域。 类比语音识别前，我先聊聊沉浸式体验。 不得不说，我想要记录下来的东西很多，很杂，但我认为，知识要的不是专精，专精是精于一个问题，一个领域，一个细节的处理与优化，所以我希望在讨论VR的时候，尽可能不要遗漏与其有关的任何部分。 沉浸式在字面意义上其实很好了解，在安卓开发中，沉浸式设计就是把安卓系统边框透明化，并且把交互按钮尽可能隐藏，使用APP的主要内容尽可能的填满屏幕；而在电影和文学设计中，则讲究通过镜头语言，实现表达、内容结构、形式与意义的关系（叙事学），叙事学是在《十日谈》中被提出的概念，其讲究的是一种表里关系，后来这种理论和概念在空间设计中也常常被提及，很成功的案例，如迪士尼，就是标准的沉浸式设计。但这些其实并不直观，就我的理解，沉浸式其实是从用户体验的角度来说的，所以我认为，任何可以使用户获得沉浸式体验的设计，都能称为沉浸式设计（当然引人入胜的诗词、山川，那不能称为设计，设计应该是有意识和目的的），沉浸式如果要从心理学的角度分析，那应该是心流体验的代言词，或者说，心流体验应该是沉浸式体验的更深刻更持久更强烈的状态，心流体验更强调认知和意识，而沉浸式体验更强调感官。沉浸式设计最普遍承认的是叙事型设计（赵江洪的《设计心理学》），即通过讲故事，通过气氛角色情节等等来让用户带入其中，迪士尼就具有很强的叙事性；在游戏设计中则是把各种导航和操作交互藏在内容为主的情景中，这样就让用户把注意力更多的集中在游戏的主要内容上，更沉浸其中，如王者荣耀的方向键是隐藏的，DNF中主线的触发、技能的学习和装备的升级等都是通过和NPC交流实现的，这样玩家注意力可以更集中于游戏本身，从而获得更好的体验，当然除了这种隐藏式的设计，还有画面、操作、反馈和节奏等都是很重要的因素，通过这些部分的设计也可以达到沉浸式体验的效果。但显然这个原理并不是很试用于VR的设计。 VR的沉浸式设计其实很明确，即通过声音和视觉（3D、动态视角，高FOV）,加上体感交互，就可以实现现实和虚拟的颠倒，这也是VR的革命之处。 接下来我将分析VR技术需要解决的一些问题。 晕动症——由于延迟，清晰度——人眼要求中心像素高，GPU不足；以及我最想谈的交互方式。VR的交互和传统交互不同，VR作为一种输出设备，必定需要输入设备来与之搭配，双手交互的精度和处理效率要求很高，双手柄的交互方式则对用户和硬件要求较高。 对于VR的玩法，先引用XboxOne 平台的体感游戏开发团队的日志—— 由于头部运动追踪的存在, 点头和摇头的操作是可以被识别的, 这就意味着很多 Yes/No的操作可以直接通过头显输入；头部的朝向可以灵活变化, 当你”盯”着某个物体看时,可以针对这个行为做出相应指令, 具体可以参考 GearVR 上的 Land’s End；由于360度视角方向不受限制, 我们可以在背后做一些场景改变,让每次转头看到的场景都不一样, 既能做成惊喜, 也能做成惊吓；头部不仅仅可以转动,还可以配合身体小范围移动, 比如 Summer Lesson 中凑近 NPC, NPC 会害羞……Vive的一个上帝视角 Demo 可以蹲下看到地底下打地道的小兵；VR 渲染可以调整 WorldScale,即世界单位缩放, 相当于动态调整自身相对于场景的比例, 既可以做成巨人的视角,也能做成蚁人的视角；因为 VR 世界中的单位可以与现实不一样,那么一些类似”缩地术”的功能也变成现实, 通过身体小范围的移动,达到虚拟世界中的大范围移动效果；双手控制器的存在可以模拟一些抓, 扔, 摸,打等的操作, 捡起一个道具上下左右仔细看也是很有意思的一件事,可以把迷题设计在道具的隐藏角落里；VR 中有了双手的存在,很多解迷机关就不再是简单的按一个键, 各种零件组合, 机械,绘画等对于双手控制器来说都是很棒的操作体验；控制器的握持感,非常接近于游戏中的手持武器, 比如枪械, 比如刀剑,这比握着一个鼠标或者手柄的感觉强多了. 得益于高精度的传感器,做出具有竞技性的操作玩法也不是不可能；双手具有天然的空间感,一些建造类的玩法也非常适合, 比如 MineCraft, 比如 Besiege 等, UE4 甚至尝试了在 VR中进行场景编辑；由于3D 音效的加强(下面会提到), “听音辨位”就可以做得更真实,各种潜入类玩法非常适合；另外, 由于沉浸感的增强,恐怖游戏和XX游戏带给人的感官刺激会放大, 这就不用展开了, 试过就知道。 对于VR的游戏方面我研究还有限，前辈的想法颇多，特此记录，以便往后反复思量。 我认为VR的移动交互是很需要实现的内容，第一人称视角的自由移动，HTC的解决方案也只能做到5m×5m，是否可以做到模拟真实的运动场地呢，如果可以实现，那么通过传感器来记录动作和模拟距离其实很容易实现。 是否有这样的设备呢，可以记录移动，并且给人真实的移动感。作为沉浸式体验，当然想要虚拟人类的各种感官，VR更多的是在视觉和听觉上进行模拟，而在游戏中，不可忽略的部分当属移动，移动也是最大化自由视角的重要方式。那么有什么方式可以模拟出移动呢，我简单的举一些例子： 摇杆，很经典的游戏移动的交互方式；键盘，由于VR，可能需要进行虚拟；螺旋仪，需要用户进行接受和适应；手柄，当前比较好的解决方式。 其实我认为，具体的操作方式最好按照不同的游戏来进行设计，如竞速类游戏，就可以简单的通过手部交互来满足游戏需求，如果一定要移动，那可以通过机甲等元素来实现，这样玩家更容易接受和适应，整个游戏设计的叙事性也更强更完整，虚拟的也更彻底。考虑到成本问题，我认为VR方面的交互可以有新的思路，比如把电脑设备的显示屏接入在VR的视野中（3D，VR），其他的部分（如键盘，甚至显示屏（护眼，沉浸式学习工作））仍然全是虚拟的，这样用户的交互都放在VR中实现，这样算是实现了VR的整个逻辑。 接下来我将梳理一下VR的制作流程，以及游戏的制作，然后类比语音交互，尝试引入机器学习来提高VR相关工作的效率并降低其成本。 VR分两大种，实景拍摄（通过全景合成软件制作3D）和3D建模，3D建模又分为第一视角是否可以移动。3D建模一般使用unity或者UE实现，关于unity和UE这两种引擎，我并不了解，这里借用一些前辈的观点加之我的理解和总结，记录后以便反复思量。 UE比起开源的unity成本更高，同时也更适应于高端设备的显示效果（3a大作），unity则更适合在移动设备或者web上进行开发。学习路线（unity）：C#-SQL-EFCore-web&amp;TCP/http-Lua。有前辈提到，UE作为游戏引擎，可视化设计器做的很优秀，但由于托鼠标造成的项目冗余过高，只能重构轮子，导致效率降低，总之，UE相对来说对美术生更友好，而对于程序员来说，可能门槛降低带来的代价还是过于沉重，不过也因此，Unity更适合单人项目，UE在制作时更需要团队的支持。Ogre3D中文站站长有句话很棒，希望我以后如果从事相关工作也可以谨记——图形学的天花板在硬件，引擎绝不是阻碍你的原因。 继续分析VR的基础内容。 VR之所以可以沉浸式，是因为用户视角在一个三维空间中，这就要求将本身的全景二维图，投影到一个立体的空间（如球面纹理映射）。对于VR的播放器，如VRPlayer，还有开源的VR开发可以使用Google的主页——https://developers.google.com/vr/。（在google vr sdk for android中 有一个cardboard的sample——treasurehunt，研究源码可以快速学习）；关于硬件方面，涉及到第一视角移动和体感交互，常常使用九轴传感器（加速度传感器、磁力计、陀螺仪），需要考虑的有瞳距、FOV、畸变、ViewPortRect等。 接下来就是VR方面的开发，SteamVR插件是全免费的（Valve），此外我们还需要一个VR设备以方便我们的调试，以游戏开发为例（http://robotinvader.com/blog/（deadsecret），函数查询http://wiki.ceeger.com/ceeger.php）。 再简单介绍VR之后，我还想提一下计算机图形学。 在games的前几个论文，大部分都是把3D和神经网络相结合，获得一个智能化的东西，或者用图形学解决实用的问题，计算机图形学更多的是解决3D的问题。3D和VR有天然的桥梁，我想这就是把机器学习引入VR的大好渠道。 加之语音交互中人工智能的解决方案的参考，会发现VR的几个问题很需要人工智能来解决，比如帧数，晕动症，这种问题完全可以通过机器学习来预测用户的下一步动作，而早做准备，提前进行画面渲染等。 如果希望把机器学习和VR结合，还需要多研究计算机图形学的前沿论文，相信这样也可以更快的找到答案。 机器学习的落地机器学习相关的历史和研究方向在上面两部分已经讨论过了，这三部分看似不是很相关，但深入思考，会发现这三个命题之间的关系千丝万缕。 想要迎合现在的市场风口和计算机发展的方向，不可避免的需要涉及到机器学习的内容，而VR/AR在20年被苹果公司提上了日程，虽然很遗憾的，由于其内部分歧，AR眼镜的发布被推迟了，但最晚22年也会与世人相见，同样的20年5月，UE5问世，学疏才浅，我简单的了解后，仍旧无法判断UE5是否可以解决VR游戏的巨大问题，并且在我的理解中，UE或者是unity更多的是类似于Axure这种涉及软件，是另一领域的高级UI设计，所以可能并不适合我，相比来说，我更希望从事底层的研究。 AR/VR的话，我认为做成我的世界一样的沙盒游戏也是很棒的方向，可以避免性能方面的不足，同时可以得到很棒的游戏体验，渲染的要求也较低；或者是沉浸式办公学习的产品，难度其实很有限，像面对面的聊天，已经被实现了，这种产品的开发门槛同样需要被考量。 回到机器学习，对于机器学习的就业和研究方向，我看到越来越多的前辈呼吁，一是要交叉，交叉学科才是硬道理；二是要落地，机器学习要落地到工业生产，在学习器模型已经比较成熟的情况下，是否可以融会贯通，不仅仅是调参，而是和实际的工业生产相结合，产生真正的商业价值，这才是市场和资本需要的能力和技术。 所以下面我就机器学习和AR/VR以及其他学科的交叉领域，在相关的领域中落地，产生商业价值，解决市场痛点等方面，进一步思索。 微软早在2017年便开源了一个“空中信息与机器人平台”，这是一款通过高级虚拟现实训练人工智能的系统。可通过在VR的虚拟环境中模拟无数有细节差异的场景对无人机进行训练。节省了大量枯燥无味且耗时巨大的工作，同时还能全面彻底的对无人机进行障碍物覆盖。这个系统同样适用于无人驾驶的领域，这种通过VR协助人工智能的思路是很值得学习的。 此外关于VR游戏，对于游戏设计，和普通游戏有所不同。就来自First Contact Entertainment公司的Adam Orth的观点，在虚拟现实开发者大会上（2017），除了包括一些经验之谈，如他提醒游戏开发者，不要将环境设置得过于复杂，阻碍玩家对游戏的探索。如果在一款游戏里玩家无法自由移动，那么就不要在游戏世界里设置太多弯弯绕绕，要让玩家的视野尽量开阔——“游戏开发者要确保玩家不会觉得自己错过了游戏世界里的什么东西”；还有，不要把游戏人物或是物体设置在玩家背后，以免吓到他们；人物的可信度远比精细度要来得重要，可以对化身进行简化，以防止模型存在违和感，VR中虚拟人物确实可以表现出肢体语言，即使只有三点数据；此外，还有VR技术本身就提供给玩家一种“临场感”的观点，通过VR捕捉一些感觉，如太空，通过互动创造沉浸感——“你可以利用这个机会来让自己的虚拟世界变得非常真实，但你所写下这一规规则要统一适用于这个世界中的所有物品”以及“让一些高画质的物体离玩家近一点，让一些低画质的东西离他们远些，这能够提升让整个体验的质量”，要确保玩家看到的以及摸得到的东西都很精细；还有很重要的观点和建议——“不要低估了力反馈以及音频在游戏中的作用”。另外还有一个命题，就是多人VR游戏，很前沿的尝试有育碧的《星际迷航：舰桥船员》，但是多人游戏，甚至网络游戏中，如果玩家互动增加，人数增加，延迟的现象会更加严重，从而影响玩家的沉浸感，同时配套的外设也是多人参与中很大的阻碍；要处理的还有玩家之间的空间问题，碰撞、交互以及语音通话等，要保证沉浸感。还有一个很重要的观点，就是建立合理的反馈机制，这也是VR向未来发展很重要的过程。 VR还在试穿和化妆预览、家居装修、推销等领域已经有了落地的实现，这些领域的VR应用往往也伴随着人工智能。 Makeup Genius，这是一个移动应用程序，它使客户可以在决定购买化妆品之前对其进行虚拟试用。该公司声称该技术使用面部跟踪或面部动作捕捉，这是一种计算机视觉技术，可通过实时映射面部标志的64个数据点来确定图像中的图像和视频数据，以确定头部姿势，面部表情和不同的肤色。在嘴唇，脸部和面部轮廓上。该公司还声称，该应用程序的面部识别算法经过培训，可以确定年龄，种族，性别，面部毛发和其他属性。Snapfeet，同样是一个移动应用程序，该应用程序声称可以使购物者根据双脚的3D生物特征扫描来虚拟地穿鞋。据该公司称，在扫描购物者的脚后，该应用程序可以推荐最适合客户的鞋子尺寸和型号。使用从多个角度拍摄的客户脚的照片，该应用程序的生物特征识别功能将创建脚的3D图像。将图像保存在应用程序中后，其算法将对图像进行排列并在生物特征识别就绪后发送通知。家居和商务平台也类似。还有很新颖的思路是营销虚拟现实，类似于用VR来训练学习器，这里是用VR来模拟实际环境中的零售，从而制定营销策略。不可否认，VR头戴式耳机仍旧是阻碍VR落地的主要因素之一。 下面引用一些大牛的观点和思想： 就人工智能对VR产业的推进，工业和信息化部电子第五研究所副所长王蕴辉：一是渲染处理。深度学习的渲染成为人工智能在图像渲染领域的重要创新。二是内容制作。以真实用户的虚拟化和三维重建为发展对象。进一步增强VR内容的交互性，以真实用户为对象的虚拟化身成为近期的热点，传统的方法依靠的是昂贵的设备和繁琐的后期处理，新一代的方法是基于深度学习技术，通过学习知识可以从一个或者是多个二维头像中，恢复物体的三维几何和结构，而无需复杂的过程。三是感知交互，通过结合计算机视觉与生理信号的反馈，打造虚实结合的体验。VR技术大大提升了VR的体验。 多伦多大学计算机科学系教授基罗斯.库图拉科斯：主动3D成像将在清晰度和分辨率上改善VR/AR。3D相机对于虚拟现实产业的发展有着非常重要的作用。3D相机其实和我们之前所使用的相机完全不同，这些3D相机可以测量距离，通过加工光线的强弱来测量照相的距离，并且可以对周边的环境进行一些测量，他们可以应用到手机、耳机、眼镜等等里面，或者可以放在车上。我们所研发出的这个相机，它有很多的体系，能够引入到很多的体系中，也就是我们称为主动的3D成像，可以用在我们的经济体系中，通过使用这种主动的3D成像技术之后，可以进行建立3D的成像体系。相机里面有不同的系统，它们在设计的时候，就可以应用到很多复杂的应用中。而且成本也可以有所控制，这些设备其实能够使用不同的技术、高端的或者光速技术，以及能够使用商业的扫描技术中，而且可以在很长的距离中，可以实现3D成像技术。而且他的精度也很高，它的清晰度、分辨率都很高，能达到微米级的距离。因为使用的是三角测量的方式，它的准确度很高，而且短距离和长距离的摄影效果都非常好。这种相机目前是高端技术，它的价格可能会稍微高，它可以使用很多的3D的成像点进行连接。 叠境数字公司联合创始人、CTO JasonYang：利用深度学习实现更少拍摄带来更精准重现。表情研究、表情分析在AI中的应用以及VR中的应用越来越广泛。我们公司的业务之一是对表情进行分析研究。 加州理工学院计算与数学科学教授马修.德布伦：机器学习与粗粒化研究相结合，能够提升模拟的精准度。人工智能、虚拟现实可以在很多方面帮助我们进行改进，获得提高。比如利用虚拟现实与人工智能结合进行外科手术培训，可以帮助医生提升以后手术的精准度。比如我们通过人工智能、虚拟现实的方式进行检测、测试肝脏在进行手术的种种情况，让外科医生了解在手术过程中怎么样操作才能更好。 特尔VFX特效负责人、电影艺术学院成员赫莲娜·派克：在虚实现实中，我们通过人工智能帮助我们塑造自然的环境，把人的情绪植入到虚拟世界中。比如《复仇者联盟》，他们使用的就是渲染以及人工智能和塑造建模的方式，提升动作上的相互匹配度、数字化人物的灵活度。目前，我们可以使用人工智能的方式把人和场景进行分割，可以把人区分出来放在不同的场景中。还通过粒子的模拟方式，帮助我们进行仿真，比如对火、烟、水进行仿真，通过人工智能仿真可以看清火的特性、形状，以人工智能的方式将其创造出来。我们希望缩短模拟仿真时间，也在致力于通过手机就能完成，加速我们拥有更多更好的VR方面体验感。 中国移动研究院云VR项目负责人李可：5G、AI与VR密不可分。一些痛点：第一是我们希望VR业务能变成大众型的业务，能走进千家万户，但目前高端VR设备依然比较昂贵。第二是VR设备便携性不够。VR头盔在工作单位、工厂里可以用，但是在家里放一个很复杂的VR设备就不太现实。第三是目前VR设备用户体验感尚无法达到替代手机和平板电脑。所以VR/AR在价格、便携性和体验上还有很多工作要推进。而5G的传输能力和边缘网络的计算能力，可以增强VR设备的处理能力，降低设备的价格。5G和4G的区别是边缘网络和边缘计算能力的增强，这对无论是游戏还是渲染业务都非常有帮助。AI与VR一直密不可分，VR本身就是AI技术的一个分支，VR对于位置、运动追踪，都依赖于AI的能力。所以5G和AI能力对于VR业务非常重要同时也密不可分。 最后还有Facebook利用机器学习为移动VR构建的全新低延迟高效能图形渲染框架，论文地址为https://dl.acm.org/doi/10.1145/3355088.3365154。团队介绍了一个为VR一体机的渲染管道运行机器学习的全新低延迟高效能框架。这个架构允许所述设备利用机器学习来显著提升图像质量和视频渲染。研究人员根据这一框架创建了一个示例应用，它能够重建更高分辨率的渲染（称为超分辨率），以最少的计算资源提高移动芯片组的VR图形保真度。这个全新框架同时可以用于执行面向的流式传输内容时的压缩伪影去除，帧预测，特征分析，以及针对引导式注视点渲染的反馈。 了解了这么多想法，再来看一看VR和人工智能以及落地的问题。 VR在原理上有个需要解决的问题是分辨率，由于畸变和FOV值，分辨率一定要解决；VR在游戏中需要解决的问题，一个是延迟，多人游戏的问题也是延迟，会影响用户的沉浸感，二个是交互，交互包括NPC的表达以及反馈机制等，体感是一个方向，但带来的问题也不小；VR在使用方面，可以对人工智能甚至营销策略进行训练和优化，很多实验，可以通过VR对现实进行捕捉，如电影中的科幻模型，但这更偏向于3D的领域；VR的直接使用还有对表情的捕捉和管理，这可能也是CV的交叉，同时可能涉及到心理学，以及3D相机，通过人工智能测距测温达到直接生成VR的效果，也是属于VR这个大命题的主战场了。最后是硬件方面，VR产业除了需要3D相机外，还有必不可少的头戴式外设，价格昂贵，其功能还是无法触及和解决人群的痛点，很难像计算机一样普及起来，这也成了很多领域推广VR的巨大阻力。 VR需要解决延迟，分辨率，交互，外设，生产成本，模型的诸多相关内容等。 关于机器学习的应用，可以解决延迟，通过预测下一帧；解决分辨率，同样通过预测；解决交互，以体感为主，其实不是VR方向了，只是体感更接近沉浸式体验，更和VR同源；解决生产成本，直接拍摄出VR的3D环境，快速搭建VR场景，这需要通过人工智能来实现；再有就是游戏方面的提高了，通过人工智能制造出有感情的NPC，这其实是计算机视觉的活。 接下来是两个我深以为然的观点： 「对于绝大部分人而言，努力成为交叉领域的熟手，远比成为计算机科学家要现实且有意义」。 能够站在机器学习“工程体系”之上，综合考虑“模型结构”，“工程限制”，“问题目标”的算法“工程师”。 这句来自于清华毕业的王喆老师。 技术需要服务于目标。 朱小强在“深度学习推荐系统”这本书作序时写的一段话结尾: 在工业级深度学习2.0阶段，技术演进的模式将再升级：从算法视角的实践和问题驱动，进一步拓展到更宏大的技术体系整体思考：领域问题特性、数据、算力、算法、架构及工程系统等将被纳入统一的思考框架中，成为技术创新的发力点。 工业界和资本需要的是可以把技术落地的，可以把学术连接到工业界，从而灵活解决问题的人才；而学校和人类需要的是专精一个领域以及从理论开始研究并搭建高楼的人才。 人工智能的落地已经在很多产业实现，或是解决巨大痛点，又或是产生商业价值，就VR的落地成本和复用仍旧需要探索。 本来感觉真相很近了，写到头，思索到失去焦点，才感觉真相仍旧遥不可及。大概这就未了解一个领域，会感觉简单清晰，但逐渐了解一个方向和领域后，才感觉到一无所知，才开始明白需要解决的问题，可能遇到的困境，每一条路都不易。 希望自己在以后谨记此时的思索，进入这片领域的海洋后，心里仍旧有方向，思索仍旧不止。","tags":[{"name":"x","slug":"x","permalink":"http://yoursite.com/tags/x/"}]},{"title":"x+","date":"2020-05-27T09:22:47.000Z","path":"2020/05/27/x-1/","text":"X+==== LeetCode刷题先做五个tag：array，string，tree，linkedlist，math。 每个tag内部就按照easy-medium-hard的顺序做，开始一天刷10道easy，后续保持。 其实，从2019开始，业界对AI的技术方向就已经达成了共识，也就是深度学习+大数据+大计算，其中尤其以数据为重。可以说只要数据足够，假以时日，大家的速度和精度都不会太差。现在大家比拼主要是算法变现的能力，也就是看谁能够把算法变成产品销售出去，因此今年我的感觉是，相对于纯粹的算法，综合性人才更稀缺，例如有既有产品思维，懂算法，懂编程的人。 ——知乎_沈世钧 数据科学数据工程师前 5 项主要技能是：SQL, Java, Python, Hadoop, 和Linux。第一步学Java基础, 或者Python；第二步学习系统语言最少掌握LINUX；第三步掌握一门数据库语言 ORACLE /DB2；第四步学习SHELL编程；第五步学习hadoop/spark生态圈. 数据挖掘工程师数据挖掘 =业务知识 + 自然语言处理技术（ NLP ） + 计算机视觉技术（ CV ） + 机器学习 / 深度学习（ ML/DL ） 大数据学习路线java(Java se,javaweb)Linux(shell,高并发架构,lucene,solr)Hadoop(Hadoop,HDFS,Mapreduce,yarn,hive,hbase,sqoop,zookeeper,flume)机器学习(R,mahout)Storm(Storm,kafka,redis)Spark(scala,spark,spark core,spark sql,spark streaming,spark mllib,spark graphx)Python(python,spark python)云计算平台(docker,kvm,openstack) 因此，数据工程师需要掌握通用脚本语言和工具，利用和改进数据分析系统，不断提高数据数量和质量。 精通Java技术知识，熟悉Spark、kafka、Hive、HBase、zookeeper、HDFS、MR等应用设计及开发；了解百python/shell等脚本语言；熟悉大数据平台架构，对ETL、数据仓库等有一定了解。","tags":[{"name":"x","slug":"x","permalink":"http://yoursite.com/tags/x/"}]},{"title":"MySQL_编程一五八俱乐部","date":"2020-05-27T04:22:14.000Z","path":"2020/05/27/MySQL-编程一五八俱乐部/","text":"MySQL学习笔记 登录和退出MySQL服务器12345# 登录MySQL$ mysql -u root -p12345612# 退出MySQL数据库服务器exit; 基本语法12345678910111213141516171819202122232425262728293031323334353637383940-- 显示所有数据库show databases;-- 创建数据库CREATE DATABASE test;-- 切换数据库use test;-- 显示数据库中的所有表show tables;-- 创建数据表CREATE TABLE pet ( name VARCHAR(20), owner VARCHAR(20), species VARCHAR(20), sex CHAR(1), birth DATE, death DATE);-- 查看数据表结构-- describe pet;desc pet;-- 查询表SELECT * from pet;-- 插入数据INSERT INTO pet VALUES (&#39;puffball&#39;, &#39;Diane&#39;, &#39;hamster&#39;, &#39;f&#39;, &#39;1990-03-30&#39;, NULL);-- 修改数据UPDATE pet SET name &#x3D; &#39;squirrel&#39; where owner &#x3D; &#39;Diane&#39;;-- 删除数据DELETE FROM pet where name &#x3D; &#39;squirrel&#39;;-- 删除表DROP TABLE myorder; 建表约束主键约束123456789101112131415161718192021222324252627282930-- 主键约束-- 使某个字段不重复且不得为空，确保表内所有数据的唯一性。CREATE TABLE user ( id INT PRIMARY KEY, name VARCHAR(20));-- 联合主键-- 联合主键中的每个字段都不能为空，并且加起来不能和已设置的联合主键重复。CREATE TABLE user ( id INT, name VARCHAR(20), password VARCHAR(20), PRIMARY KEY(id, name));-- 自增约束-- 自增约束的主键由系统自动递增分配。CREATE TABLE user ( id INT PRIMARY KEY AUTO_INCREMENT, name VARCHAR(20));-- 添加主键约束-- 如果忘记设置主键，还可以通过SQL语句设置（两种方式）：ALTER TABLE user ADD PRIMARY KEY(id);ALTER TABLE user MODIFY id INT PRIMARY KEY;-- 删除主键ALTER TABLE user drop PRIMARY KEY; 唯一主键1234567891011121314-- 建表时创建唯一主键CREATE TABLE user ( id INT, name VARCHAR(20), UNIQUE(name));-- 添加唯一主键-- 如果建表时没有设置唯一建，还可以通过SQL语句设置（两种方式）：ALTER TABLE user ADD UNIQUE(name);ALTER TABLE user MODIFY name VARCHAR(20) UNIQUE;-- 删除唯一主键ALTER TABLE user DROP INDEX name; 非空约束123456789-- 建表时添加非空约束-- 约束某个字段不能为空CREATE TABLE user ( id INT, name VARCHAR(20) NOT NULL);-- 移除非空约束ALTER TABLE user MODIFY name VARCHAR(20); 默认约束12345678910-- 建表时添加默认约束-- 约束某个字段的默认值CREATE TABLE user2 ( id INT, name VARCHAR(20), age INT DEFAULT 10);-- 移除非空约束ALTER TABLE user MODIFY age INT; 外键约束123456789101112131415161718-- 班级CREATE TABLE classes ( id INT PRIMARY KEY, name VARCHAR(20));-- 学生表CREATE TABLE students ( id INT PRIMARY KEY, name VARCHAR(20), -- 这里的 class_id 要和 classes 中的 id 字段相关联 class_id INT, -- 表示 class_id 的值必须来自于 classes 中的 id 字段值 FOREIGN KEY(class_id) REFERENCES classes(id));-- 1. 主表（父表）classes 中没有的数据值，在副表（子表）students 中，是不可以使用的；-- 2. 主表中的记录被副表引用时，主表不可以被删除。 数据库的三大设计范式1NF只要字段值还可以继续拆分，就不满足第一范式。 范式设计得越详细，对某些实际操作可能会更好，但并非都有好处，需要对项目的实际情况进行设定。 2NF在满足第一范式的前提下，其他列都必须完全依赖于主键列。如果出现不完全依赖，只可能发生在联合主键的情况下： 12345678-- 订单表CREATE TABLE myorder ( product_id INT, customer_id INT, product_name VARCHAR(20), customer_name VARCHAR(20), PRIMARY KEY (product_id, customer_id)); 实际上，在这张订单表中，product_name 只依赖于 product_id ，customer_name 只依赖于 customer_id 。也就是说，product_name 和 customer_id 是没用关系的，customer_name 和 product_id 也是没有关系的。 这就不满足第二范式：其他列都必须完全依赖于主键列！ 123456789101112131415CREATE TABLE myorder ( order_id INT PRIMARY KEY, product_id INT, customer_id INT);CREATE TABLE product ( id INT PRIMARY KEY, name VARCHAR(20));CREATE TABLE customer ( id INT PRIMARY KEY, name VARCHAR(20)); 拆分之后，myorder 表中的 product_id 和 customer_id 完全依赖于 order_id 主键，而 product 和 customer 表中的其他字段又完全依赖于主键。满足了第二范式的设计！ 3NF在满足第二范式的前提下，除了主键列之外，其他列之间不能有传递依赖关系。 123456CREATE TABLE myorder ( order_id INT PRIMARY KEY, product_id INT, customer_id INT, customer_phone VARCHAR(15)); 表中的 customer_phone 有可能依赖于 order_id 、 customer_id 两列，也就不满足了第三范式的设计：其他列之间不能有传递依赖关系。 1234567891011CREATE TABLE myorder ( order_id INT PRIMARY KEY, product_id INT, customer_id INT);CREATE TABLE customer ( id INT PRIMARY KEY, name VARCHAR(20), phone VARCHAR(15)); 修改后就不存在其他列之间的传递依赖关系，其他列都只依赖于主键列，满足了第三范式的设计！ 查询练习准备数据123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687-- 创建数据库CREATE DATABASE select_test;-- 切换数据库USE select_test;-- 创建学生表CREATE TABLE student ( no VARCHAR(20) PRIMARY KEY, name VARCHAR(20) NOT NULL, sex VARCHAR(10) NOT NULL, birthday DATE, -- 生日 class VARCHAR(20) -- 所在班级);-- 创建教师表CREATE TABLE teacher ( no VARCHAR(20) PRIMARY KEY, name VARCHAR(20) NOT NULL, sex VARCHAR(10) NOT NULL, birthday DATE, profession VARCHAR(20) NOT NULL, -- 职称 department VARCHAR(20) NOT NULL -- 部门);-- 创建课程表CREATE TABLE course ( no VARCHAR(20) PRIMARY KEY, name VARCHAR(20) NOT NULL, t_no VARCHAR(20) NOT NULL, -- 教师编号 -- 表示该 tno 来自于 teacher 表中的 no 字段值 FOREIGN KEY(t_no) REFERENCES teacher(no) );-- 成绩表CREATE TABLE score ( s_no VARCHAR(20) NOT NULL, -- 学生编号 c_no VARCHAR(20) NOT NULL, -- 课程号 degree DECIMAL, -- 成绩 -- 表示该 s_no, c_no 分别来自于 student, course 表中的 no 字段值 FOREIGN KEY(s_no) REFERENCES student(no), FOREIGN KEY(c_no) REFERENCES course(no), -- 设置 s_no, c_no 为联合主键 PRIMARY KEY(s_no, c_no));-- 查看所有表SHOW TABLES;-- 添加学生表数据INSERT INTO student VALUES(&#39;101&#39;, &#39;曾华&#39;, &#39;男&#39;, &#39;1977-09-01&#39;, &#39;95033&#39;);INSERT INTO student VALUES(&#39;102&#39;, &#39;匡明&#39;, &#39;男&#39;, &#39;1975-10-02&#39;, &#39;95031&#39;);INSERT INTO student VALUES(&#39;103&#39;, &#39;王丽&#39;, &#39;女&#39;, &#39;1976-01-23&#39;, &#39;95033&#39;);INSERT INTO student VALUES(&#39;104&#39;, &#39;李军&#39;, &#39;男&#39;, &#39;1976-02-20&#39;, &#39;95033&#39;);INSERT INTO student VALUES(&#39;105&#39;, &#39;王芳&#39;, &#39;女&#39;, &#39;1975-02-10&#39;, &#39;95031&#39;);INSERT INTO student VALUES(&#39;106&#39;, &#39;陆军&#39;, &#39;男&#39;, &#39;1974-06-03&#39;, &#39;95031&#39;);INSERT INTO student VALUES(&#39;107&#39;, &#39;王尼玛&#39;, &#39;男&#39;, &#39;1976-02-20&#39;, &#39;95033&#39;);INSERT INTO student VALUES(&#39;108&#39;, &#39;张全蛋&#39;, &#39;男&#39;, &#39;1975-02-10&#39;, &#39;95031&#39;);INSERT INTO student VALUES(&#39;109&#39;, &#39;赵铁柱&#39;, &#39;男&#39;, &#39;1974-06-03&#39;, &#39;95031&#39;);-- 添加教师表数据INSERT INTO teacher VALUES(&#39;804&#39;, &#39;李诚&#39;, &#39;男&#39;, &#39;1958-12-02&#39;, &#39;副教授&#39;, &#39;计算机系&#39;);INSERT INTO teacher VALUES(&#39;856&#39;, &#39;张旭&#39;, &#39;男&#39;, &#39;1969-03-12&#39;, &#39;讲师&#39;, &#39;电子工程系&#39;);INSERT INTO teacher VALUES(&#39;825&#39;, &#39;王萍&#39;, &#39;女&#39;, &#39;1972-05-05&#39;, &#39;助教&#39;, &#39;计算机系&#39;);INSERT INTO teacher VALUES(&#39;831&#39;, &#39;刘冰&#39;, &#39;女&#39;, &#39;1977-08-14&#39;, &#39;助教&#39;, &#39;电子工程系&#39;);-- 添加课程表数据INSERT INTO course VALUES(&#39;3-105&#39;, &#39;计算机导论&#39;, &#39;825&#39;);INSERT INTO course VALUES(&#39;3-245&#39;, &#39;操作系统&#39;, &#39;804&#39;);INSERT INTO course VALUES(&#39;6-166&#39;, &#39;数字电路&#39;, &#39;856&#39;);INSERT INTO course VALUES(&#39;9-888&#39;, &#39;高等数学&#39;, &#39;831&#39;);-- 添加添加成绩表数据INSERT INTO score VALUES(&#39;103&#39;, &#39;3-105&#39;, &#39;92&#39;);INSERT INTO score VALUES(&#39;103&#39;, &#39;3-245&#39;, &#39;86&#39;);INSERT INTO score VALUES(&#39;103&#39;, &#39;6-166&#39;, &#39;85&#39;);INSERT INTO score VALUES(&#39;105&#39;, &#39;3-105&#39;, &#39;88&#39;);INSERT INTO score VALUES(&#39;105&#39;, &#39;3-245&#39;, &#39;75&#39;);INSERT INTO score VALUES(&#39;105&#39;, &#39;6-166&#39;, &#39;79&#39;);INSERT INTO score VALUES(&#39;109&#39;, &#39;3-105&#39;, &#39;76&#39;);INSERT INTO score VALUES(&#39;109&#39;, &#39;3-245&#39;, &#39;68&#39;);INSERT INTO score VALUES(&#39;109&#39;, &#39;6-166&#39;, &#39;81&#39;);-- 查看表结构SELECT * FROM course;SELECT * FROM score;SELECT * FROM student;SELECT * FROM teacher; 1 到 1012345678910111213141516171819202122232425262728293031323334353637383940414243-- 查询 student 表的所有行SELECT * FROM student;-- 查询 student 表中的 name、sex 和 class 字段的所有行SELECT name, sex, class FROM student;-- 查询 teacher 表中不重复的 department 列-- department: 去重查询SELECT DISTINCT department FROM teacher;-- 查询 score 表中成绩在60-80之间的所有行（区间查询和运算符查询）-- BETWEEN xx AND xx: 查询区间, AND 表示 &quot;并且&quot;SELECT * FROM score WHERE degree BETWEEN 60 AND 80;SELECT * FROM score WHERE degree &gt; 60 AND degree &lt; 80;-- 查询 score 表中成绩为 85, 86 或 88 的行-- IN: 查询规定中的多个值SELECT * FROM score WHERE degree IN (85, 86, 88);-- 查询 student 表中 &#39;95031&#39; 班或性别为 &#39;女&#39; 的所有行-- or: 表示或者关系SELECT * FROM student WHERE class &#x3D; &#39;95031&#39; or sex &#x3D; &#39;女&#39;;-- 以 class 降序的方式查询 student 表的所有行-- DESC: 降序，从高到低-- ASC（默认）: 升序，从低到高SELECT * FROM student ORDER BY class DESC;SELECT * FROM student ORDER BY class ASC;-- 以 c_no 升序、degree 降序查询 score 表的所有行SELECT * FROM score ORDER BY c_no ASC, degree DESC;-- 查询 &quot;95031&quot; 班的学生人数-- COUNT: 统计SELECT COUNT(*) FROM student WHERE class &#x3D; &#39;95031&#39;;-- 查询 score 表中的最高分的学生学号和课程编号（子查询或排序查询）。-- (SELECT MAX(degree) FROM score): 子查询，算出最高分SELECT s_no, c_no FROM score WHERE degree &#x3D; (SELECT MAX(degree) FROM score);-- 排序查询-- LIMIT r, n: 表示从第r行开始，查询n条数据SELECT s_no, c_no, degree FROM score ORDER BY degree DESC LIMIT 0, 1; 分组计算平均成绩查询每门课的平均成绩。 1234567-- AVG: 平均值SELECT AVG(degree) FROM score WHERE c_no &#x3D; &#39;3-105&#39;;SELECT AVG(degree) FROM score WHERE c_no &#x3D; &#39;3-245&#39;;SELECT AVG(degree) FROM score WHERE c_no &#x3D; &#39;6-166&#39;;-- GROUP BY: 分组查询SELECT c_no, AVG(degree) FROM score GROUP BY c_no; 分组条件与模糊查询查询 score 表中至少有 2 名学生选修，并以 3 开头的课程的平均分数。 123456789101112131415SELECT * FROM score;-- c_no 课程编号+------+-------+--------+| s_no | c_no | degree |+------+-------+--------+| 103 | 3-105 | 92 || 103 | 3-245 | 86 || 103 | 6-166 | 85 || 105 | 3-105 | 88 || 105 | 3-245 | 75 || 105 | 6-166 | 79 || 109 | 3-105 | 76 || 109 | 3-245 | 68 || 109 | 6-166 | 81 |+------+-------+--------+ 分析表发现，至少有 2 名学生选修的课程是 3-105 、3-245 、6-166 ，以 3 开头的课程是 3-105 、3-245 。也就是说，我们要查询所有 3-105 和 3-245 的 degree 平均分。 12345678910111213141516171819202122232425262728-- 首先把 c_no, AVG(degree) 通过分组查询出来SELECT c_no, AVG(degree) FROM score GROUP BY c_no+-------+-------------+| c_no | AVG(degree) |+-------+-------------+| 3-105 | 85.3333 || 3-245 | 76.3333 || 6-166 | 81.6667 |+-------+-------------+-- 再查询出至少有 2 名学生选修的课程-- HAVING: 表示持有HAVING COUNT(c_no) &gt;&#x3D; 2-- 并且是以 3 开头的课程-- LIKE 表示模糊查询，&quot;%&quot; 是一个通配符，匹配 &quot;3&quot; 后面的任意字符。AND c_no LIKE &#39;3%&#39;;-- 把前面的SQL语句拼接起来，-- 后面加上一个 COUNT(*)，表示将每个分组的个数也查询出来。SELECT c_no, AVG(degree), COUNT(*) FROM score GROUP BY c_noHAVING COUNT(c_no) &gt;&#x3D; 2 AND c_no LIKE &#39;3%&#39;;+-------+-------------+----------+| c_no | AVG(degree) | COUNT(*) |+-------+-------------+----------+| 3-105 | 85.3333 | 3 || 3-245 | 76.3333 | 3 |+-------+-------------+----------+ 多表查询 - 1查询所有学生的 name，以及该学生在 score 表中对应的 c_no 和 degree 。 1234567891011121314151617181920212223242526272829SELECT no, name FROM student;+-----+-----------+| no | name |+-----+-----------+| 101 | 曾华 || 102 | 匡明 || 103 | 王丽 || 104 | 李军 || 105 | 王芳 || 106 | 陆军 || 107 | 王尼玛 || 108 | 张全蛋 || 109 | 赵铁柱 |+-----+-----------+SELECT s_no, c_no, degree FROM score;+------+-------+--------+| s_no | c_no | degree |+------+-------+--------+| 103 | 3-105 | 92 || 103 | 3-245 | 86 || 103 | 6-166 | 85 || 105 | 3-105 | 88 || 105 | 3-245 | 75 || 105 | 6-166 | 79 || 109 | 3-105 | 76 || 109 | 3-245 | 68 || 109 | 6-166 | 81 |+------+-------+--------+ 通过分析可以发现，只要把 score 表中的 s_no 字段值替换成 student 表中对应的 name 字段值就可以了，如何做呢？ 1234567891011121314151617-- FROM...: 表示从 student, score 表中查询-- WHERE 的条件表示为，只有在 student.no 和 score.s_no 相等时才显示出来。SELECT name, c_no, degree FROM student, score WHERE student.no &#x3D; score.s_no;+-----------+-------+--------+| name | c_no | degree |+-----------+-------+--------+| 王丽 | 3-105 | 92 || 王丽 | 3-245 | 86 || 王丽 | 6-166 | 85 || 王芳 | 3-105 | 88 || 王芳 | 3-245 | 75 || 王芳 | 6-166 | 79 || 赵铁柱 | 3-105 | 76 || 赵铁柱 | 3-245 | 68 || 赵铁柱 | 6-166 | 81 |+-----------+-------+--------+ 多表查询 - 2查询所有学生的 no 、课程名称 ( course 表中的 name ) 和成绩 ( score 表中的 degree ) 列。 只有 score 关联学生的 no ，因此只要查询 score 表，就能找出所有和学生相关的 no 和 degree ： 1234567891011121314SELECT s_no, c_no, degree FROM score;+------+-------+--------+| s_no | c_no | degree |+------+-------+--------+| 103 | 3-105 | 92 || 103 | 3-245 | 86 || 103 | 6-166 | 85 || 105 | 3-105 | 88 || 105 | 3-245 | 75 || 105 | 6-166 | 79 || 109 | 3-105 | 76 || 109 | 3-245 | 68 || 109 | 6-166 | 81 |+------+-------+--------+ 然后查询 course 表： 12345678+-------+-----------------+| no | name |+-------+-----------------+| 3-105 | 计算机导论 || 3-245 | 操作系统 || 6-166 | 数字电路 || 9-888 | 高等数学 |+-------+-----------------+ 只要把 score 表中的 c_no 替换成 course 表中对应的 name 字段值就可以了。 1234567891011121314151617-- 增加一个查询字段 name，分别从 score、course 这两个表中查询。-- as 表示取一个该字段的别名。SELECT s_no, name as c_name, degree FROM score, courseWHERE score.c_no &#x3D; course.no;+------+-----------------+--------+| s_no | c_name | degree |+------+-----------------+--------+| 103 | 计算机导论 | 92 || 105 | 计算机导论 | 88 || 109 | 计算机导论 | 76 || 103 | 操作系统 | 86 || 105 | 操作系统 | 75 || 109 | 操作系统 | 68 || 103 | 数字电路 | 85 || 105 | 数字电路 | 79 || 109 | 数字电路 | 81 |+------+-----------------+--------+ 三表关联查询查询所有学生的 name 、课程名 ( course 表中的 name ) 和 degree 。 只有 score 表中关联学生的学号和课堂号，我们只要围绕着 score 这张表查询就好了。 1234567891011121314SELECT * FROM score;+------+-------+--------+| s_no | c_no | degree |+------+-------+--------+| 103 | 3-105 | 92 || 103 | 3-245 | 86 || 103 | 6-166 | 85 || 105 | 3-105 | 88 || 105 | 3-245 | 75 || 105 | 6-166 | 79 || 109 | 3-105 | 76 || 109 | 3-245 | 68 || 109 | 6-166 | 81 |+------+-------+--------+ 只要把 s_no 和 c_no 替换成 student 和 srouse 表中对应的 name 字段值就好了。 首先把 s_no 替换成 student 表中的 name 字段： 1234567891011121314SELECT name, c_no, degree FROM student, score WHERE student.no &#x3D; score.s_no;+-----------+-------+--------+| name | c_no | degree |+-----------+-------+--------+| 王丽 | 3-105 | 92 || 王丽 | 3-245 | 86 || 王丽 | 6-166 | 85 || 王芳 | 3-105 | 88 || 王芳 | 3-245 | 75 || 王芳 | 6-166 | 79 || 赵铁柱 | 3-105 | 76 || 赵铁柱 | 3-245 | 68 || 赵铁柱 | 6-166 | 81 |+-----------+-------+--------+ 再把 c_no 替换成 course 表中的 name 字段： 12345678910111213141516-- 课程表SELECT no, name FROM course;+-------+-----------------+| no | name |+-------+-----------------+| 3-105 | 计算机导论 || 3-245 | 操作系统 || 6-166 | 数字电路 || 9-888 | 高等数学 |+-------+-----------------+-- 由于字段名存在重复，使用 &quot;表名.字段名 as 别名&quot; 代替。SELECT student.name as s_name, course.name as c_name, degree FROM student, score, courseWHERE student.NO &#x3D; score.s_noAND score.c_no &#x3D; course.no; 子查询加分组求平均分查询 95031 班学生每门课程的平均成绩。 在 score 表中根据 student 表的学生编号筛选出学生的课堂号和成绩： 12345678910111213-- IN (..): 将筛选出的学生号当做 s_no 的条件查询SELECT s_no, c_no, degree FROM scoreWHERE s_no IN (SELECT no FROM student WHERE class &#x3D; &#39;95031&#39;);+------+-------+--------+| s_no | c_no | degree |+------+-------+--------+| 105 | 3-105 | 88 || 105 | 3-245 | 75 || 105 | 6-166 | 79 || 109 | 3-105 | 76 || 109 | 3-245 | 68 || 109 | 6-166 | 81 |+------+-------+--------+ 这时只要将 c_no 分组一下就能得出 95031 班学生每门课的平均成绩： 12345678910SELECT c_no, AVG(degree) FROM scoreWHERE s_no IN (SELECT no FROM student WHERE class &#x3D; &#39;95031&#39;)GROUP BY c_no;+-------+-------------+| c_no | AVG(degree) |+-------+-------------+| 3-105 | 82.0000 || 3-245 | 71.5000 || 6-166 | 80.0000 |+-------+-------------+ 子查询 - 1查询在 3-105 课程中，所有成绩高于 109 号同学的记录。 首先筛选出课堂号为 3-105 ，在找出所有成绩高于 109 号同学的的行。 123SELECT * FROM score WHERE c_no &#x3D; &#39;3-105&#39;AND degree &gt; (SELECT degree FROM score WHERE s_no &#x3D; &#39;109&#39; AND c_no &#x3D; &#39;3-105&#39;); 子查询 - 2查询所有成绩高于 109 号同学的 3-105 课程成绩记录。 123-- 不限制课程号，只要成绩大于109号同学的3-105课程成绩就可以。SELECT * FROM scoreWHERE degree &gt; (SELECT degree FROM score WHERE s_no &#x3D; &#39;109&#39; AND c_no &#x3D; &#39;3-105&#39;); YEAR 函数与带 IN 关键字查询查询所有和 101 、108 号学生同年出生的 no 、name 、birthday 列。 123-- YEAR(..): 取出日期中的年份SELECT no, name, birthday FROM studentWHERE YEAR(birthday) IN (SELECT YEAR(birthday) FROM student WHERE no IN (101, 108)); 多层嵌套子查询查询 &#39;张旭&#39; 教师任课的学生成绩表。 首先找到教师编号： 1SELECT NO FROM teacher WHERE NAME &#x3D; &#39;张旭&#39; 通过 sourse 表找到该教师课程号： 1SELECT NO FROM course WHERE t_no &#x3D; ( SELECT NO FROM teacher WHERE NAME &#x3D; &#39;张旭&#39; ); 通过筛选出的课程号查询成绩表： 12345SELECT * FROM score WHERE c_no &#x3D; ( SELECT no FROM course WHERE t_no &#x3D; ( SELECT no FROM teacher WHERE NAME &#x3D; &#39;张旭&#39; )); 多表查询查询某选修课程多于5个同学的教师姓名。 首先在 teacher 表中，根据 no 字段来判断该教师的同一门课程是否有至少5名学员选修： 1234567891011121314-- 查询 teacher 表SELECT no, name FROM teacher;+-----+--------+| no | name |+-----+--------+| 804 | 李诚 || 825 | 王萍 || 831 | 刘冰 || 856 | 张旭 |+-----+--------+SELECT name FROM teacher WHERE no IN ( -- 在这里找到对应的条件); 查看和教师编号有有关的表的信息： 12345678910SELECT * FROM course;-- t_no: 教师编号+-------+-----------------+------+| no | name | t_no |+-------+-----------------+------+| 3-105 | 计算机导论 | 825 || 3-245 | 操作系统 | 804 || 6-166 | 数字电路 | 856 || 9-888 | 高等数学 | 831 |+-------+-----------------+------+ 我们已经找到和教师编号有关的字段就在 course 表中，但是还无法知道哪门课程至少有5名学生选修，所以还需要根据 score 表来查询： 12345678910111213141516171819202122232425262728293031-- 在此之前向 score 插入一些数据，以便丰富查询条件。INSERT INTO score VALUES (&#39;101&#39;, &#39;3-105&#39;, &#39;90&#39;);INSERT INTO score VALUES (&#39;102&#39;, &#39;3-105&#39;, &#39;91&#39;);INSERT INTO score VALUES (&#39;104&#39;, &#39;3-105&#39;, &#39;89&#39;);-- 查询 score 表SELECT * FROM score;+------+-------+--------+| s_no | c_no | degree |+------+-------+--------+| 101 | 3-105 | 90 || 102 | 3-105 | 91 || 103 | 3-105 | 92 || 103 | 3-245 | 86 || 103 | 6-166 | 85 || 104 | 3-105 | 89 || 105 | 3-105 | 88 || 105 | 3-245 | 75 || 105 | 6-166 | 79 || 109 | 3-105 | 76 || 109 | 3-245 | 68 || 109 | 6-166 | 81 |+------+-------+--------+-- 在 score 表中将 c_no 作为分组，并且限制 c_no 持有至少 5 条数据。SELECT c_no FROM score GROUP BY c_no HAVING COUNT(*) &gt; 5;+-------+| c_no |+-------+| 3-105 |+-------+ 根据筛选出来的课程号，找出在某课程中，拥有至少5名学员的教师编号： 12345678SELECT t_no FROM course WHERE no IN ( SELECT c_no FROM score GROUP BY c_no HAVING COUNT(*) &gt; 5);+------+| t_no |+------+| 825 |+------+ 在 teacher 表中，根据筛选出来的教师编号找到教师姓名： 123456SELECT name FROM teacher WHERE no IN ( -- 最终条件 SELECT t_no FROM course WHERE no IN ( SELECT c_no FROM score GROUP BY c_no HAVING COUNT(*) &gt; 5 )); 子查询 - 3查询 “计算机系” 课程的成绩表。 思路是，先找出 course 表中所有 计算机系 课程的编号，然后根据这个编号查询 score 表。 123456789101112131415161718192021222324252627282930313233343536373839-- 通过 teacher 表查询所有 &#96;计算机系&#96; 的教师编号SELECT no, name, department FROM teacher WHERE department &#x3D; &#39;计算机系&#39;+-----+--------+--------------+| no | name | department |+-----+--------+--------------+| 804 | 李诚 | 计算机系 || 825 | 王萍 | 计算机系 |+-----+--------+--------------+-- 通过 course 表查询该教师的课程编号SELECT no FROM course WHERE t_no IN ( SELECT no FROM teacher WHERE department &#x3D; &#39;计算机系&#39;);+-------+| no |+-------+| 3-245 || 3-105 |+-------+-- 根据筛选出来的课程号查询成绩表SELECT * FROM score WHERE c_no IN ( SELECT no FROM course WHERE t_no IN ( SELECT no FROM teacher WHERE department &#x3D; &#39;计算机系&#39; ));+------+-------+--------+| s_no | c_no | degree |+------+-------+--------+| 103 | 3-245 | 86 || 105 | 3-245 | 75 || 109 | 3-245 | 68 || 101 | 3-105 | 90 || 102 | 3-105 | 91 || 103 | 3-105 | 92 || 104 | 3-105 | 89 || 105 | 3-105 | 88 || 109 | 3-105 | 76 |+------+-------+--------+ UNION 和 NOTIN 的使用查询 计算机系 与 电子工程系 中的不同职称的教师。 123456789-- NOT: 代表逻辑非SELECT * FROM teacher WHERE department &#x3D; &#39;计算机系&#39; AND profession NOT IN ( SELECT profession FROM teacher WHERE department &#x3D; &#39;电子工程系&#39;)-- 合并两个集UNIONSELECT * FROM teacher WHERE department &#x3D; &#39;电子工程系&#39; AND profession NOT IN ( SELECT profession FROM teacher WHERE department &#x3D; &#39;计算机系&#39;); ANY 表示至少一个 - DESC ( 降序 )查询课程 3-105 且成绩 至少 高于 3-245 的 score 表。 12345678910111213141516171819202122232425262728293031323334353637SELECT * FROM score WHERE c_no &#x3D; &#39;3-105&#39;;+------+-------+--------+| s_no | c_no | degree |+------+-------+--------+| 101 | 3-105 | 90 || 102 | 3-105 | 91 || 103 | 3-105 | 92 || 104 | 3-105 | 89 || 105 | 3-105 | 88 || 109 | 3-105 | 76 |+------+-------+--------+SELECT * FROM score WHERE c_no &#x3D; &#39;3-245&#39;;+------+-------+--------+| s_no | c_no | degree |+------+-------+--------+| 103 | 3-245 | 86 || 105 | 3-245 | 75 || 109 | 3-245 | 68 |+------+-------+--------+-- ANY: 符合SQL语句中的任意条件。-- 也就是说，在 3-105 成绩中，只要有一个大于从 3-245 筛选出来的任意行就符合条件，-- 最后根据降序查询结果。SELECT * FROM score WHERE c_no &#x3D; &#39;3-105&#39; AND degree &gt; ANY( SELECT degree FROM score WHERE c_no &#x3D; &#39;3-245&#39;) ORDER BY degree DESC;+------+-------+--------+| s_no | c_no | degree |+------+-------+--------+| 103 | 3-105 | 92 || 102 | 3-105 | 91 || 101 | 3-105 | 90 || 104 | 3-105 | 89 || 105 | 3-105 | 88 || 109 | 3-105 | 76 |+------+-------+--------+ 表示所有的 ALL查询课程 3-105 且成绩高于 3-245 的 score 表。 123456789101112131415-- 只需对上一道题稍作修改。-- ALL: 符合SQL语句中的所有条件。-- 也就是说，在 3-105 每一行成绩中，都要大于从 3-245 筛选出来全部行才算符合条件。SELECT * FROM score WHERE c_no &#x3D; &#39;3-105&#39; AND degree &gt; ALL( SELECT degree FROM score WHERE c_no &#x3D; &#39;3-245&#39;);+------+-------+--------+| s_no | c_no | degree |+------+-------+--------+| 101 | 3-105 | 90 || 102 | 3-105 | 91 || 103 | 3-105 | 92 || 104 | 3-105 | 89 || 105 | 3-105 | 88 |+------+-------+--------+ 复制表的数据作为条件查询查询某课程成绩比该课程平均成绩低的 score 表。 1234567891011121314151617181920212223242526272829303132333435363738394041424344-- 查询平均分SELECT c_no, AVG(degree) FROM score GROUP BY c_no;+-------+-------------+| c_no | AVG(degree) |+-------+-------------+| 3-105 | 87.6667 || 3-245 | 76.3333 || 6-166 | 81.6667 |+-------+-------------+-- 查询 score 表SELECT degree FROM score;+--------+| degree |+--------+| 90 || 91 || 92 || 86 || 85 || 89 || 88 || 75 || 79 || 76 || 68 || 81 |+--------+-- 将表 b 作用于表 a 中查询数据-- score a (b): 将表声明为 a (b)，-- 如此就能用 a.c_no &#x3D; b.c_no 作为条件执行查询了。SELECT * FROM score a WHERE degree &lt; ( (SELECT AVG(degree) FROM score b WHERE a.c_no &#x3D; b.c_no));+------+-------+--------+| s_no | c_no | degree |+------+-------+--------+| 105 | 3-245 | 75 || 105 | 6-166 | 79 || 109 | 3-105 | 76 || 109 | 3-245 | 68 || 109 | 6-166 | 81 |+------+-------+--------+ 子查询 - 4查询所有任课 ( 在 course 表里有课程 ) 教师的 name 和 department 。 123456789SELECT name, department FROM teacher WHERE no IN (SELECT t_no FROM course);+--------+-----------------+| name | department |+--------+-----------------+| 李诚 | 计算机系 || 王萍 | 计算机系 || 刘冰 | 电子工程系 || 张旭 | 电子工程系 |+--------+-----------------+ 条件加组筛选查询 student 表中至少有 2 名男生的 class 。 12345678910111213141516171819202122232425-- 查看学生表信息SELECT * FROM student;+-----+-----------+-----+------------+-------+| no | name | sex | birthday | class |+-----+-----------+-----+------------+-------+| 101 | 曾华 | 男 | 1977-09-01 | 95033 || 102 | 匡明 | 男 | 1975-10-02 | 95031 || 103 | 王丽 | 女 | 1976-01-23 | 95033 || 104 | 李军 | 男 | 1976-02-20 | 95033 || 105 | 王芳 | 女 | 1975-02-10 | 95031 || 106 | 陆军 | 男 | 1974-06-03 | 95031 || 107 | 王尼玛 | 男 | 1976-02-20 | 95033 || 108 | 张全蛋 | 男 | 1975-02-10 | 95031 || 109 | 赵铁柱 | 男 | 1974-06-03 | 95031 || 110 | 张飞 | 男 | 1974-06-03 | 95038 |+-----+-----------+-----+------------+-------+-- 只查询性别为男，然后按 class 分组，并限制 class 行大于 1。SELECT class FROM student WHERE sex &#x3D; &#39;男&#39; GROUP BY class HAVING COUNT(*) &gt; 1;+-------+| class |+-------+| 95033 || 95031 |+-------+ NOTLIKE 模糊查询取反查询 student 表中不姓 “王” 的同学记录。 1234567891011121314-- NOT: 取反-- LIKE: 模糊查询mysql&gt; SELECT * FROM student WHERE name NOT LIKE &#39;王%&#39;;+-----+-----------+-----+------------+-------+| no | name | sex | birthday | class |+-----+-----------+-----+------------+-------+| 101 | 曾华 | 男 | 1977-09-01 | 95033 || 102 | 匡明 | 男 | 1975-10-02 | 95031 || 104 | 李军 | 男 | 1976-02-20 | 95033 || 106 | 陆军 | 男 | 1974-06-03 | 95031 || 108 | 张全蛋 | 男 | 1975-02-10 | 95031 || 109 | 赵铁柱 | 男 | 1974-06-03 | 95031 || 110 | 张飞 | 男 | 1974-06-03 | 95038 |+-----+-----------+-----+------------+-------+ YEAR 与 NOW 函数查询 student 表中每个学生的姓名和年龄。 12345678910111213141516-- 使用函数 YEAR(NOW()) 计算出当前年份，减去出生年份后得出年龄。SELECT name, YEAR(NOW()) - YEAR(birthday) as age FROM student;+-----------+------+| name | age |+-----------+------+| 曾华 | 42 || 匡明 | 44 || 王丽 | 43 || 李军 | 43 || 王芳 | 44 || 陆军 | 45 || 王尼玛 | 43 || 张全蛋 | 44 || 赵铁柱 | 45 || 张飞 | 45 |+-----------+------+ MAX 与 MIN 函数查询 student 表中最大和最小的 birthday 值。 123456SELECT MAX(birthday), MIN(birthday) FROM student;+---------------+---------------+| MAX(birthday) | MIN(birthday) |+---------------+---------------+| 1977-09-01 | 1974-06-03 |+---------------+---------------+ 多段排序以 class 和 birthday 从大到小的顺序查询 student 表。 123456789101112131415SELECT * FROM student ORDER BY class DESC, birthday;+-----+-----------+-----+------------+-------+| no | name | sex | birthday | class |+-----+-----------+-----+------------+-------+| 110 | 张飞 | 男 | 1974-06-03 | 95038 || 103 | 王丽 | 女 | 1976-01-23 | 95033 || 104 | 李军 | 男 | 1976-02-20 | 95033 || 107 | 王尼玛 | 男 | 1976-02-20 | 95033 || 101 | 曾华 | 男 | 1977-09-01 | 95033 || 106 | 陆军 | 男 | 1974-06-03 | 95031 || 109 | 赵铁柱 | 男 | 1974-06-03 | 95031 || 105 | 王芳 | 女 | 1975-02-10 | 95031 || 108 | 张全蛋 | 男 | 1975-02-10 | 95031 || 102 | 匡明 | 男 | 1975-10-02 | 95031 |+-----+-----------+-----+------------+-------+ 子查询 - 5查询 “男” 教师及其所上的课程。 1234567SELECT * FROM course WHERE t_no in (SELECT no FROM teacher WHERE sex &#x3D; &#39;男&#39;);+-------+--------------+------+| no | name | t_no |+-------+--------------+------+| 3-245 | 操作系统 | 804 || 6-166 | 数字电路 | 856 |+-------+--------------+------+ MAX 函数与子查询查询最高分同学的 score 表。 1234567891011-- 找出最高成绩（该查询只能有一个结果）SELECT MAX(degree) FROM score;-- 根据上面的条件筛选出所有最高成绩表，-- 该查询可能有多个结果，假设 degree 值多次符合条件。SELECT * FROM score WHERE degree &#x3D; (SELECT MAX(degree) FROM score);+------+-------+--------+| s_no | c_no | degree |+------+-------+--------+| 103 | 3-105 | 92 |+------+-------+--------+ 子查询 - 6查询和 “李军” 同性别的所有同学 name 。 123456789101112131415161718192021222324-- 首先将李军的性别作为条件取出来SELECT sex FROM student WHERE name &#x3D; &#39;李军&#39;;+-----+| sex |+-----+| 男 |+-----+-- 根据性别查询 name 和 sexSELECT name, sex FROM student WHERE sex &#x3D; ( SELECT sex FROM student WHERE name &#x3D; &#39;李军&#39;);+-----------+-----+| name | sex |+-----------+-----+| 曾华 | 男 || 匡明 | 男 || 李军 | 男 || 陆军 | 男 || 王尼玛 | 男 || 张全蛋 | 男 || 赵铁柱 | 男 || 张飞 | 男 |+-----------+-----+ 子查询 - 7查询和 “李军” 同性别且同班的同学 name 。 123456789101112SELECT name, sex, class FROM student WHERE sex &#x3D; ( SELECT sex FROM student WHERE name &#x3D; &#39;李军&#39;) AND class &#x3D; ( SELECT class FROM student WHERE name &#x3D; &#39;李军&#39;);+-----------+-----+-------+| name | sex | class |+-----------+-----+-------+| 曾华 | 男 | 95033 || 李军 | 男 | 95033 || 王尼玛 | 男 | 95033 |+-----------+-----+-------+ 子查询 - 8查询所有选修 “计算机导论” 课程的 “男” 同学成绩表。 需要的 “计算机导论” 和性别为 “男” 的编号可以在 course 和 student 表中找到。 12345678910111213SELECT * FROM score WHERE c_no &#x3D; ( SELECT no FROM course WHERE name &#x3D; &#39;计算机导论&#39;) AND s_no IN ( SELECT no FROM student WHERE sex &#x3D; &#39;男&#39;);+------+-------+--------+| s_no | c_no | degree |+------+-------+--------+| 101 | 3-105 | 90 || 102 | 3-105 | 91 || 104 | 3-105 | 89 || 109 | 3-105 | 76 |+------+-------+--------+ 按等级查询建立一个 grade 表代表学生的成绩等级，并插入数据： 12345678910111213141516171819202122CREATE TABLE grade ( low INT(3), upp INT(3), grade char(1));INSERT INTO grade VALUES (90, 100, &#39;A&#39;);INSERT INTO grade VALUES (80, 89, &#39;B&#39;);INSERT INTO grade VALUES (70, 79, &#39;C&#39;);INSERT INTO grade VALUES (60, 69, &#39;D&#39;);INSERT INTO grade VALUES (0, 59, &#39;E&#39;);SELECT * FROM grade;+------+------+-------+| low | upp | grade |+------+------+-------+| 90 | 100 | A || 80 | 89 | B || 70 | 79 | C || 60 | 69 | D || 0 | 59 | E |+------+------+-------+ 查询所有学生的 s_no 、c_no 和 grade 列。 思路是，使用区间 ( BETWEEN ) 查询，判断学生的成绩 ( degree ) 在 grade 表的 low 和 upp 之间。 123456789101112131415161718SELECT s_no, c_no, grade FROM score, grade WHERE degree BETWEEN low AND upp;+------+-------+-------+| s_no | c_no | grade |+------+-------+-------+| 101 | 3-105 | A || 102 | 3-105 | A || 103 | 3-105 | A || 103 | 3-245 | B || 103 | 6-166 | B || 104 | 3-105 | B || 105 | 3-105 | B || 105 | 3-245 | C || 105 | 6-166 | C || 109 | 3-105 | C || 109 | 3-245 | D || 109 | 6-166 | B |+------+-------+-------+ 连接查询准备用于测试连接查询的数据： 12345678910111213141516171819202122232425262728293031323334CREATE DATABASE testJoin;CREATE TABLE person ( id INT, name VARCHAR(20), cardId INT);CREATE TABLE card ( id INT, name VARCHAR(20));INSERT INTO card VALUES (1, &#39;饭卡&#39;), (2, &#39;建行卡&#39;), (3, &#39;农行卡&#39;), (4, &#39;工商卡&#39;), (5, &#39;邮政卡&#39;);SELECT * FROM card;+------+-----------+| id | name |+------+-----------+| 1 | 饭卡 || 2 | 建行卡 || 3 | 农行卡 || 4 | 工商卡 || 5 | 邮政卡 |+------+-----------+INSERT INTO person VALUES (1, &#39;张三&#39;, 1), (2, &#39;李四&#39;, 3), (3, &#39;王五&#39;, 6);SELECT * FROM person;+------+--------+--------+| id | name | cardId |+------+--------+--------+| 1 | 张三 | 1 || 2 | 李四 | 3 || 3 | 王五 | 6 |+------+--------+--------+ 分析两张表发现，person 表并没有为 cardId 字段设置一个在 card 表中对应的 id 外键。如果设置了的话，person 中 cardId 字段值为 6 的行就插不进去，因为该 cardId 值在 card 表中并没有。 内连接要查询这两张表中有关系的数据，可以使用 INNER JOIN ( 内连接 ) 将它们连接在一起。 123456789101112-- INNER JOIN: 表示为内连接，将两张表拼接在一起。-- on: 表示要执行某个条件。SELECT * FROM person INNER JOIN card on person.cardId &#x3D; card.id;+------+--------+--------+------+-----------+| id | name | cardId | id | name |+------+--------+--------+------+-----------+| 1 | 张三 | 1 | 1 | 饭卡 || 2 | 李四 | 3 | 3 | 农行卡 |+------+--------+--------+------+-----------+-- 将 INNER 关键字省略掉，结果也是一样的。-- SELECT * FROM person JOIN card on person.cardId &#x3D; card.id; 注意：card 的整张表被连接到了右边。 左外连接完整显示左边的表 ( person ) ，右边的表如果符合条件就显示，不符合则补 NULL 。 123456789-- LEFT JOIN 也叫做 LEFT OUTER JOIN，用这两种方式的查询结果是一样的。SELECT * FROM person LEFT JOIN card on person.cardId &#x3D; card.id;+------+--------+--------+------+-----------+| id | name | cardId | id | name |+------+--------+--------+------+-----------+| 1 | 张三 | 1 | 1 | 饭卡 || 2 | 李四 | 3 | 3 | 农行卡 || 3 | 王五 | 6 | NULL | NULL |+------+--------+--------+------+-----------+ 右外链接完整显示右边的表 ( card ) ，左边的表如果符合条件就显示，不符合则补 NULL 。 12345678910SELECT * FROM person RIGHT JOIN card on person.cardId &#x3D; card.id;+------+--------+--------+------+-----------+| id | name | cardId | id | name |+------+--------+--------+------+-----------+| 1 | 张三 | 1 | 1 | 饭卡 || 2 | 李四 | 3 | 3 | 农行卡 || NULL | NULL | NULL | 2 | 建行卡 || NULL | NULL | NULL | 4 | 工商卡 || NULL | NULL | NULL | 5 | 邮政卡 |+------+--------+--------+------+-----------+ 全外链接完整显示两张表的全部数据。 12345678910111213141516171819-- MySQL 不支持这种语法的全外连接-- SELECT * FROM person FULL JOIN card on person.cardId &#x3D; card.id;-- 出现错误：-- ERROR 1054 (42S22): Unknown column &#39;person.cardId&#39; in &#39;on clause&#39;-- MySQL全连接语法，使用 UNION 将两张表合并在一起。SELECT * FROM person LEFT JOIN card on person.cardId &#x3D; card.idUNIONSELECT * FROM person RIGHT JOIN card on person.cardId &#x3D; card.id;+------+--------+--------+------+-----------+| id | name | cardId | id | name |+------+--------+--------+------+-----------+| 1 | 张三 | 1 | 1 | 饭卡 || 2 | 李四 | 3 | 3 | 农行卡 || 3 | 王五 | 6 | NULL | NULL || NULL | NULL | NULL | 2 | 建行卡 || NULL | NULL | NULL | 4 | 工商卡 || NULL | NULL | NULL | 5 | 邮政卡 |+------+--------+--------+------+-----------+ 事务在 MySQL 中，事务其实是一个最小的不可分割的工作单元。事务能够保证一个业务的完整性。 比如我们的银行转账： 12345-- a -&gt; -100UPDATE user set money &#x3D; money - 100 WHERE name &#x3D; &#39;a&#39;;-- b -&gt; +100UPDATE user set money &#x3D; money + 100 WHERE name &#x3D; &#39;b&#39;; 在实际项目中，假设只有一条 SQL 语句执行成功，而另外一条执行失败了，就会出现数据前后不一致。 因此，在执行多条有关联 SQL 语句时，事务可能会要求这些 SQL 语句要么同时执行成功，要么就都执行失败。 如何控制事务 - COMMIT / ROLLBACK在 MySQL 中，事务的自动提交状态默认是开启的。 1234567-- 查询事务的自动提交状态SELECT @@AUTOCOMMIT;+--------------+| @@AUTOCOMMIT |+--------------+| 1 |+--------------+ 自动提交的作用：当我们执行一条 SQL 语句的时候，其产生的效果就会立即体现出来，且不能回滚。 什么是回滚？举个例子： 123456789101112131415161718CREATE DATABASE bank;USE bank;CREATE TABLE user ( id INT PRIMARY KEY, name VARCHAR(20), money INT);INSERT INTO user VALUES (1, &#39;a&#39;, 1000);SELECT * FROM user;+----+------+-------+| id | name | money |+----+------+-------+| 1 | a | 1000 |+----+------+-------+ 可以看到，在执行插入语句后数据立刻生效，原因是 MySQL 中的事务自动将它提交到了数据库中。那么所谓回滚的意思就是，撤销执行过的所有 SQL 语句，使其回滚到最后一次提交数据时的状态。 在 MySQL 中使用 ROLLBACK 执行回滚： 123456789-- 回滚到最后一次提交ROLLBACK;SELECT * FROM user;+----+------+-------+| id | name | money |+----+------+-------+| 1 | a | 1000 |+----+------+-------+ 由于所有执行过的 SQL 语句都已经被提交过了，所以数据并没有发生回滚。那如何让数据可以发生回滚？ 12345678910-- 关闭自动提交SET AUTOCOMMIT &#x3D; 0;-- 查询自动提交状态SELECT @@AUTOCOMMIT;+--------------+| @@AUTOCOMMIT |+--------------+| 0 |+--------------+ 将自动提交关闭后，测试数据回滚： 1234567891011121314151617181920212223242526272829INSERT INTO user VALUES (2, &#39;b&#39;, 1000);-- 关闭 AUTOCOMMIT 后，数据的变化是在一张虚拟的临时数据表中展示，-- 发生变化的数据并没有真正插入到数据表中。SELECT * FROM user;+----+------+-------+| id | name | money |+----+------+-------+| 1 | a | 1000 || 2 | b | 1000 |+----+------+-------+-- 数据表中的真实数据其实还是：+----+------+-------+| id | name | money |+----+------+-------+| 1 | a | 1000 |+----+------+-------+-- 由于数据还没有真正提交，可以使用回滚ROLLBACK;-- 再次查询SELECT * FROM user;+----+------+-------+| id | name | money |+----+------+-------+| 1 | a | 1000 |+----+------+-------+ 那如何将虚拟的数据真正提交到数据库中？使用 COMMIT : 12345678910111213141516INSERT INTO user VALUES (2, &#39;b&#39;, 1000);-- 手动提交数据（持久性），-- 将数据真正提交到数据库中，执行后不能再回滚提交过的数据。COMMIT;-- 提交后测试回滚ROLLBACK;-- 再次查询（回滚无效了）SELECT * FROM user;+----+------+-------+| id | name | money |+----+------+-------+| 1 | a | 1000 || 2 | b | 1000 |+----+------+-------+ 总结 自动提交 查看自动提交状态：SELECT @@AUTOCOMMIT ； 设置自动提交状态：SET AUTOCOMMIT = 0 。 手动提交 @@AUTOCOMMIT = 0 时，使用 COMMIT 命令提交事务。 事务回滚 @@AUTOCOMMIT = 0 时，使用 ROLLBACK 命令回滚事务。 事务的实际应用，让我们再回到银行转账项目： 12345678910111213-- 转账UPDATE user set money &#x3D; money - 100 WHERE name &#x3D; &#39;a&#39;;-- 到账UPDATE user set money &#x3D; money + 100 WHERE name &#x3D; &#39;b&#39;;SELECT * FROM user;+----+------+-------+| id | name | money |+----+------+-------+| 1 | a | 900 || 2 | b | 1100 |+----+------+-------+ 这时假设在转账时发生了意外，就可以使用 ROLLBACK 回滚到最后一次提交的状态： 12345678910-- 假设转账发生了意外，需要回滚。ROLLBACK;SELECT * FROM user;+----+------+-------+| id | name | money |+----+------+-------+| 1 | a | 1000 || 2 | b | 1000 |+----+------+-------+ 这时我们又回到了发生意外之前的状态，也就是说，事务给我们提供了一个可以反悔的机会。假设数据没有发生意外，这时可以手动将数据真正提交到数据表中：COMMIT 。 手动开启事务 - BEGIN / START TRANSACTION事务的默认提交被开启 ( @@AUTOCOMMIT = 1 ) 后，此时就不能使用事务回滚了。但是我们还可以手动开启一个事务处理事件，使其可以发生回滚： 1234567891011121314151617181920212223242526-- 使用 BEGIN 或者 START TRANSACTION 手动开启一个事务-- START TRANSACTION;BEGIN;UPDATE user set money &#x3D; money - 100 WHERE name &#x3D; &#39;a&#39;;UPDATE user set money &#x3D; money + 100 WHERE name &#x3D; &#39;b&#39;;-- 由于手动开启的事务没有开启自动提交，-- 此时发生变化的数据仍然是被保存在一张临时表中。SELECT * FROM user;+----+------+-------+| id | name | money |+----+------+-------+| 1 | a | 900 || 2 | b | 1100 |+----+------+-------+-- 测试回滚ROLLBACK;SELECT * FROM user;+----+------+-------+| id | name | money |+----+------+-------+| 1 | a | 1000 || 2 | b | 1000 |+----+------+-------+ 仍然使用 COMMIT 提交数据，提交后无法再发生本次事务的回滚。 1234567891011121314151617BEGIN;UPDATE user set money &#x3D; money - 100 WHERE name &#x3D; &#39;a&#39;;UPDATE user set money &#x3D; money + 100 WHERE name &#x3D; &#39;b&#39;;SELECT * FROM user;+----+------+-------+| id | name | money |+----+------+-------+| 1 | a | 900 || 2 | b | 1100 |+----+------+-------+-- 提交数据COMMIT;-- 测试回滚（无效，因为表的数据已经被提交）ROLLBACK; 事务的 ACID 特征与使用事务的四大特征： A 原子性：事务是最小的单位，不可以再分割； C 一致性：要求同一事务中的 SQL 语句，必须保证同时成功或者失败； I 隔离性：事务1 和 事务2 之间是具有隔离性的； D 持久性：事务一旦结束 ( COMMIT ) ，就不可以再返回了 ( ROLLBACK ) 。 事务的隔离性事务的隔离性可分为四种 ( 性能从低到高 ) ： READ UNCOMMITTED ( 读取未提交 ) 如果有多个事务，那么任意事务都可以看见其他事务的未提交数据。 READ COMMITTED ( 读取已提交 ) 只能读取到其他事务已经提交的数据。 REPEATABLE READ ( 可被重复读 ) 如果有多个连接都开启了事务，那么事务之间不能共享数据记录，否则只能共享已提交的记录。 SERIALIZABLE ( 串行化 ) 所有的事务都会按照固定顺序执行，执行完一个事务后再继续执行下一个事务的写入操作。 查看当前数据库的默认隔离级别： 123456789101112-- MySQL 8.x, GLOBAL 表示系统级别，不加表示会话级别。SELECT @@GLOBAL.TRANSACTION_ISOLATION;SELECT @@TRANSACTION_ISOLATION;+--------------------------------+| @@GLOBAL.TRANSACTION_ISOLATION |+--------------------------------+| REPEATABLE-READ | -- MySQL的默认隔离级别，可以重复读。+--------------------------------+-- MySQL 5.xSELECT @@GLOBAL.TX_ISOLATION;SELECT @@TX_ISOLATION; 修改隔离级别： 12345678910-- 设置系统隔离级别，LEVEL 后面表示要设置的隔离级别 (READ UNCOMMITTED)。SET GLOBAL TRANSACTION ISOLATION LEVEL READ UNCOMMITTED;-- 查询系统隔离级别，发现已经被修改。SELECT @@GLOBAL.TRANSACTION_ISOLATION;+--------------------------------+| @@GLOBAL.TRANSACTION_ISOLATION |+--------------------------------+| READ-UNCOMMITTED |+--------------------------------+ 脏读测试 READ UNCOMMITTED ( 读取未提交 ) 的隔离性： 1234567891011121314151617181920212223242526272829INSERT INTO user VALUES (3, &#39;小明&#39;, 1000);INSERT INTO user VALUES (4, &#39;淘宝店&#39;, 1000);SELECT * FROM user;+----+-----------+-------+| id | name | money |+----+-----------+-------+| 1 | a | 900 || 2 | b | 1100 || 3 | 小明 | 1000 || 4 | 淘宝店 | 1000 |+----+-----------+-------+-- 开启一个事务操作数据-- 假设小明在淘宝店买了一双800块钱的鞋子：START TRANSACTION;UPDATE user SET money &#x3D; money - 800 WHERE name &#x3D; &#39;小明&#39;;UPDATE user SET money &#x3D; money + 800 WHERE name &#x3D; &#39;淘宝店&#39;;-- 然后淘宝店在另一方查询结果，发现钱已到账。SELECT * FROM user;+----+-----------+-------+| id | name | money |+----+-----------+-------+| 1 | a | 900 || 2 | b | 1100 || 3 | 小明 | 200 || 4 | 淘宝店 | 1800 |+----+-----------+-------+ 由于小明的转账是在新开启的事务上进行操作的，而该操作的结果是可以被其他事务（另一方的淘宝店）看见的，因此淘宝店的查询结果是正确的，淘宝店确认到账。但就在这时，如果小明在它所处的事务上又执行了 ROLLBACK 命令，会发生什么？ 12345678910111213-- 小明所处的事务ROLLBACK;-- 此时无论对方是谁，如果再去查询结果就会发现：SELECT * FROM user;+----+-----------+-------+| id | name | money |+----+-----------+-------+| 1 | a | 900 || 2 | b | 1100 || 3 | 小明 | 1000 || 4 | 淘宝店 | 1000 |+----+-----------+-------+ 这就是所谓的脏读，一个事务读取到另外一个事务还未提交的数据。这在实际开发中是不允许出现的。 读取已提交把隔离级别设置为 READ COMMITTED ： 1234567SET GLOBAL TRANSACTION ISOLATION LEVEL READ COMMITTED;SELECT @@GLOBAL.TRANSACTION_ISOLATION;+--------------------------------+| @@GLOBAL.TRANSACTION_ISOLATION |+--------------------------------+| READ-COMMITTED |+--------------------------------+ 这样，再有新的事务连接进来时，它们就只能查询到已经提交过的事务数据了。但是对于当前事务来说，它们看到的还是未提交的数据，例如： 12345678910111213141516171819202122232425262728293031-- 正在操作数据事务（当前事务）START TRANSACTION;UPDATE user SET money &#x3D; money - 800 WHERE name &#x3D; &#39;小明&#39;;UPDATE user SET money &#x3D; money + 800 WHERE name &#x3D; &#39;淘宝店&#39;;-- 虽然隔离级别被设置为了 READ COMMITTED，但在当前事务中，-- 它看到的仍然是数据表中临时改变数据，而不是真正提交过的数据。SELECT * FROM user;+----+-----------+-------+| id | name | money |+----+-----------+-------+| 1 | a | 900 || 2 | b | 1100 || 3 | 小明 | 200 || 4 | 淘宝店 | 1800 |+----+-----------+-------+-- 假设此时在远程开启了一个新事务，连接到数据库。$ mysql -u root -p12345612-- 此时远程连接查询到的数据只能是已经提交过的SELECT * FROM user;+----+-----------+-------+| id | name | money |+----+-----------+-------+| 1 | a | 900 || 2 | b | 1100 || 3 | 小明 | 1000 || 4 | 淘宝店 | 1000 |+----+-----------+-------+ 但是这样还有问题，那就是假设一个事务在操作数据时，其他事务干扰了这个事务的数据。例如： 1234567891011121314151617181920212223242526272829303132333435-- 小张在查询数据的时候发现：SELECT * FROM user;+----+-----------+-------+| id | name | money |+----+-----------+-------+| 1 | a | 900 || 2 | b | 1100 || 3 | 小明 | 200 || 4 | 淘宝店 | 1800 |+----+-----------+-------+-- 在小张求表的 money 平均值之前，小王做了一个操作：START TRANSACTION;INSERT INTO user VALUES (5, &#39;c&#39;, 100);COMMIT;-- 此时表的真实数据是：SELECT * FROM user;+----+-----------+-------+| id | name | money |+----+-----------+-------+| 1 | a | 900 || 2 | b | 1100 || 3 | 小明 | 1000 || 4 | 淘宝店 | 1000 || 5 | c | 100 |+----+-----------+-------+-- 这时小张再求平均值的时候，就会出现计算不相符合的情况：SELECT AVG(money) FROM user;+------------+| AVG(money) |+------------+| 820.0000 |+------------+ 虽然 READ COMMITTED 让我们只能读取到其他事务已经提交的数据，但还是会出现问题，就是在读取同一个表的数据时，可能会发生前后不一致的情况。这被称为不可重复读现象 ( READ COMMITTED ) 。 幻读将隔离级别设置为 REPEATABLE READ ( 可被重复读取 ) : 1234567SET GLOBAL TRANSACTION ISOLATION LEVEL REPEATABLE READ;SELECT @@GLOBAL.TRANSACTION_ISOLATION;+--------------------------------+| @@GLOBAL.TRANSACTION_ISOLATION |+--------------------------------+| REPEATABLE-READ |+--------------------------------+ 测试 REPEATABLE READ ，假设在两个不同的连接上分别执行 START TRANSACTION : 123456789-- 小张 - 成都START TRANSACTION;INSERT INTO user VALUES (6, 'd', 1000);-- 小王 - 北京START TRANSACTION;-- 小张 - 成都COMMIT; 当前事务开启后，没提交之前，查询不到，提交后可以被查询到。但是，在提交之前其他事务被开启了，那么在这条事务线上，就不会查询到当前有操作事务的连接。相当于开辟出一条单独的线程。 无论小张是否执行过 COMMIT ，在小王这边，都不会查询到小张的事务记录，而是只会查询到自己所处事务的记录： 12345678910SELECT * FROM user;+----+-----------+-------+| id | name | money |+----+-----------+-------+| 1 | a | 900 || 2 | b | 1100 || 3 | 小明 | 1000 || 4 | 淘宝店 | 1000 || 5 | c | 100 |+----+-----------+-------+ 这是因为小王在此之前开启了一个新的事务 ( START TRANSACTION ) **，那么在他的这条新事务的线上，跟其他事务是没有联系的**，也就是说，此时如果其他事务正在操作数据，它是不知道的。 然而事实是，在真实的数据表中，小张已经插入了一条数据。但是小王此时并不知道，也插入了同一条数据，会发生什么呢？ 12INSERT INTO user VALUES (6, 'd', 1000);-- ERROR 1062 (23000): Duplicate entry '6' for key 'PRIMARY' 报错了，操作被告知已存在主键为 6 的字段。这种现象也被称为幻读，一个事务提交的数据，不能被其他事务读取到。 串行化顾名思义，就是所有事务的写入操作全都是串行化的。什么意思？把隔离级别修改成 SERIALIZABLE : 1234567SET GLOBAL TRANSACTION ISOLATION LEVEL SERIALIZABLE;SELECT @@GLOBAL.TRANSACTION_ISOLATION;+--------------------------------+| @@GLOBAL.TRANSACTION_ISOLATION |+--------------------------------+| SERIALIZABLE |+--------------------------------+ 还是拿小张和小王来举例： 123456789101112131415161718192021-- 小张 - 成都START TRANSACTION;-- 小王 - 北京START TRANSACTION;-- 开启事务之前先查询表，准备操作数据。SELECT * FROM user;+----+-----------+-------+| id | name | money |+----+-----------+-------+| 1 | a | 900 || 2 | b | 1100 || 3 | 小明 | 1000 || 4 | 淘宝店 | 1000 || 5 | c | 100 || 6 | d | 1000 |+----+-----------+-------+-- 发现没有 7 号王小花，于是插入一条数据：INSERT INTO user VALUES (7, &#39;王小花&#39;, 1000); 此时会发生什么呢？由于现在的隔离级别是 SERIALIZABLE ( 串行化 ) ，串行化的意思就是：假设把所有的事务都放在一个串行的队列中，那么所有的事务都会按照固定顺序执行，执行完一个事务后再继续执行下一个事务的写入操作 ( 这意味着队列中同时只能执行一个事务的写入操作 ) 。 根据这个解释，小王在插入数据时，会出现等待状态，直到小张执行 COMMIT 结束它所处的事务，或者出现等待超时。","tags":[{"name":"MySQL","slug":"MySQL","permalink":"http://yoursite.com/tags/MySQL/"}]},{"title":"leetcode_766","date":"2020-05-27T04:12:28.000Z","path":"2020/05/27/leetcode-766/","text":"766.托普利茨矩阵 给定一个矩阵，判断其是否为托普利茨矩阵（如果一个矩阵的每一方向由左上到右下的对角线上具有相同元素，那么这个矩阵是托普利茨矩阵）。 解： 要理解对角线在矩阵中的数学表达。 对于对角线上后来出现的元素，托普利茨矩阵要求其与左上角的元素，即同一对角线上先出现的元素相同，元素A[i][j]的左上角元素为A[i-1][j-1]，遍历除了第一行&amp;第一列外的所有元素，若全与左上角相同，则返回true，否则返回false。 12345678910bool isToeplitzMatrix(vector&lt;vector&lt;int&gt;&gt;&amp; matrix) &#123; if(matrix.size()==1 || matrix[0].size()==1) return true; for(int i=1; i&lt;matrix.size(); i++)&#123; for(int j=1; j&lt;matrix[0].size(); j++)&#123; if(matrix[i][j]!=matrix[i-1][j-1]) return false; &#125; &#125; return true;&#125; 复杂度时间复杂度：O(m*n)。 空间复杂度：O(1)。 Tip：C++中二维数组的列数为matrix.length，行数为matrix[0].length。","tags":[{"name":"array","slug":"array","permalink":"http://yoursite.com/tags/array/"}]},{"title":"leetcode_867","date":"2020-05-27T03:10:42.000Z","path":"2020/05/27/leetcode-867/","text":"867.转置矩阵 给定一个矩阵，要求返回其转置矩阵（矩阵由二维vector存储）。 解： m*n的矩阵转置后会得到n*m的矩阵，假设原矩阵为A，转置后矩阵为B，则A[i][j] =B[j][j]。 嵌套for循环对二维数组逐个赋值即可。 Tip：C++中VECTOR的容量问题。 方法 效果 size() 返回容器的大小 empty() 判断容器是否为空 max_size() 返回容器最大的可以存储的元素 capacity() 返回容器当前能够容纳的元素数量 如果v.push_back(1)，容器本身可以提供且存储的元素为n个，加入一个元素后空间不足，申请后大小变为原来的两倍，固得到的size为n+1，而得到的capacity为2n。","tags":[{"name":"array","slug":"array","permalink":"http://yoursite.com/tags/array/"}]},{"title":"HTML快查","date":"2020-05-21T09:41:14.000Z","path":"2020/05/21/HTML快查/","text":"HTML语法快查 HTML基本框架1234567891011121314151617&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;title&gt;文档标题&lt;&#x2F;title&gt;&lt;&#x2F;head&gt;&lt;body&gt;可见文本...&lt;&#x2F;body&gt;&lt;&#x2F;html&gt; 基本标签12345678910111213141516171819&lt;h1&gt;最大的标题&lt;&#x2F;h1&gt;&lt;h2&gt; . . . &lt;&#x2F;h2&gt;&lt;h3&gt; . . . &lt;&#x2F;h3&gt;&lt;h4&gt; . . . &lt;&#x2F;h4&gt;&lt;h5&gt; . . . &lt;&#x2F;h5&gt;&lt;h6&gt;最小的标题&lt;&#x2F;h6&gt;&lt;p&gt;这是一个段落。&lt;&#x2F;p&gt;&lt;br&gt; （换行）&lt;hr&gt; （水平线）&lt;!-- 这是注释 --&gt; 文本格式化123456789101112131415161718192021222324252627282930313233&lt;b&gt;粗体文本&lt;&#x2F;b&gt;&lt;code&gt;计算机代码&lt;&#x2F;code&gt;&lt;em&gt;强调文本&lt;&#x2F;em&gt;&lt;i&gt;斜体文本&lt;&#x2F;i&gt;&lt;kbd&gt;键盘输入&lt;&#x2F;kbd&gt;&lt;pre&gt;预格式化文本&lt;&#x2F;pre&gt;&lt;small&gt;更小的文本&lt;&#x2F;small&gt;&lt;strong&gt;重要的文本&lt;&#x2F;strong&gt;&lt;abbr&gt; （缩写）&lt;address&gt; （联系信息）&lt;bdo&gt; （文字方向）&lt;blockquote&gt; （从另一个源引用的部分）&lt;cite&gt; （工作的名称）&lt;del&gt; （删除的文本）&lt;ins&gt; （插入的文本）&lt;sub&gt; （下标文本）&lt;sup&gt; （上标文本） 链接123456789101112普通的链接：&lt;a href&#x3D;&quot;http:&#x2F;&#x2F;www.example.com&#x2F;&quot;&gt;链接文本&lt;&#x2F;a&gt;图像链接： &lt;a href&#x3D;&quot;http:&#x2F;&#x2F;www.example.com&#x2F;&quot;&gt;&lt;img src&#x3D;&quot;URL&quot;alt&#x3D;&quot;替换文本&quot;&gt;&lt;&#x2F;a&gt;邮件链接： &lt;a href&#x3D;&quot;mailto:webmaster@example.com&quot;&gt;发送e-mail&lt;&#x2F;a&gt;书签：&lt;a id&#x3D;&quot;tips&quot;&gt;提示部分&lt;&#x2F;a&gt;&lt;a href&#x3D;&quot;#tips&quot;&gt;跳到提示部分&lt;&#x2F;a&gt; 图片1&lt;img src&#x3D;&quot;URL&quot; alt&#x3D;&quot;替换文本&quot; height&#x3D;&quot;42&quot; width&#x3D;&quot;42&quot;&gt; 区块1234567891011&lt;style type&#x3D;&quot;text&#x2F;css&quot;&gt;h1 &#123;color:red;&#125;p &#123;color:blue;&#125;&lt;&#x2F;style&gt;&lt;div&gt;文档中的块级元素&lt;&#x2F;div&gt;&lt;span&gt;文档中的内联元素&lt;&#x2F;span&gt; 无序有序列表12345678910111213141516&lt;ul&gt; &lt;li&gt;项目&lt;&#x2F;li&gt; &lt;li&gt;项目&lt;&#x2F;li&gt;&lt;&#x2F;ul&gt;&lt;ol&gt; &lt;li&gt;第一项&lt;&#x2F;li&gt; &lt;li&gt;第二项&lt;&#x2F;li&gt;&lt;&#x2F;ol&gt; 定义列表1234567891011&lt;dl&gt; &lt;dt&gt;项目 1&lt;&#x2F;dt&gt; &lt;dd&gt;描述项目 1&lt;&#x2F;dd&gt; &lt;dt&gt;项目 2&lt;&#x2F;dt&gt; &lt;dd&gt;描述项目 2&lt;&#x2F;dd&gt;&lt;&#x2F;dl&gt; 表格12345678910111213141516171819&lt;table border&#x3D;&quot;1&quot;&gt; &lt;tr&gt; &lt;th&gt;表格标题&lt;&#x2F;th&gt; &lt;th&gt;表格标题&lt;&#x2F;th&gt; &lt;&#x2F;tr&gt; &lt;tr&gt; &lt;td&gt;表格数据&lt;&#x2F;td&gt; &lt;td&gt;表格数据&lt;&#x2F;td&gt; &lt;&#x2F;tr&gt;&lt;&#x2F;table&gt; 框架1&lt;iframe src&#x3D;&quot;demo_iframe.htm&quot;&gt;&lt;&#x2F;iframe&gt; 表单1234567891011121314151617181920212223242526272829&lt;form action&#x3D;&quot;demo_form.php&quot; method&#x3D;&quot;post&#x2F;get&quot;&gt;&lt;input type&#x3D;&quot;text&quot; name&#x3D;&quot;email&quot; size&#x3D;&quot;40&quot; maxlength&#x3D;&quot;50&quot;&gt;&lt;input type&#x3D;&quot;password&quot;&gt;&lt;input type&#x3D;&quot;checkbox&quot; checked&#x3D;&quot;checked&quot;&gt;&lt;input type&#x3D;&quot;radio&quot; checked&#x3D;&quot;checked&quot;&gt;&lt;input type&#x3D;&quot;submit&quot; value&#x3D;&quot;Send&quot;&gt;&lt;input type&#x3D;&quot;reset&quot;&gt;&lt;input type&#x3D;&quot;hidden&quot;&gt;&lt;select&gt;&lt;option&gt;苹果&lt;&#x2F;option&gt;&lt;option selected&#x3D;&quot;selected&quot;&gt;香蕉&lt;&#x2F;option&gt;&lt;option&gt;樱桃&lt;&#x2F;option&gt;&lt;&#x2F;select&gt;&lt;textarea name&#x3D;&quot;comment&quot; rows&#x3D;&quot;60&quot; cols&#x3D;&quot;20&quot;&gt;&lt;&#x2F;textarea&gt;&lt;&#x2F;form&gt; 实体12345&lt; 等同于 &lt;&gt; 等同于 &gt;&amp;#169; 等同于 ©","tags":[{"name":"HTML","slug":"HTML","permalink":"http://yoursite.com/tags/HTML/"}]},{"title":"HTML入门","date":"2020-05-21T09:30:54.000Z","path":"2020/05/21/HTML入门/","text":"HTML的入门学习 12345678910111213&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset&#x3D;&quot;utf-8&quot;&gt;&lt;title&gt;Vain&lt;&#x2F;title&gt;&lt;&#x2F;head&gt;&lt;body&gt;&lt;h1&gt;标题&lt;&#x2F;h1&gt;&lt;p&gt;段落。&lt;&#x2F;p&gt;&lt;&#x2F;body&gt;&lt;&#x2F;html&gt; &lt;!DOCTYPE html&gt; 声明为 HTML5 文档&lt;html&gt; 元素是 HTML 页面的根元素&lt;head&gt; 元素包含了文档的元（meta）数据，如 &lt;meta charset=”utf-8”&gt;定义网页编码格式为 utf-8（中文）。&lt;title&gt; 元素描述了文档的标题&lt;body&gt; 元素包含了可见的页面内容&lt;h1&gt; 元素定义一个大标题&lt;p&gt; 元素定义一个段落 …… 注：在浏览器的页面上使用键盘上的 F12 按键开启调试模式，就可以看到组成标签。 Hyper Text Markup Language——标记语言 HTML元素包括 &lt;标签&gt;内容&lt;/标签&gt; 开始标签-内容-结束标签 注：只有 &lt;body&gt;才会在浏览器中显示。 编译器Visual Studio Code（简称 VS Code）。 新建HTML文件另存为HTML文件在浏览器中运行这个 HTML 文件 元素 开始标签 含义 结束标签 &lt;p&gt; 这是一个段落 &lt;/p&gt; &lt;a href=”default.htm”&gt; 这是一个链接 &lt;/a&gt; &lt;br&gt; 换行 &lt;h1&gt; 这是一个标题 &lt;/h1&gt; 标题（Heading）是通过&lt;h1&gt;-&lt;h6&gt;标签进行定义的。&lt;h1&gt;定义最大的标题。&lt;h6&gt;定义最小的标题。请确保将HTML标题标签只用于标题。不要仅仅是为了生成粗体或大号的文本而使用标题。浏览器会自动地在标题的前后添加空行。 搜索引擎使用标题为您的网页的结构和内容编制索引。&lt;br&gt;就是没有关闭标签的空元素，但使用&lt;br/&gt;更正规。 &lt;hr&gt; 标签在 HTML 页面中创建水平线。 &lt;!– 这是一个注释 –&gt; &lt;body&gt; 定义文档的主体 标签使用小写。 属性 类型 作用 class 为html元素定义一个或多个类名 id 定义元素的唯一id style 规定元素的行内样式（inlinestyle） title 描述了元素的额外信息(作为工具条使用) 属性值应该始终被包括在双引号内；在某些个别的情况下，比如属性值本身就含有双引号，则使用单引号。 属性使用小写。 文本格式化&lt;b&gt;加粗文本&lt;/b&gt; &lt;i&gt;斜体文本&lt;/i&gt; &lt;code&gt;电脑自动输出&lt;/code&gt; 这是 &lt;sub&gt; 下标&lt;/sub&gt; 和 &lt;sup&gt; 上标&lt;/sup&gt; 链接&lt;p&gt;&lt;a href=”//www.microsoft.com/&quot;\\&gt;本文本\\&lt;/a&gt;是一个指向万维网上的页面的链接。&lt;/p&gt; 默认情况下：一个未访问过的链接显示为蓝色字体并带有下划线。访问过的链接显示为紫色并带有下划线。点击链接时，链接显示为红色并带有下划线。 可以通过属性定义链接，如target、id，已适应不同的场景和需求。可以对超链接设置CSS样式，展示样式会根据CSS的设定而显示。 头部&lt;head&gt;元素包含了所有的头部标签元素。在&lt;head&gt;元素中你可以插入脚本（scripts）,样式文件（CSS），及各种meta信息。 可以添加在头部区域的元素标签为:&lt;title&gt;,&lt;style&gt;,&lt;meta&gt;,&lt;link&gt;,&lt;script&gt;,&lt;noscript&gt;和&lt;base&gt;。&lt;script&gt;标签用于加载脚本文件，如：JavaScript。 标签 描述 &lt;head&gt; 定义了文档的信息 &lt;title&gt; 定义了文档的标题 &lt;base&gt; 定义了页面链接标签的默认链接地址 &lt;link&gt; 定义了一个文档和外部资源之间的关系 &lt;meta&gt; 定义了HTML文档中的元数据 &lt;script&gt; 定义了客户端的脚本文件 &lt;style&gt; 定义了HTML文档的样式文件 CSSCSS (Cascading Style Sheets) 用于渲染HTML元素标签的样式。 CSS可以通过以下方式添加到HTML中: 1·内联样式-在HTML元素中使用”style”属性； 2·内部样式表-在HTML文档头部&lt;head&gt;区域使用&lt;style&gt;元素来包含CSS； 3·外部引用-使用外部CSS文件。 最好的方式是通过外部引用CSS文件。 对于大部分标签，”内联”和”外引”两种方式均可，且修改父级标签，子级标签特性也会改变。但某些标签确无法通过修改父级标签来改变子级标签特性，如a标签，修改其颜色特性，必须直接修改a标签的特性才可。 图像&lt;img border=”0” src=”/images/pulpit.jpg” alt=”Pulpit rock” width=”304”height=”228”&gt; 加载页面时，要注意插入页面图像的路径，如果不能正确设置图像的位置，浏览器无法加载图片，图像标签就会显示一个破碎的图片。 表格表格由&lt;table&gt;标签来定义。每个表格均有若干行（由&lt;tr&gt;标签定义），每行被分割为若干单元格（由&lt;td&gt;标签定义）。字母td指表格数据（tabledata），即数据单元格的内容。数据单元格可以包含文本、图片、列表、段落、表单、水平线、表格等等。 列表等不赘述。 区块大多数HTML元素被定义为块级元素或内联元素。 ——块级元素在浏览器显示时，通常会以新行来开始（和结束）。 HTML&lt;div&gt;元素是块级元素，它可用于组合其他HTML元素的容器。 &lt;div&gt;元素没有特定的含义。除此之外，由于它属于块级元素，浏览器会在其前后显示折行。如果与CSS一同使用，&lt;div&gt;元素可用于对大的内容块设置样式属性。&lt;div&gt;元素的另一个常见的用途是文档布局。 ——内联元素在显示时通常不会以新行开始。 HTML&lt;span&gt;元素是内联元素，可用作文本的容器，&lt;span&gt;元素也没有特定的含义。 当与CSS一同使用时，&lt;span&gt;元素可用于为部分文本设置样式属性。 布局网页布局对改善网站的外观非常重要。 大多数网站可以使用&lt;div&gt;或者&lt;table&gt;元素来创建多列。CSS用于对元素进行定位，或者为页面创建背景以及色彩丰富的外观。 使用CSS最大的好处是，如果把CSS代码存放到外部样式表中，那么站点会更易于维护。通过编辑单一的文件，就可以改变所有页面的布局。 表单HTML 表单用于收集不同类型的用户输入。 表单是一个包含表单元素的区域。表单元素是允许用户在表单中输入内容,比如：文本域(textarea)、下拉列表、单选框(radio-buttons)、复选框(checkboxes)等等。表单使用表单标签&lt;form&gt;来设置。 文本域通过&lt;inputtype=”text”&gt;标签来设定，当用户要在表单中键入字母、数字等内容时，就会用到文本域。 密码字段通过标签&lt;input type=”password”&gt;来定义。 &lt;inputtype=”radio”&gt;标签定义了表单单选框选项。可以设置以下几个属性：value、name、checked。 &lt;inputtype=”checkbox”&gt;定义了复选框。用户需要从若干给定的选择中选取一个或若干选项。 &lt;inputtype=”submit”&gt;定义了提交按钮。当用户单击确认按钮时，表单的内容会被传送到另一个文件。表单的动作属性定义了目的文件的文件名。由动作属性定义的这个文件通常会对接收到的输入数据进行相关的处理。 此外还有下拉列表选项、计算结果等。 框架通过使用框架，可以在同一个浏览器窗口中显示不止一个页面。 iframe语法: &lt;iframesrc=”URL”&gt;&lt;/iframe&gt; 该URL指向不同的网页。 颜色HTML颜色由一个十六进制符号来定义，这个符号由红色、绿色和蓝色的值组成（RGB）。 每种颜色的最小值是0（十六进制：#00）。最大值是255（十六进制：#FF）。 RGBA的意思是（Red-Green-Blue-Alpha）它是在RGB上扩展包括了“alpha”通道，运行对颜色值设置透明度。 141个颜色名称是在HTML和CSS颜色规范定义的（17标准颜色，再加124）。 脚本JavaScript使HTML页面具有更强的动态和交互性。 &lt;script&gt;标签用于定义客户端脚本，比如JavaScript，其既可包含脚本语句，也可通过src属性指向外部脚本文件。 &lt;noscript&gt;标签提供无法使用脚本时的替代内容，比方在浏览器禁用脚本时，或浏览器不支持客户端脚本时；只有在浏览器不支持脚本或者禁用脚本时，才会显示&lt;noscript&gt;元素中的内容。 字符实体HTML中的预留字符必须被替换为字符实体，以防浏览器误认为它们是标签。 HTML中的常用字符实体是不间断空格(&amp;nbsp;)。浏览器总是会截短HTML页面中的空格。如果在文本中写10个空格，在显示该页面之前，浏览器会删除它们中的9个。如需在页面中增加空格的数量，则需要使用&nbsp;字符实体。 URLURL——统一资源定位器是一个网页地址。 常见的URL Scheme（定义因特网服务的类型）—— Scheme 访问 用于… http 超文本传输协议 以 http:// 开头的普通网页。不加密。 https 安全超文本传输协议 安全网页，加密所有信息交换。 ftp 文件传输协议 用于将文件下载或上传至网站。 file 您计算机上的文件。","tags":[{"name":"HTML","slug":"HTML","permalink":"http://yoursite.com/tags/HTML/"}]},{"title":"leetcode_1","date":"2020-05-21T06:41:24.000Z","path":"2020/05/21/leetcode-1/","text":"1.两数之和 给定一个数组以及一个目标值——在该数组中找出和为目标值的那两个整数，并返回他们的数组下标。 解： 暴力法—— 遍历数组，对于每一个函数x，都再次遍历数组查找是否存在于target-x相等的元素。 两遍哈希表—— Hash表支持以近似恒定的速度查找元素，通过以空间换取速度的方式。使用两次迭代，第一次迭代将每个元素的值和它的索引添加到表中，；第二次迭代检查每个元素所对应的目标元素target-x是否存在于表中。 12345678910111213class Solution &#123;public: vector&lt;int&gt; twoSum(vector&lt;int&gt;&amp; nums, int target) &#123; unordered_map&lt;int,int&gt; m; for(int i = 0; i&lt;nums.size(); i++) m[nums[i]] = i; //向map中添加元素 for(int i = 0; i&lt;nums.size(); i++)&#123; if(m.find(target-nums[i]) != m.end() &amp;&amp; m[target-nums[i]] != i)//如果m中存在对应的键值，且不为i return &#123;i, m[target-nums[i]]&#125;; &#125; return &#123;&#125;; &#125;&#125;; 复杂度暴力法 时间复杂度：O(n2)。对于每一个元素，都需要遍历整个数组来查找是否存在target-x。 空间复杂度：O(1)。 两遍哈希表 时间复杂度：O(n)。把数组遍历了两次，由于哈希表将查找时间缩短到O(1)，所以时间复杂度为O(n)。 空间复杂度：O(n)。所需的额外空间取决于哈希表中存储的元素数量，该表中存储了n个元素。 Tip：HashMap在resize、put的时候消耗了很多时间没有计算在内，但这些其实都属于初始化范畴，在实际开发中，其实是一次性开销。 Java集合类中的Map.containsKey()方法判断Map集合对象中是否包含指定的键名。如果Map集合中包含指定的键名，则返回true，否则返回false。 也去专门去查了hashMap.containsKey()的时间复杂度，使用指针指向数组引用，时间复杂度为O(1)，未命中时，才回去遍历红黑树，时间复杂度为O(n)，如果仔细地挑选哈希函数，在哈希表中进行查找的用时应当被摊销为O(1)。 C++中，在map中查找key为k的元素，返回指向它的迭代器。若k不存在，返回map::end，返回值是一个迭代器，成功返回迭代器指向要查找的元素，失败返回的迭代器指向end。 map unordered_map #include &lt;map&gt; #include &lt;unordered_map&gt; map内部实现了一个红黑树，该结构具有自动排序的功能，因此map内部的所有元素都是有序的，红黑树的效率决定了map的效率。 unordered_map内部实现了一个哈希表，因此其元素的排列顺序是杂乱的，无序的。 红黑树、有序、空间占用率高 哈希表、无序、耗费时间多 对于那些有顺序要求的问题，用map会更高效一些 对于查找问题，unordered_map会更加高效一些","tags":[{"name":"array","slug":"array","permalink":"http://yoursite.com/tags/array/"}]},{"title":"leetcode_167","date":"2020-05-21T03:39:09.000Z","path":"2020/05/21/leetcode-167/","text":"167.两数之和II -输入有序数组 给定一个升序排列的数组以及一个目标值——求数组中的两个元素和为目标值，并按序输出两个元素的下标。 解： 双指针法——分别记录第一个元素和最后一个元素，求和后与target值比较大小，偏大则移动尾指针（值变小），偏小则移动头指针（值变大），等于目标值则按序输出头尾指针。 复杂度时间复杂度：O(n)。每个元素最多被访问一次。 空间复杂度：O(1)。只是用了两个指针。 Tip：vector作为参数的三种传参方式 c++中常用的vector容器作为参数时（为说明问题，用二维vector）： function1(std::vector&lt;std::vector&lt;int&gt; &gt; vec)，传值 function2(std::vector&lt;std::vector&lt;int&gt; &gt;&amp; vec)，传引用 function3(std::vector&lt;std::vector&lt;int&gt; &gt;* vec)，传指针 三种方式对应的调用形式分别为： function1(vec)，传入值 function2(vec)，传入引用 function3(&amp;vec),传入地址 三种方式在函数调用时是否了vector的拷贝构造函数： 会发生拷贝构造 不会发生拷贝构造 不会发生拷贝构造 函数体 函数调用 拷贝构造函数 void 函数名(vector&lt;int&gt; obj); deal( vec ); void 函数名(vector&lt;int&gt;* pobj); deal( &amp;vec ); void 函数名(const vector&lt;int&gt;* pobj); deal( &amp;vec ); 调用时不会调用拷贝构造函数 void 函数名(vector&lt;int&gt;&amp; obj); deal( vec ); void 函数名(const vector&lt;int&gt;&amp; obj); deal( vec ); 调用时会调用拷贝构造函数 *如果需要在函数中对vector容器中数据调换顺序等操作需要是引用传递 1234567vector&lt;int&gt; twoSum(vector&lt;int&gt;&amp; numbers, int target) &#123; //… int low = 0, high = numbers.size() - 1; //… return &#123;low + 1, high + 1&#125;; //…&#125;","tags":[{"name":"array","slug":"array","permalink":"http://yoursite.com/tags/array/"}]},{"title":"leetcode_941","date":"2020-05-20T09:29:15.000Z","path":"2020/05/20/leetcode-941/","text":"941.有效的山脉数组 检查一个数组是否符合山脉数组——数组元素大于等于三个，且存在某中间元素，其前元素值为递增，其后元素值为递减。 解： 按照数组下标扫描即可，判断出峰元素（从1到length-1的前一个），然后检查其后是否递减，判断以及检查中若有相等或者相反变化的部分，则return false。","tags":[{"name":"array","slug":"array","permalink":"http://yoursite.com/tags/array/"}]},{"title":"leetcode_914","date":"2020-05-20T08:43:13.000Z","path":"2020/05/20/leetcode-914/","text":"914.卡牌分组 检查一个数组是否符合分组的规则——可以分成大小一样的若干数组且各个数组中的数字都一样（子数组长度最小为2）。 解： 统计各个数字出现的次数，然后求其是否存在最大公约数大于等于2。 12345678910111213141516//求最大公约数int gcd(int a,int b)&#123; if(b == 0) return a; return gcd(b,a%b);&#125;class Solution &#123;public: bool hasGroupsSizeX(vector\\&lt;int\\&gt;&amp; deck) &#123; int bucket[10000] = &#123;0&#125;; int g = 0; for (int d : deck) bucket[d]++; //基于范围的for循环(C++11) for (int b : bucket) g = gcd(b, g); return g \\&gt;= 2; &#125;&#125;; Tip： for 语句允许简单的范围迭代： 1234567891011int my_array[5] = &#123;1, 2, 3, 4, 5&#125;;// 每个数组元素乘于 2for (int &amp;x : my_array)&#123; x *= 2; cout &lt;&lt; x &lt;&lt; endl;&#125;// auto 类型也是 C++11 新标准中的，用来自动获取变量的类型for (auto &amp;x : my_array) &#123; x *= 2; cout &lt;&lt; x &lt;&lt; endl;&#125; 上面for述句的第一部分定义被用来做范围迭代的变量，就像被声明在一般for循环的变量一样，其作用域仅只于循环的范围。而在”:”之后的第二区块，代表将被迭代的范围。","tags":[{"name":"array","slug":"array","permalink":"http://yoursite.com/tags/array/"}]},{"title":"人物塑造-第二真","date":"2020-05-19T08:48:38.000Z","path":"2020/05/19/人物塑造-第二真/","text":"人的认知是片面独立的。 每个人对他人的认定大多源于某个既定影响，然后随着某个契机，这个印象不断完善，人的好奇心，对世界的感官，都在促使这件事的完成。 对这个契机的认知是价值观的体现，人们喜欢把想象中的自己沉浸在其中，用想象中的自己去判断一维的好坏。 是想象中的自己，因为人们对自己的认知偏颇难以避免，这种认知同样是片面的，人们在做决定的时候更多的是内心存在选择后，尝试去反驳和证明，反驳和证明都需要存在，这种公允的，中庸的冷静，在和渴望挂不上钩的时候是必然存在的，渴望存在前和是如此经历被琢磨的。 人们判断他人、事物的时候把想象中的自己带入，而判断的主角和法官都是自己的时候，人们把想象带入，这是更深一层的渴望，如果说上者人们还顾及道德和法律，在判断自己的人生时，人们的思绪更多像个辩论赛，这场辩论的比分则由理性的逻辑和感性的价值观决定了。 人们对自己的认知和对别人的认知是完全不同的存在，本文要讨论的就是对他人的认知。 对他人的认知是把想象中的自己带入去判决一维的正误。 人物的塑造譬如肖像描写，仅仅只是第一印象的加成，在文学艺术作品里，所谓人物塑造栩栩如生是需要后期的那个契机的，人物形象丰满必须要有的过程。 塑造人物的手法套路大多出于经验，很成熟的方法论，然而其内核就是完成对读者的认知引导。成功塑造人物需要第一印象的捏造以及后续的契机设立，这种解构的方式是对塑造手法的总结。 说回人们对他人的认知，人的内在逻辑其实是单向的，不仅仅是对体验结果的判决，更是对契机引起的变化的一种单向，这就是反差存在的逻辑。 被成功塑造的恶人，在肖像方面往往是文质彬彬甚至美轮美奂的，其恶当然不只是源于人们对他后续行径的一种价值观判决，更多的，是一种反差的存在，人们的内在逻辑简单化，一者，判决的理智会被这种曲线的填满，人们更倾向于坚信后来被说服的事情，这是源于对后悔的习性，轻车熟路的悔不当初并拍案叫绝；二者是对他人认知的成长判决的简单性，这种判决源于其反差的方向，和肖像的相对方向，这就是人们心中的预设期望。 预设期望源于对第一印象的判决，沉浸式判决加以经验，让肖像在人心里留下一个正或负的分数，而后的契机成长，如果正数的正向成长，人们会在逻辑上表示，哦，果然是这样，这就是毫无新意的普通好人或者坏人，但如果是负数的正向成长，那会给人以冲击，所谓丰满，就是让人们意识到自己的认知错误，人们感觉到成长，感官甚至人生层面上的丰满。 对于好人的预设是一样的，瑕疵感为后来的正向成长加分的，除了真实的不完美，更多的和负数的正面成长的逻辑相似，人们倾向于相信第二个真理。当然也可以简单理解为经验，譬如欲扬先抑或者是巴黎圣母院中的克洛德。 第二个真理的说服力是一个很强大的存在。 颠覆给人一种辩证的真实感，世界并不是非黑即白的，人物的塑造当然不只是为了正面这正误的共生性，更多的还是去引导这种逻辑，操控观者的认知过程，没有影视作品会想要用负数印象加一个正向成长来塑造负面形象的，即使这种负面形象是一种复杂的，难判定好与坏的人物形象，作品也会有偏颇，有初衷与结果。 第二个真理是引导思维认知的重要理论依据。","tags":[{"name":"随笔","slug":"随笔","permalink":"http://yoursite.com/tags/%E9%9A%8F%E7%AC%94/"}]},{"title":"lu","date":"2020-04-05T07:48:58.000Z","path":"2020/04/05/lu/","text":"热爱","tags":[{"name":"随笔","slug":"随笔","permalink":"http://yoursite.com/tags/%E9%9A%8F%E7%AC%94/"}]},{"title":"x","date":"2020-04-05T07:48:18.000Z","path":"2020/04/05/x/","text":"Practice in individual leetcode Three questions per article per day Tags and knowledge extension are important algorithm According to leetcode, summarize the application of various classical algorithms A single article to tabulate various algorithms python Grammar and application C++ Grammar and application artificial intelligence Scipy-python Sklearm-python Deep Learning(to realize machine learning) Machine learning taught by Wu enda Neural network(after the fifth lesson) (by 3Blue1Brow) Deep learning(a flower color book) by Ian Goodfellow Sequence modeling linux operation and maintenance development bottom layer","tags":[{"name":"x","slug":"x","permalink":"http://yoursite.com/tags/x/"}]}]